<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Filter&amp;Listener&amp;Ajax&amp;Axios&amp;JSON</title>
    <url>/2023/12/02/Filter-Listener-Ajax/</url>
    <content><![CDATA[<h2 id="1-filter"><a class="markdownIt-Anchor" href="#1-filter"></a> 1. Filter</h2>
<h3 id="11-filter概述"><a class="markdownIt-Anchor" href="#11-filter概述"></a> 1.1  Filter概述</h3>
<p>Filter 表示过滤器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。</p>
<p>过滤器可以把对资源的请求<mark>拦截</mark>下来，从而实现一些特殊的功能。</p>
<p>在没有使用过滤器Filter时浏览器可以访问服务器上的所有的资源（servlet、jsp、html等），而在访问到这些资源之前可以使过滤器拦截来下，也就是说在访问资源之前会先经过 Filter，如下图</p>
<p><img src="image-20210823184657328.png" alt="" /></p>
<p>拦截器拦截到后可以做什么功能呢？</p>
<p>**过滤器一般完成一些通用的操作。**比如每个资源都要写一些代码完成某个功能，我们总不能在每个资源中写这样的代码吧，而此时我们可以将这些代码写在过滤器中，因为请求每一个资源都要经过过滤器。</p>
<p>我们希望实现的效果是在页面中用户如果登陆过了就跳转到品牌数据展示的页面；如果没有登陆就跳转到登陆页面让用户进行登陆，要实现这个效果需要在每一个资源中都写上这段逻辑，而像这种通用的操作，我们就可以放在过滤器中进行实现。这个就是<strong>权限控制</strong>，以后我们还会进行细粒度权限控制。过滤器还可以做 <code>统一编码处理</code>、 <code>敏感字符处理</code> 等等…</p>
<h3 id="12-filter快速入门"><a class="markdownIt-Anchor" href="#12-filter快速入门"></a> 1.2  Filter快速入门</h3>
<h4 id="121-开发步骤"><a class="markdownIt-Anchor" href="#121-开发步骤"></a> 1.2.1  开发步骤</h4>
<p>进行 <code>Filter</code> 开发分成以下三步实现</p>
<ul>
<li>
<p>定义类，实现 Filter接口，并重写其所有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置Filter拦截资源的路径：在类上定义 <code>@WebFilter</code> 注解。而注解的 <code>value</code> 属性值 <code>/*</code> 表示拦截所有的资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在doFilter方法中输出一句话，并放行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;filter 被执行了...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放行</span></span><br><span class="line">    filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码中的 <code>chain.doFilter(request,response);</code> 就是放行，也就是让其访问本该访问的资源。</p>
</blockquote>
</li>
</ul>
<h4 id="122-代码演示"><a class="markdownIt-Anchor" href="#122-代码演示"></a> 1.2.2  代码演示</h4>
<p>创建一个Maven Web项目，在webapp下有一个 <code>hello.jsp</code> 页面。</p>
<p><code>pom.xml</code> 配置文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>filter-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>hello.jsp</code> 页面内容如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;hello JSP~&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>我们现在在浏览器输入 <code>http://localhost/filter-demo/hello.jsp</code> 访问 <code>hello.jsp</code> 页面，这里是可以访问到 <code>hello.jsp</code> 页面内容的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello JSP~</span><br></pre></td></tr></table></figure>
<p>接下来编写过滤器。过滤器是 Web 三大组件之一，所以我们将 <code>filter</code> 创建在 <code>com.itheima.web.filter</code> 包下，起名为 <code>FilterDemo</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FilterDemo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重启启动服务器，再次重新访问 <code>hello.jsp</code> 页面，这次发现页面没有任何效果，但是在 <code>idea</code> 的控制台可以看到如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FilterDemo...</span><br></pre></td></tr></table></figure>
<p>上述效果说明 <code>FilterDemo</code> 这个过滤器的 <code>doFilter()</code> 方法执行了，但是为什么在浏览器上看不到 <code>hello.jsp</code> 页面的内容呢？这是因为在 <code>doFilter()</code> 方法中添加放行的方法才能访问到 <code>hello.jsp</code> 页面。那就在 <code>doFilter()</code> 方法中添加放行的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//放行</span></span><br><span class="line"> chain.doFilter(request,response);</span><br></pre></td></tr></table></figure>
<p>再次重启服务器并访问 <code>hello.jsp</code> 页面，发现这次就可以在浏览器上看到页面效果。</p>
<p><strong><code>FilterDemo</code> 过滤器完整代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1.FilterDemo...&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-filter执行流程"><a class="markdownIt-Anchor" href="#13-filter执行流程"></a> 1.3  Filter执行流程</h3>
<p><img src="image-20210823194830074.png" alt="" /></p>
<p>如上图是使用过滤器的流程，我们通过以下问题来研究过滤器的执行流程：</p>
<ul>
<li>
<p>放行后访问对应资源，资源访问完成后，还会回到Filter中吗？</p>
<p>从上图就可以看出肯定 <strong>会</strong> 回到Filter中</p>
</li>
<li>
<p>如果回到Filter中，是重头执行还是执行放行后的逻辑呢？</p>
<p>如果是重头执行的话，就意味着 <code>放行前逻辑</code> 会被执行两次，肯定不会这样设计了；所以访问完资源后，会回到 <code>放行后逻辑</code>，执行该部分代码。</p>
</li>
</ul>
<p>通过上述的说明，我们就可以总结Filter的执行流程如下：</p>
<pre><code class="highlight mermaid">graph LR
A[执行放行前逻辑]--&gt;B[放行]
B--&gt;C[访问资源]
C--&gt;D[执行放行后逻辑]</code></pre>
<p>接下来我们通过代码验证一下，在 <code>doFilter()</code> 方法前后都加上输出语句，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//1. 放行前，对request数据进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1.FilterDemo&quot;</span>);</span><br><span class="line">        <span class="comment">//放心</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        <span class="comment">//2. 放行后，对Response数据进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.FilterDemo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时在 <code>hello.jsp</code> 页面加上输出语句，如下</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;hello JSP~&lt;/h1&gt;</span><br><span class="line">&lt;% System.out.println(<span class="string">&quot;2.FilterDemo&quot;</span>); %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>执行访问该资源打印的顺序是按照我们标记的标号进行打印的话，说明我们上边总结出来的流程是没有问题的。启动服务器访问 <code>hello.jsp</code> 页面，在控制台打印的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.FilterDemo...</span><br><span class="line">2.hello jsp</span><br><span class="line">3.FilterDemo...</span><br></pre></td></tr></table></figure>
<p>以后我们可以将对请求进行处理的代码放在放行之前进行处理，而如果请求完资源后还要对响应的数据进行处理时可以在放行后进行逻辑处理。</p>
<h3 id="14-filter拦截路径配置"><a class="markdownIt-Anchor" href="#14-filter拦截路径配置"></a> 1.4  Filter拦截路径配置</h3>
<p>拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 <code>@WebFilter</code> 注解进行配置。如：<code>@WebFilter(&quot;拦截路径&quot;)</code></p>
<p>拦截路径有如下四种配置方式：</p>
<ul>
<li>拦截具体的资源：/index.jsp：只有访问index.jsp时才会被拦截</li>
<li>目录拦截：/user/*：访问/user下的所有资源，都会被拦截</li>
<li>后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截</li>
<li>拦截所有：/*：访问所有资源，都会被拦截</li>
</ul>
<p>通过上面拦截路径的学习，大家会发现拦截路径的配置方式和 <code>Servlet</code> 的请求资源路径配置方式一样，但是表示的含义不同。</p>
<h3 id="15-过滤器链"><a class="markdownIt-Anchor" href="#15-过滤器链"></a> 1.5  过滤器链</h3>
<h4 id="151-概述"><a class="markdownIt-Anchor" href="#151-概述"></a> 1.5.1  概述</h4>
<p>过滤器链是指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。</p>
<p>如下图就是一个过滤器链，我们学习过滤器链主要是学习过滤器链执行的流程</p>
<p><img src="image-20210823215835812.png" alt="" /></p>
<p>上图中的过滤器链执行是按照以下流程执行：</p>
<ol>
<li>执行 <code>Filter1</code> 的放行前逻辑代码</li>
<li>执行 <code>Filter1</code> 的放行代码</li>
<li>执行 <code>Filter2</code> 的放行前逻辑代码</li>
<li>执行 <code>Filter2</code> 的放行代码</li>
<li>访问到资源</li>
<li>执行 <code>Filter2</code> 的放行后逻辑代码</li>
<li>执行 <code>Filter1</code> 的放行后逻辑代码</li>
</ol>
<pre><code class="highlight mermaid">graph TB
A[执行Filter1的放行前逻辑代码] --&gt;|放行| B[执行Filter1的放行代码]
B --&gt;|放行| C[执行Filter2的放行前逻辑代码]
C --&gt;|放行| D[执行Filter2的放行代码]
D --&gt;|访问到资源| E[访问到资源]
E --&gt;|放行| F[执行Filter2的放行后逻辑代码]
F --&gt;|放行| G[执行Filter1的放行后逻辑代码]
</code></pre>
<p>以上流程串起来就像一条链子，故称之为过滤器链。</p>
<h4 id="152-代码演示"><a class="markdownIt-Anchor" href="#152-代码演示"></a> 1.5.2  代码演示</h4>
<ul>
<li>
<p>编写第一个过滤器 <code>FilterDemo</code> ，配置成拦截所有资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 放行前，对 request数据进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1.FilterDemo...&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        <span class="comment">//2. 放行后，对Response 数据进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.FilterDemo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编写第二个过滤器 <code>FilterDemo2</code> ，配置成拦截所有资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo2</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 放行前，对 request数据进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2.FilterDemo...&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        <span class="comment">//2. 放行后，对Response 数据进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4.FilterDemo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改 <code>hello.jsp</code> 页面中脚本的输出语句</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;hello JSP~&lt;/h1&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        System.out.println(<span class="string">&quot;3.hello jsp&quot;</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动服务器，在浏览器输入 <code>http://localhost/filter-demo/hello.jsp</code> 进行测试，在控制台打印内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.FilterDemo...</span><br><span class="line">2.FilterDemo...</span><br><span class="line">3.hello jsp</span><br><span class="line">4.FilterDemo...</span><br><span class="line">5.FilterDemo...</span><br></pre></td></tr></table></figure>
<p>从结果可以看到确实是按照我们之前说的执行流程进行执行的。</p>
</li>
</ul>
<h4 id="153-问题"><a class="markdownIt-Anchor" href="#153-问题"></a> 1.5.3  问题</h4>
<p>上面代码中为什么是先执行 <code>FilterDemo</code> ，后执行 <code>FilterDemo2</code> 呢？</p>
<p>我们现在使用的是注解配置Filter，而这种配置方式的优先级是按照过滤器类名(字符串)的自然排序。</p>
<p>比如有如下两个名称的过滤器 ： <code>BFilterDemo</code> 和 <code>AFilterDemo</code> 。那一定是 <code>AFilterDemo</code> 过滤器先执行。</p>
<h2 id="2-listener"><a class="markdownIt-Anchor" href="#2-listener"></a> 2. Listener</h2>
<h3 id="21-概述"><a class="markdownIt-Anchor" href="#21-概述"></a> 2.1  概述</h3>
<ul>
<li>
<p>Listener 表示监听器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。</p>
</li>
<li>
<p>监听器可以监听就是在 <code>application</code>，<code>session</code>，<code>request</code> 三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p>
<p>request 和 session 我们学习过。而 <code>application</code> 是 <code>ServletContext</code> 类型的对象。</p>
<p><code>ServletContext</code> 代表整个web应用，在服务器启动的时候，tomcat会自动创建该对象。在服务器关闭时会自动销毁该对象。</p>
</li>
</ul>
<h3 id="22-分类"><a class="markdownIt-Anchor" href="#22-分类"></a> 2.2  分类</h3>
<p>JavaWeb 提供了8个监听器：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ServletContext</td>
<td>ServletContextListener</td>
<td>监听ServletContext的创建和销毁事件，可用于执行初始化和清理操作</td>
</tr>
<tr>
<td></td>
<td>ServletContextAttributeListener</td>
<td>监听ServletContext属性的添加、修改和删除事件，可用于处理全局属性的变化</td>
</tr>
<tr>
<td></td>
<td>ServletRequestListener</td>
<td>监听ServletRequest的创建和销毁事件，可用于执行请求级别的初始化和清理操作</td>
</tr>
<tr>
<td></td>
<td>ServletRequestAttributeListener</td>
<td>监听ServletRequest属性的添加、修改和删除事件，可用于处理请求级别的属性变化</td>
</tr>
<tr>
<td>Session</td>
<td>HttpSessionListener</td>
<td>监听HttpSession的创建和销毁事件，可用于执行会话级别的初始化和清理操作</td>
</tr>
<tr>
<td></td>
<td>HttpSessionAttributeListener</td>
<td>监听HttpSession属性的添加、修改和删除事件，可用于处理会话级别的属性变化</td>
</tr>
<tr>
<td></td>
<td>HttpSessionBindingListener</td>
<td>监听绑定到HttpSession的对象的状态变化，可用于处理对象状态的更新</td>
</tr>
<tr>
<td></td>
<td>HttpSessionActivationListener</td>
<td>监听HttpSession的活化和钝化事件，可用于执行会话对象的序列化和反序列化操作</td>
</tr>
<tr>
<td>Request</td>
<td>AsyncListener</td>
<td>监听异步请求的状态变化，可用于处理异步操作的完成和错误等事件</td>
</tr>
</tbody>
</table>
<p>这里面只有 <code>ServletContextListener</code> 这个监听器后期我们会接触到，<code>ServletContextListener</code> 是用来监听 <code>ServletContext</code> 对象的创建和销毁。</p>
<p><code>ServletContextListener</code> 接口中有以下两个方法</p>
<ul>
<li><code>void contextInitialized(ServletContextEvent sce)</code>：<code>ServletContext</code> 对象被创建了会自动执行的方法</li>
<li><code>void contextDestroyed(ServletContextEvent sce)</code>：<code>ServletContext</code> 对象被销毁时会自动执行的方法</li>
</ul>
<h3 id="23-代码演示"><a class="markdownIt-Anchor" href="#23-代码演示"></a> 2.3  代码演示</h3>
<p>我们只演示一下 <code>ServletContextListener</code> 监听器</p>
<ul>
<li>定义一个类，实现<code>ServletContextListener</code> 接口</li>
<li>重写所有的抽象方法</li>
<li>使用 <code>@WebListener</code> 进行配置</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//加载资源</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ContextLoaderListener...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务器，就可以在启动的日志信息中看到 <code>contextInitialized()</code> 方法输出的内容，同时也说明了 <code>ServletContext</code> 对象在服务器启动的时候被创建了。</p>
<h2 id="3-ajax"><a class="markdownIt-Anchor" href="#3-ajax"></a> 3. Ajax</h2>
<h3 id="31-概述"><a class="markdownIt-Anchor" href="#31-概述"></a> 3.1  概述</h3>
<p><strong><code>AJAX</code> (Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。</strong></p>
<p>我们先来说概念中的 <code>JavaScript</code> 和 <code>XML</code>，<code>JavaScript</code> 表明该技术和前端相关；<code>XML</code> 是指以此进行数据交换。</p>
<h4 id="311-作用"><a class="markdownIt-Anchor" href="#311-作用"></a> 3.1.1  作用</h4>
<p>AJAX 作用有以下两方面：</p>
<ol>
<li><strong>与服务器进行数据交换</strong>：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。如下图</li>
</ol>
<p>我们先来看之前做功能的流程，如下图：</p>
<p><img src="image-20210823235114367.png" alt="" /></p>
<p>如上图，<code>Servlet</code> 调用完业务逻辑层后将数据存储到域对象中，然后跳转到指定的 <code>jsp</code> 页面，在页面上使用 <code>EL表达式</code> 和 <code>JSTL</code> 标签库进行数据的展示。</p>
<p>而我们学习了AJAX 后，就可以<strong>使用AJAX和服务器进行通信，以达到使用 HTML+AJAX来替换JSP页面</strong>了。如下图，浏览器发送请求servlet，servlet 调用完业务逻辑层后将数据直接响应回给浏览器页面，页面使用 HTML 来进行数据展示。</p>
<p><img src="image-20210823235006847.png" alt="" /></p>
<ol start="2">
<li><strong>异步交互</strong>：可以在<strong>不重新加载整个页面</strong>的情况下，与服务器交换数据并<strong>更新部分网页</strong>的技术，如：搜索联想、用户名是否可用校验，等等…</li>
</ol>
<p>例如我们在百度搜索框中输入一些关键字（例如 <code>奥运</code>）后就会在下面联想出相关的内容，而联想出来的这部分数据肯定是存储在百度的服务器上，而我们并没有看出页面重新刷新，这就是 <strong>更新局部页面</strong> 的效果。还有我们在登录时输入框输入用户名，当输入框一失去焦点，如果用户名已经被占用就会在下方展示提示的信息；在这整个过程中也没有页面的刷新，只是在局部展示出了提示信息，这就是 <strong>更新局部页面</strong> 的效果。</p>
<h4 id="312-同步和异步"><a class="markdownIt-Anchor" href="#312-同步和异步"></a> 3.1.2  同步和异步</h4>
<p>知道了局部刷新后，接下来我们再聊聊同步和异步:</p>
<ul>
<li>同步发送请求过程如下</li>
</ul>
<p><img src="image-20210824001443897.png" alt="" /></p>
<p>浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。</p>
<ul>
<li>
<p>异步发送请求过程如下</p>
<p><img src="image-20210824001608916.png" alt="" /></p>
<p>浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。</p>
</li>
</ul>
<h2 id="4-axios"><a class="markdownIt-Anchor" href="#4-axios"></a> 4. axios</h2>
<p>Axios 对原生的AJAX进行封装，简化书写。</p>
<p>Axios官网是：<code>https://www.axios-http.cn</code></p>
<h3 id="41-基本使用"><a class="markdownIt-Anchor" href="#41-基本使用"></a> 4.1  基本使用</h3>
<p>axios 使用是比较简单的，分为以下两步：</p>
<ul>
<li>
<p>引入 axios 的 js 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用axios 发送请求，并获取响应结果</p>
<ul>
<li>
<p>发送 get 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>发送 post 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><code>axios()</code> 是用来发送异步请求的，小括号中使用 js 对象传递请求相关的参数：</p>
<ul>
<li><code>method</code> 属性：用来设置请求方式的。取值为 <code>get</code> 或者 <code>post</code>。</li>
<li><code>url</code> 属性：用来书写请求的资源路径。如果是 <code>get</code> 请求，需要将请求参数拼接到路径的后面，格式为： <code>url?参数名=参数值&amp;参数名2=参数值2</code>。</li>
<li><code>data</code> 属性：作为请求体被发送的数据。也就是说如果是 <code>post</code> 请求的话，数据需要作为 <code>data</code> 属性的值。</li>
</ul>
<p><code>then()</code> 需要传递一个匿名函数。我们将 <code>then()</code> 中传递的匿名函数称为 <strong>回调函数</strong>，意思是<strong>该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数</strong>。而该回调函数中的 <code>resp</code> 参数是对响应的数据进行封装的对象，通过 <code>resp.data</code> 可以获取到响应的数据。</p>
<h3 id="42-快速入门"><a class="markdownIt-Anchor" href="#42-快速入门"></a> 4.2  快速入门</h3>
<h4 id="421-后端实现"><a class="markdownIt-Anchor" href="#421-后端实现"></a> 4.2.1  后端实现</h4>
<p>定义一个用于接收请求的servlet，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/axiosServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AxiosServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 接收请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">//2. 响应数据</span></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;hello Axios~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="422-前端实现"><a class="markdownIt-Anchor" href="#422-前端实现"></a> 4.2.2  前端实现</h4>
<ul>
<li>
<p>引入 js 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>发送 ajax 请求</p>
<ul>
<li>
<p>get 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>post 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>整体页面代码如下：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. get</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">/* axios(&#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        method:&quot;get&quot;,</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        url:&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    &#125;).then(function (resp) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        alert(resp.data);</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    &#125;)*/</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. post  在js中&#123;&#125; 表示一个js对象，而这个js对象中有三个属性</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="43-请求方法别名"><a class="markdownIt-Anchor" href="#43-请求方法别名"></a> 4.3  请求方法别名</h3>
<p>为了方便起见， Axios 已经为所有支持的请求方法提供了别名。如下：</p>
<ul>
<li>
<p><code>get</code> 请求 ： <code>axios.get(url[,config])</code></p>
</li>
<li>
<p><code>delete</code> 请求 ： <code>axios.delete(url[,config])</code></p>
</li>
<li>
<p><code>head</code> 请求 ： <code>axios.head(url[,config])</code></p>
</li>
<li>
<p><code>options</code> 请求 ： <code>axios.option(url[,config])</code></p>
</li>
<li>
<p><code>post</code> 请求：<code>axios.post(url[,data[,config])</code></p>
</li>
<li>
<p><code>put</code> 请求：<code>axios.put(url[,data[,config])</code></p>
</li>
<li>
<p><code>patch</code> 请求：<code>axios.patch(url[,data[,config])</code></p>
</li>
</ul>
<p>而我们只关注 <code>get</code> 请求和 <code>post</code> 请求。</p>
<p>入门案例中的 <code>get</code> 请求代码可以改为如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>入门案例中的 <code>post</code> 请求代码可以改为如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,<span class="string">&quot;username=zhangsan&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="5-json"><a class="markdownIt-Anchor" href="#5-json"></a> 5. JSON</h2>
<h3 id="51-概述"><a class="markdownIt-Anchor" href="#51-概述"></a> 5.1  概述</h3>
<p><strong>概念：<code>JavaScript Object Notation</code>。JavaScript 对象表示法.</strong></p>
<p>如下是 <code>JavaScript</code> 对象的定义格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line">  <span class="attr">city</span>:<span class="string">&quot;北京&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们再看看 <code>JSON</code> 的格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;北京&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过上面 js 对象格式和 json 格式进行对比，发现两个格式特别像。只不过 js 对象中的属性名可以不使用引号，也可以使用引号（可以是单引号，也可以是双引号）；而 <code>json</code> 格式中的键要求必须使用双引号括起来，这是 <code>json</code> 格式的规定。<code>json</code> 格式的数据有什么作用呢？</p>
<p>作用：由于其语法格式简单，层次结构鲜明，现多用于作为<strong>数据载体</strong>，在网络中进行数据传输。如下图所示就是服务端给浏览器响应的数据，这个数据比较简单，如果现需要将 JAVA 对象中封装的数据响应回给浏览器的话，应该以何种数据传输呢？</p>
<p>大家还记得 <code>ajax</code> 的概念吗？ 是 <strong>异步的 JavaScript 和 xml</strong>。这里的 xml就是以前进行数据传递的方式，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再看 <code>json</code> 描述以上数据的写法：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;北京&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面两种格式进行对比后就会发现 <code>json</code> 格式数据的简单，以及所占的字节数少等优点。</p>
<h3 id="52-json-基础语法"><a class="markdownIt-Anchor" href="#52-json-基础语法"></a> 5.2  JSON 基础语法</h3>
<h4 id="521-定义格式"><a class="markdownIt-Anchor" href="#521-定义格式"></a> 5.2.1  定义格式</h4>
<p><code>JSON</code> 本质就是一个字符串，但是该字符串内容是有一定的格式要求的。 定义格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="string">&#x27;&#123;&quot;key&quot;:value,&quot;key&quot;:value,...&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><code>JSON</code> 串的键要求必须使用双引号括起来，而值根据要表示的类型确定。value 的数据类型分为如下</p>
<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（使用双引号括起来）</li>
<li>逻辑值（true或者false）</li>
<li>数组（在方括号中）</li>
<li>对象（在花括号中）</li>
<li>null</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:23,&quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="522-代码演示"><a class="markdownIt-Anchor" href="#522-代码演示"></a> 5.2.2  代码演示</h4>
<p>创建一个页面，在该页面的 <code>&lt;script&gt;</code> 标签中定义json字符串</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 定义JSON字符串</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:23,&quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(jsonStr);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过浏览器打开，页面效果如下图所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:23,&quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们需要获取到该 <code>JSON</code> 串中的 <code>name</code> 属性值，应该怎么处理呢？</p>
<p>如果它是一个 js 对象，我们就可以通过 <code>js对象.属性名</code> 的方式来获取数据。JS 提供了一个对象 <code>JSON</code> ，该对象有如下两个方法：</p>
<ul>
<li><code>parse(str)</code> ：将 JSON串转换为 js 对象。使用方式是： <strong><code>var jsObject = JSON.parse(jsonStr);</code></strong></li>
<li><code>stringify(obj)</code> ：将 js 对象转换为 JSON 串。使用方式是：<strong><code>var jsonStr = JSON.stringify(jsObject)</code></strong></li>
</ul>
<p>代码演示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 定义JSON字符串</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:23,&quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(jsonStr);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. 将 JSON 字符串转为 JS 对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> jsObject = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(jsObject)</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(jsObject.<span class="property">name</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//3. 将 JS 对象转换为 JSON 字符串</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> jsonStr2 = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(jsObject);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(jsonStr2)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="523-发送异步请求携带参数"><a class="markdownIt-Anchor" href="#523-发送异步请求携带参数"></a> 5.2.3  发送异步请求携带参数</h4>
<p>后面我们使用 <code>axios</code> 发送请求时，如果要携带复杂的数据时都会以 <code>JSON</code> 格式进行传递，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>请求参数不可能由我们自己拼接字符串吧？肯定不用，可以提前定义一个 js 对象，用来封装需要提交的参数，然后使用 <code>JSON.stringify(js对象)</code> 转换为 <code>JSON</code> 串，再将该 <code>JSON</code> 串作为 <code>axios</code> 的 <code>data</code> 属性值进行请求参数的提交。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsObject = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(jsObject)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>而 <code>axios</code> 是一个很强大的工具。我们只需要将需要提交的参数封装成 js 对象，并将该 js 对象作为 <code>axios</code> 的 <code>data</code> 属性值进行，它会自动将 js 对象转换为 <code>JSON</code> 串进行提交。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsObject = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:jsObject  <span class="comment">//这里 axios 会将该js对象转换为 json 串的</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>js 提供的 <code>JSON</code> 对象我们只需要了解一下即可。因为 <code>axios</code> 会自动对 js 对象和 <code>JSON</code> 串进行想换转换。</li>
<li>发送异步请求时，如果请求参数是 <code>JSON</code> 格式，那请求方式必须是 <code>POST</code>。因为 <code>JSON</code> 串需要放在请求体中。</li>
</ul>
</blockquote>
<h3 id="53-json串和java对象的相互转换"><a class="markdownIt-Anchor" href="#53-json串和java对象的相互转换"></a> 5.3  JSON串和Java对象的相互转换</h3>
<p>学习完 json 后，接下来聊聊 json 的作用。以后我们会以 json 格式的数据进行前后端交互。前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给前端浏览器。</p>
<p>在后端我们就需要重点学习以下两部分操作：</p>
<ul>
<li>请求数据：JSON字符串转为Java对象</li>
<li>响应数据：Java对象转为JSON字符串</li>
</ul>
<p>接下来给大家介绍一套 API，可以实现上面两部分操作。这套 API 就是 <code>Fastjson</code></p>
<h4 id="531-fastjson-概述"><a class="markdownIt-Anchor" href="#531-fastjson-概述"></a> 5.3.1  Fastjson 概述</h4>
<p><code>Fastjson</code> 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 <code>JSON</code> 库，是目前Java语言中最快的 <code>JSON</code> 库，可以实现 <code>Java</code> 对象和 <code>JSON</code> 字符串的相互转换。</p>
<h4 id="532-fastjson-使用"><a class="markdownIt-Anchor" href="#532-fastjson-使用"></a> 5.3.2  Fastjson 使用</h4>
<p><code>Fastjson</code> 使用也是比较简单的，分为以下三步完成</p>
<ol>
<li>
<p><strong>导入坐标</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Java对象转JSON</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(obj);</span><br></pre></td></tr></table></figure>
<p>将 Java 对象转换为 JSON 串，只需要使用 <code>Fastjson</code> 提供的 <code>JSON</code> 类中的 <code>toJSONString()</code> 静态方法即可。</p>
</li>
<li>
<p><strong>JSON字符串转Java对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(jsonStr, User.class);</span><br></pre></td></tr></table></figure>
<p>将 json 转换为 Java 对象，只需要使用 <code>Fastjson</code> 提供的 <code>JSON</code> 类中的 <code>parseObject()</code> 静态方法即可。</p>
</li>
</ol>
<h4 id="533-代码演示"><a class="markdownIt-Anchor" href="#533-代码演示"></a> 5.3.3  代码演示</h4>
<ul>
<li>
<p>引入坐标</p>
</li>
<li>
<p>创建一个类，专门用来测试 Java 对象和 JSON 串的相互转换，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 将Java对象转为JSON字符串</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">        System.out.println(jsonString);<span class="comment">//&#123;&quot;id&quot;:1,&quot;password&quot;:&quot;123&quot;,&quot;username&quot;:&quot;zhangsan&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 将JSON字符串转为Java对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> JSON.parseObject(<span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;password\&quot;:\&quot;123\&quot;,\&quot;username\&quot;:\&quot;zhangsan\&quot;&#125;&quot;</span>, User.class);</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC相关知识</title>
    <url>/2023/11/22/JDBC%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>本文全部内容均来自<code>黑马程序员</code>的资料，本文仅对其总结，很多复杂难懂内容跳过。</p>
<h1 id="1-jdbc介绍"><a class="markdownIt-Anchor" href="#1-jdbc介绍"></a> 1. JDBC介绍</h1>
<h2 id="11-jdbc概念"><a class="markdownIt-Anchor" href="#11-jdbc概念"></a> 1.1 JDBC概念</h2>
<blockquote>
<p>全称（ Java database connectivity）Java数据库连接</p>
<p>JDBC 是使用Java语言操作关系型数据库的一套API</p>
</blockquote>
<img src="/img/JDBC概念.png" style="zoom:70%" />
<p>同一套Java代码无法操作不同的关系型数据库，因为每一个关系型数据库的底层实现不同，sun公司制定了一套操作数据库的标准接口（JDBC），JDBC中定义了所有操作关系型数据库的规则，接口无法使用，需要使用接口的实现类，这套实现类（称之为：驱动），由各自的数据库厂商给出。</p>
<h2 id="12-jdbc本质"><a class="markdownIt-Anchor" href="#12-jdbc本质"></a> 1.2 JDBC本质</h2>
<blockquote>
<p>官方定义的一套操作所有关系型数据库的规则，即接口。</p>
<p>各个数据库厂商去实现这套接口，提供数据库驱动jar包</p>
<p>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中德实现类</p>
</blockquote>
<h2 id="13-jdbc好处"><a class="markdownIt-Anchor" href="#13-jdbc好处"></a> 1.3 JDBC好处</h2>
<blockquote>
<p>各个数据库厂商实现同一个相同的接口，客户实际使用时调用这套接口（JDBC）操作不同的数据库。</p>
<p>可随时替换底层数据库，且访问数据库的Java代码不变。</p>
</blockquote>
<p>客户编写操作数据库的代码只需要面向这套接口（JDBC），操作哪个关系型数据库就导入对应的数据库的驱动包，如操作MySQL数据库就需要在项目中导入MySQL数据库的驱动包。</p>
<h1 id="2-jdbc快速入门"><a class="markdownIt-Anchor" href="#2-jdbc快速入门"></a> 2. JDBC快速入门</h1>
<p>Java操作数据库的流程是：</p>
<blockquote>
<p>第一步：编写Java代码</p>
<p>第二部：Java代码将sql发送到MySQL服务端</p>
<p>第三步： MySQL服务端接受sql语句并执行</p>
<p>第四步：MySQL服务端将sql语句执行结果返回给Java代码</p>
</blockquote>
<h2 id="21-编写代码步骤"><a class="markdownIt-Anchor" href="#21-编写代码步骤"></a> 2.1 编写代码步骤</h2>
<ol>
<li>
<p>创建工程，导入驱动jar包</p>
</li>
<li>
<p>注册驱动(以MySQL为例)，目的是将数据库驱动程序加载到<code>JVM</code>中,旧版本JDBC需要手动注册驱动，新版本驱动会自动注册，以下为手动注册代码，现在在编程是可以不用写以下代码，因为会自动注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forname(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取连接，Java代码需要发送sql给MySQL服务端，就需要先建立连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManage.getConnection(url, username, password);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义sql语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update...&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取执行sql的对象，执行sql语句需要sql执行对象，就是Statement对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> coon.createStatement();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>执行SQL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>处理返回结果</p>
</li>
<li>
<p>释放资源</p>
</li>
</ol>
<h2 id="22-完整代码"><a class="markdownIt-Anchor" href="#22-完整代码"></a> 2.2 完整代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC快速入门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 1.注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		<span class="comment">// 2.获取连接</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">		<span class="comment">// 3.定义SQL</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = 2000 where id = 1&quot;</span>;</span><br><span class="line">		<span class="comment">// 4.获取执行SQL对象 Statement</span></span><br><span class="line">		<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">		<span class="comment">// 5.执行SQL</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">		<span class="comment">// 6.处理结果</span></span><br><span class="line">		...</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		<span class="comment">// 7.释放资源</span></span><br><span class="line">		stmt.close();</span><br><span class="line">		coon.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-jdbc-api详解"><a class="markdownIt-Anchor" href="#3-jdbc-api详解"></a> 3. JDBC API详解</h1>
<h2 id="31-drviermanage"><a class="markdownIt-Anchor" href="#31-drviermanage"></a> 3.1 DrvierManage</h2>
<ul>
<li>获取数据库连接</li>
</ul>
<table>
<thead>
<tr>
<th>static Connection</th>
<th>getConnection(String url, String username, String password)</th>
<th>尝试与给定数据库URL连接</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>参数说明：</p>
<blockquote>
<ul>
<li>url：连接路径</li>
</ul>
<p>语法：jdbc:mysql://ip地址(域名):端口号/数据库名称?参数键值对1&amp;参数键值对2。</p>
<p>示例：jdbc:mysql://127.0.0.1:3306/db1</p>
<p>细节：</p>
<ul>
<li>如果连接的是本机MySQL服务器，并且MySQL服务器默认端口是3306，则url可简写为：jdbc:mysql:///数据库名称?参数键值对</li>
<li>配置useSSL=false参数，禁用安全连接方式，解决警告提示</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>user：用户名</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>password: 密码</li>
</ul>
</blockquote>
<h2 id="32-connection"><a class="markdownIt-Anchor" href="#32-connection"></a> 3.2 Connection</h2>
<p>Connection（数据库连接对象）作用：</p>
<ul>
<li>获取执行SQL对象</li>
<li>管理事务</li>
</ul>
<h3 id="321-获取sql执行对象"><a class="markdownIt-Anchor" href="#321-获取sql执行对象"></a> 3.2.1 获取SQL执行对象</h3>
<ul>
<li>普通执行SQL对象</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement <span class="title function_">createStatement</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>预编译SQL的执行SQL对象，可防止SQL注入</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement <span class="title function_">prepareStatement</span><span class="params">(sql)</span></span><br></pre></td></tr></table></figure>
<h3 id="322-事务管理"><a class="markdownIt-Anchor" href="#322-事务管理"></a> 3.2.2 事务管理</h3>
<p>MySQL事务管理的操作：</p>
<blockquote>
<p>开启事务：BEGIN; 或者START TRANSACTION;</p>
<p>提交事务：COMMIT;</p>
<p>回滚事务：ROLLBACK；</p>
</blockquote>
<p>Connection接口中定义了三个对应的方法：</p>
<ul>
<li>
<p>开启事务</p>
<table>
<thead>
<tr>
<th>void</th>
<th>setAutoCommit(boolean autoCommit)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>参数autoCommit表示是否自动提交事务，true表示自动提交，false表示手动提交。而开启事务需要将该参数设为false。</p>
</li>
<li>
<p>提交事务</p>
<table>
<thead>
<tr>
<th>void</th>
<th>commit()</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
<li>
<p>回滚事务</p>
<table>
<thead>
<tr>
<th>void</th>
<th>rollback()</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
</ul>
<p>具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC API详解： Connection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 1.注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		<span class="comment">// 2.获取连接，如果连接的是本机MySQL且端口是3306可以简化书写</span></span><br><span class="line">		<span class="comment">// String url = &quot;jdbc:mysql://127.0.0.1:3306/db1&quot;;</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">		<span class="comment">// 3.定义SQL</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update account set money = 3000 where id = 1&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update account set money = 3000 where id = 2&quot;</span>;</span><br><span class="line">		<span class="comment">// 4.获取执行SQL对象 Statement</span></span><br><span class="line">		<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// ======开启事务======</span></span><br><span class="line">			conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">			<span class="comment">// 5.执行SQL</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> stmt.executeUpdate(sql1);<span class="comment">//受影响的行数</span></span><br><span class="line">			<span class="comment">// 6.处理结果</span></span><br><span class="line">			System.out.println(count1);</span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 5.执行SQL</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> stmt.executeUpdate(sql2);<span class="comment">//受影响的行数</span></span><br><span class="line">			<span class="comment">// 6.处理结果</span></span><br><span class="line">			System.out.println(count2);</span><br><span class="line">			<span class="comment">// ======提交事务======</span></span><br><span class="line">			<span class="comment">//程序运行到此处，说明没有出现任何问题，则需要提交事务</span></span><br><span class="line">			coon.commit();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			<span class="comment">// ======回滚事务======</span></span><br><span class="line">			<span class="comment">//程序在出现异常时会执行到这个地方，此时就需要回滚事务</span></span><br><span class="line">			conn.rollback();</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 7.释放资源</span></span><br><span class="line">		stmt.close();</span><br><span class="line">		coon.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="33-statement"><a class="markdownIt-Anchor" href="#33-statement"></a> 3.3 Statement</h2>
<p>Statement对象的作用是用来执行SQL语句，针对不同的SQL语句使用的方法也不同。</p>
<ul>
<li>
<p>执行DDL、DML语句</p>
<blockquote>
<p>开发中很少使用Java代码操作DDL语句</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>int</th>
<th>executeUpdate(String sql)</th>
<th>执行给定的SQL语句，可能是INSERT,UPDATE或DELETE语句</th>
</tr>
</thead>
<tbody></tbody>
</table>
<ul>
<li>
<p>执行DQL语句</p>
<table>
<thead>
<tr>
<th>ResultSet</th>
<th>executeQuery(String sql)</th>
<th>执行给定的SQL语句，返回单个ResultSet对象</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
</ul>
<h2 id="34-resultset"><a class="markdownIt-Anchor" href="#34-resultset"></a> 3.4 ResultSet</h2>
<h3 id="341-介绍"><a class="markdownIt-Anchor" href="#341-介绍"></a> 3.4.1 介绍</h3>
<p>ResultSet（结果集对象）封装了SQL查询语句的结果。对应执行DQL语句的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResultSet <span class="title function_">executeQuery</span><span class="params">(sql)</span>: 执行DQL语句，返回ResultSet对象</span><br></pre></td></tr></table></figure>
<p><code>ResultSet</code>对象提供了操作查询结果的方法，如下：</p>
<blockquote>
<p>boolean next()</p>
<ul>
<li>将光标从当前位置向后移动一行</li>
<li>判断当前行是否为有效行</li>
</ul>
<p>方法返回值说明：</p>
<ul>
<li>true：有效行，当前行有数据</li>
<li>false：无效行，当前行没有数据</li>
</ul>
</blockquote>
<blockquote>
<p>xxx getXxx(参数)：获取数据</p>
<ul>
<li>xxx：数据类型；如：int getInt(参数)；String getString(参数)；</li>
<li>参数
<ul>
<li>int类型的参数：列的名称（行号也可以）</li>
<li>String类型的参数：列的名称（行号也可以）</li>
</ul>
</li>
</ul>
</blockquote>
<p>如下为执行SQL语句后的结果：</p>
<img src="/img/SQL查询结果.png" style="zoom:80%"/>
<p>如图，一开始光标指在第一行前，如图所示红色箭头指向于表头行。当我们调用了<code>next()</code>方法后，光标就下移到第一行，并且方法返回<code>true</code>，此时可通过<code>getInt(&quot;id&quot;)</code>获取当前行id字段的值，也可通过<code>getString(&quot;name&quot;)</code>获取当前行的name字段的值。如果想获取下一行的数据，继续调用<code>next()</code>方法。</p>
<h3 id="342-代码实现"><a class="markdownIt-Anchor" href="#342-代码实现"></a> 3.4.2 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 执行DQL</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResultSet</span><span class="params">()</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    <span class="comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line">    <span class="comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">    <span class="comment">//3. 定义sql</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from account&quot;</span>;</span><br><span class="line">    <span class="comment">//4. 获取statement对象</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="comment">//5. 执行sql</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line">    <span class="comment">//6. 处理结果， 遍历rs中的所有数据</span></span><br><span class="line">    <span class="comment">/* // 6.1 光标向下移动一行，并且判断当前行是否有数据</span></span><br><span class="line"><span class="comment">        while (rs.next())&#123;</span></span><br><span class="line"><span class="comment">            //6.2 获取数据  getXxx()</span></span><br><span class="line"><span class="comment">            int id = rs.getInt(1);</span></span><br><span class="line"><span class="comment">            String name = rs.getString(2);</span></span><br><span class="line"><span class="comment">            double money = rs.getDouble(3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            System.out.println(id);</span></span><br><span class="line"><span class="comment">            System.out.println(name);</span></span><br><span class="line"><span class="comment">            System.out.println(money);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            System.out.println(&quot;--------------&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="comment">// 6.1 光标向下移动一行，并且判断当前行是否有数据</span></span><br><span class="line">    <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">        <span class="comment">//6.2 获取数据  getXxx()</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(id);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(money);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    rs.close();</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="35-preparedstatement"><a class="markdownIt-Anchor" href="#35-preparedstatement"></a> 3.5 PreparedStatement</h2>
<blockquote>
<ul>
<li>
<p>PreparedStatement作用：</p>
<p>预编译SQL语句并执行，预防SQL注入问题</p>
</li>
</ul>
</blockquote>
<h3 id="351-sql注入"><a class="markdownIt-Anchor" href="#351-sql注入"></a> 3.5.1 SQL注入</h3>
<p><code>SQL注入</code>是通过操作输入来修改事先定义好的SQL语句，达到执行代码来攻击服务器的手段，具体详情感觉与Java学习关系不大，我也不太懂，就不详细介绍了。</p>
<h3 id="352-preparedstatement概述"><a class="markdownIt-Anchor" href="#352-preparedstatement概述"></a> 3.5.2 PreparedStatement概述</h3>
<ul>
<li>
<p>获取PreparedStatement对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//SQL语句中的参数值，使用 ? 占位符替代</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过Connection对象获取，并传入对应的SQL语句，这里比以前的createStatement()方法参数传递提前了</span></span><br><span class="line">  <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> coon.preparedStatement(sql);</span><br><span class="line"></span><br><span class="line">- 设置参数值</span><br><span class="line"></span><br><span class="line">  上面的SQL语句中参数使用  `?` 进行占位，在此之前要设置这些 `?` 的值</span><br><span class="line"></span><br><span class="line">  &gt; 方法：setXxx(参数<span class="number">1</span>， 参数<span class="number">2</span>)</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; - Xxx：表示数据类型，例如setInt(参数<span class="number">1</span>， 参数<span class="number">2</span>)</span><br><span class="line">  &gt; - 参数<span class="number">1</span>：占位符 `?` 的位置编号，代表在SQL语句中第几个占位符，从<span class="number">1</span>开始</span><br><span class="line">  &gt; - 参数<span class="number">2</span>：占位符`?`的值</span><br><span class="line"></span><br><span class="line">- 执行SQL语句</span><br><span class="line"></span><br><span class="line">  &gt; executeUpdate(); <span class="comment">//执行DDL语句和DML语句</span></span><br><span class="line">  &gt;</span><br><span class="line">  &gt; executeQuery(); <span class="comment">//执行DQL语句</span></span><br><span class="line">  &gt;</span><br><span class="line">  &gt; - 注意：调用这两个方法时不需要传递SQL语句，在获取SQL语句执行对象PreparedStatement时已经对SQL语句进行预编译了。</span><br><span class="line"></span><br><span class="line">- 开启预编译功能</span><br><span class="line"></span><br><span class="line">  &gt; 在代码中编写url时需要加上以下参数：</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; useServerPrepStmts=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">### <span class="number">3.5</span><span class="number">.3</span> PreparedStatement的使用</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC API详解： PreparedStatement</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 1.注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		<span class="comment">// 2.获取连接，如果连接的是本机MySQL且端口是3306可以简化书写</span></span><br><span class="line">		<span class="comment">// String url = &quot;jdbc:mysql://127.0.0.1:3306/db1&quot;;</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">		<span class="comment">//占位符 ？ 的值</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//定义SQL</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = ? and password = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取PreparedStatement对象</span></span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置占位符 ？ 的值</span></span><br><span class="line">		pstmt.setString(<span class="number">1</span>, name);</span><br><span class="line">		pstmt.setString(<span class="number">2</span>, pwd);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//执行SQL</span></span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断是否登录成功</span></span><br><span class="line">		<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 7.释放资源</span></span><br><span class="line">		rs.close();</span><br><span class="line">		pstmt.close();</span><br><span class="line">		coon.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后，PreparedStatement原理较为复杂，读者也不太懂。</p>
<h1 id="4-数据库连接池"><a class="markdownIt-Anchor" href="#4-数据库连接池"></a> 4. 数据库连接池</h1>
<h2 id="41-数据库连接池介绍"><a class="markdownIt-Anchor" href="#41-数据库连接池介绍"></a> 4.1 数据库连接池介绍</h2>
<ul>
<li>数据库连接池是一个容器，负责分配、管理数据库连接（Connection）</li>
<li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立新连接</li>
</ul>
<p>之前代码中使用连接时每一个使用都创建一个Connection对象，使用完后将其销毁。这样<strong>重复创建销毁的过程时特别耗费计算机的性能和时间。</strong></p>
<p>但在使用数据库连接池后，可以实现对Connection对象的复用。</p>
<blockquote>
<p>连接池是在一开始就创建好了一些连接对象(Connection)存储起来，用户需要连接数据库时，不需要自己创建连接，只需从连接池中获取一个连接进行使用，使用完毕后在将连接对象(Connection)归还给连接池，这样可以起到资源复用的作用，也节省了频繁创建连接、销毁连接所花费的时间，从而提升了响应速度。</p>
</blockquote>
<h2 id="42-数据库连接池实现"><a class="markdownIt-Anchor" href="#42-数据库连接池实现"></a> 4.2 数据库连接池实现</h2>
<ul>
<li>
<p>标准接口：DataSource</p>
<p>官方提供的数据库连接池标准接口，由第三方实现此接口，该接口提供过了获取连接的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection <span class="title function_">getConnection</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>使用数据库连接池就不需要通过<code>DriverManager</code>对象获取<code>Connection</code>对象，而是通过连接池<code>DataSource</code>获取<code>Connection</code>对象。</p>
</li>
<li>
<p>常用数据库连接池： Druid(德鲁伊)</p>
<ul>
<li>Druid连接池是阿里巴巴开源的数据库连接池项目</li>
</ul>
</li>
</ul>
<h2 id="43-druid使用"><a class="markdownIt-Anchor" href="#43-druid使用"></a> 4.3 Druid使用</h2>
<blockquote>
<ul>
<li>导入jar包 例如druid-1.1.12.jar //将druid的jar包放在项目下的lib下并添加为库文件</li>
<li>定义配置文件</li>
<li>加载配置文件</li>
<li>获取数据库连接池对象</li>
<li>获取连接</li>
</ul>
</blockquote>
<p><strong>编写名为druid.properties的配置文件，放在src下的目录中</strong></p>
<p><strong>druid.properties的配置文件内容如下:</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver # MySQL JDBC驱动程序的类名，用于连接到MySQL数据库</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true # 连接到名为db1的MySQL数据库的URL，不使用SSL加密连接，并开启预处理语句功能</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root # 连接到MySQL数据库所使用的用户名</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">1234 # 连接到MySQL数据库所使用的密码</span></span><br><span class="line"><span class="comment"># 初始化连接数量，设置为5表示在连接池启动时创建5个连接</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 最大连接数，设置为10表示连接池中最多同时存在10个连接</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10 </span></span><br><span class="line"><span class="comment"># 最大等待时间，设置为3000表示当所有连接都被占用时，新的请求最多等待3秒钟</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>
<p>使用druid的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Druid数据库连接池演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.导入jar包</span></span><br><span class="line">		<span class="comment">//2.定义配置文件</span></span><br><span class="line">		<span class="comment">//3.加载配置文件</span></span><br><span class="line">		<span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<span class="comment">//即druid配置文件在项目中的位置</span></span><br><span class="line">		<span class="comment">//4.获取连接池对象</span></span><br><span class="line">		<span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">		<span class="comment">//5.获取数据库连接Connection</span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">		...获取到连接后继续进行其它操作</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次写这么长的文章，虽然都是抄的黑马，仍希望这是自己好的开始。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的next主题的博客文章目录显示问题</title>
    <url>/2023/11/23/Hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>写完文章后目录中的编号在Typora中没问题，但在网页查看后出现了数字编号重复出现的问题，错误如下图：</p>
<img src="/img/文章目录显示错误.png" />
<p>感觉这个错误很扯淡，在<code>csdn</code>上找到了解决办法：</p>
<blockquote>
<p>打开<code>next</code>主题下的<code>_config.yml</code>配置文件，将<code>toc</code>部分中的<code>number</code>的值改为<code>false</code>，原值为true，会自动为目录添加数字序号。</p>
</blockquote>
<p><a href="%5B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E3%80%90Hexo%E3%80%91%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7%E9%97%AE%E9%A2%98_hexo%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/Passerby_Wang/article/details/121342829)">CSDN参考链接</a></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA中Mapper.xml不自动显示数据库表和字段提示</title>
    <url>/2023/11/27/IDEA%E4%B8%ADMapper-xml%E4%B8%8D%E8%87%AA%E5%8A%A8%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%92%8C%E5%AD%97%E6%AE%B5%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<p><strong>打开File的settings，在搜索框中找到SQL Dialects，把SQL Dialects选项的右边那个SQL Dialect改为你的默认数据库，我这边之前默认的是<code>&lt;None&gt;</code>，然后我把它改回了我使用的mysql，之后就会有提示了。</strong></p>
<p><big><strong>修改前：</strong></big></p>
<table>
<thead>
<tr>
<th>Global SQL Dialect：</th>
<th><None></th>
</tr>
</thead>
<tbody>
<tr>
<td>ProjectSQL Dialect：</td>
<td><None></td>
</tr>
</tbody>
</table>
<p><big><strong>修改后，改为自己的数据库类型：</strong></big></p>
<table>
<thead>
<tr>
<th>Global SQL Dialect：</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>ProjectSQL Dialect：</td>
<td>MySQL</td>
</tr>
</tbody>
</table>
<p>然后点击Apply，再点击OK。</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的http简单介绍</title>
    <url>/2023/11/24/Java%E4%B8%AD%E7%9A%84http%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="1-javaweb概述"><a class="markdownIt-Anchor" href="#1-javaweb概述"></a> 1. JavaWeb概述</h1>
<h2 id="11-javaweb概念"><a class="markdownIt-Anchor" href="#11-javaweb概念"></a> 1.1 JavaWeb概念</h2>
<p>JavaWeb是使用Java语言开发Web应用程序的技术，用Java语言解决相关web互联网领域的技术栈。</p>
<h2 id="12-javaweb技术栈"><a class="markdownIt-Anchor" href="#12-javaweb技术栈"></a> 1.2 JavaWeb技术栈</h2>
<blockquote>
<ul>
<li>B/S架构</li>
<li>html、css和JavaScript等静态资源</li>
<li>Servlet和JSP等动态资源</li>
<li>数据库</li>
<li>HTTP协议</li>
<li>web服务器</li>
</ul>
</blockquote>
<h3 id="121-bs架构"><a class="markdownIt-Anchor" href="#121-bs架构"></a> 1.2.1 B/S架构</h3>
<p>B/S架构：Browser/Server，即浏览器/服务器架构模式，特点是客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取web资源，服务器把web资源发送给浏览器。我是开窍真的晚，我差不多是到大四写毕业设计的时候才搞明白B/S架构，感觉这个跟前后端分离差不多。</p>
<img src="/img/BS架构.png" style="zoom:80%"/>
<ul>
<li>B/S架构优点：易于维护升级，服务器端升级后，客户端无需任何操作就可以使用到最新的版本。</li>
</ul>
<h3 id="122-静态资源"><a class="markdownIt-Anchor" href="#122-静态资源"></a> 1.2.2 静态资源</h3>
<p>静态资源主要包含HTML、CSS、JavaScript和图片等，主要是页面的展示。</p>
<h3 id="123-动态资源"><a class="markdownIt-Anchor" href="#123-动态资源"></a> 1.2.3 动态资源</h3>
<p>动态资源主要包括Servlet、JSP等，主要用于逻辑处理，这两个我都旺季具体内容了，后面边学编写。动态资源处理完逻辑后会将得到的结果交给静态资源进行展示，静态资源和动态资源结合在一起使用。</p>
<h3 id="124-数据库"><a class="markdownIt-Anchor" href="#124-数据库"></a> 1.2.4 数据库</h3>
<p>数据库负责存储数据，整个Web的访问过程如下图所示：</p>
<img src="/img/BS访问数据库.png" />
<blockquote>
<p>(1)浏览器发送请求到服务器端，去请求所需要的相关资源;<br />
(2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容;<br />
(3)在Java代码可以进行业务处理也可以从数据库中读取数据;<br />
(4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好;<br />
(5)服务端将静态资源响应给浏览器;<br />
(6)浏览器将这些资源进行解析;<br />
(7)解析后将效果展示在浏览器，用户就可以看到最终的结果。</p>
</blockquote>
<h3 id="125-http协议"><a class="markdownIt-Anchor" href="#125-http协议"></a> 1.2.5 HTTP协议</h3>
<p>HTTP协议定义了网络通信的规则，浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则。</p>
<h3 id="126-web服务器"><a class="markdownIt-Anchor" href="#126-web服务器"></a> 1.2.6 Web服务器</h3>
<ul>
<li>作用：用于接收、处理并响应来自客户端（通常是浏览器）的HTTP请求</li>
<li>浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器</li>
</ul>
<h1 id="2-http"><a class="markdownIt-Anchor" href="#2-http"></a> 2. HTTP</h1>
<h2 id="21-http简介"><a class="markdownIt-Anchor" href="#21-http简介"></a> 2.1 HTTP简介</h2>
<ul>
<li>
<p>HTTP概念</p>
<p>HTTP（HyperText Transfer Protocol，超文本传输协议），规定了浏览器和服务器之间的数据传输的规则。数据传输规则指的是请求数据和响应数据要按照指定的格式进行传输。</p>
</li>
<li>
<p>HTTP特点</p>
<blockquote>
<ul>
<li>
<p>基于TCP协议：面向连接，安全</p>
<p>TCP是一种面向连接的（建立连接之前要经过三次握手）、可靠的、基于字节流的传输层通信协议。</p>
</li>
<li>
<p>基于请求-响应模型：一次请求对应依次响应，请求和响应时一 一对应的。</p>
</li>
<li>
<p>HTTP协议是无状态协议：对于事物处理没有记忆能力。每次请求-响应都是独立的</p>
<p><big><strong>无状态指的是说服务器在响应客户端请求后并不会记录客户端的请求信息。每个HTTP请求都是独立的，服务器无法知道当前请求的上下文信息或者之前的操作历史。</strong></big></p>
<p>这种无状态协议导致的<strong>缺点是无法共享数据</strong>：</p>
<ul>
<li>
<p>在京东购物的场景中，用户在浏览商品时可以将感兴趣的商品加入购物车，然后在结算时将购物车中的商品进行支付。这涉及到两个不同的操作：加入购物车和去购物车结算。</p>
<p>假设京东采用了纯粹的HTTP协议，并且没有使用任何状态管理技术（比如Cookie或Session）。当用户点击“加入购物车”按钮时，浏览器会向服务器发送一个加入购物车的请求，服务器会处理这个请求并返回响应，告诉浏览器“已成功将商品加入购物车”。</p>
<p>这时，如果用户立刻点击“去购物车结算”，浏览器会向服务器发送另一个请求，以请求展示购物车中的商品和进行结算。但由于HTTP协议本身<big><strong>是无状态</strong></big>的，服务器并不知道之前那个加入购物车的请求是针对哪些商品的，也就无法正确展示购物车中的商品信息。</p>
<p>因此，如果没有状态管理技术的支持，服务器无法跟踪用户的操作历史，无法知道用户之前加入了哪些商品到购物车。这就导致了无法正确展示购物车信息的问题，因为每个请求都是相互独立的，服务器无法从请求中获取之前的操作信息。</p>
</li>
<li>
<p>通过引入状态管理技术，比如使用Cookie或Session，服务器可以在客户端与服务器之间保持一些状态信息，比如记录用户加入购物车的商品信息，从而确保在用户进行结算时能够正确展示购物车中的商品信息。这样就能够解决因HTTP协议无状态特性而引发的数据共享问题，后面会介绍。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="22-http请求数据格式"><a class="markdownIt-Anchor" href="#22-http请求数据格式"></a> 2.2 HTTP请求数据格式</h2>
<p>请求数据分为三部分，分别是<strong>请求行</strong>、<strong>请求头</strong>、<strong>请求体</strong>，如下所示：</p>
<blockquote>
<p><strong>POST /api/login HTTP/1.1</strong><br />
<strong>Host</strong>: <a href="http://example.com">example.com</a><br />
<strong>Connection</strong>: keep-alive<br />
<strong>Cache-Control</strong>: max-age=0<br />
<strong>User-Agent</strong>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36<br />
<strong>Content-Type</strong>: application/x-www-form-urlencoded</p>
<p><strong>username=john&amp;password=123456</strong></p>
</blockquote>
<ul>
<li>
<p>请求行: HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] /[请求URL路径] HTTP/1.1[HTTP协议及版本]，请求方式有7种，常用的时GET和POST</p>
</li>
<li>
<p>请求头: 第二行开始，格式为<strong>key: value</strong>形式，请求头中会包含若干个属性，常见的HTTP请求头有:</p>
<blockquote>
<p><strong>Host</strong>: 表示请求的主机名<br />
<strong>User-Agent</strong>: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0…Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT …)like Gecko；<br />
<strong>Accept</strong>：表示浏览器能接收的资源类型，如text/*，image/<em>或者</em>/*表示所有；<br />
<strong>Accept-Language</strong>：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；<br />
<strong>Accept-Encoding</strong>：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</p>
</blockquote>
</li>
<li>
<p>请求体：POST请求最后一部分，存储请求参数</p>
<blockquote>
<p>请求体和请求头之间是有一个空行隔开。此时浏览器发送的是POST请求，为什么不能使用GET呢？这时就需要回顾GET和POST两个请求之间的区别了:</p>
<ul>
<li><strong>GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中</strong></li>
<li><strong>GET请求请求参数大小有限制，POST没有</strong></li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="23-http响应数据格式"><a class="markdownIt-Anchor" href="#23-http响应数据格式"></a> 2.3 HTTP响应数据格式</h2>
<h3 id="231-格式介绍"><a class="markdownIt-Anchor" href="#231-格式介绍"></a> 2.3.1 格式介绍</h3>
<p>响应数据跟请求数据类似，分为三个部分，分别是响应行、响应头和响应体。具体格式如下所示：</p>
<blockquote>
<p><strong>HTTP/1.1 200 OK</strong><br />
<strong>Server</strong>: Apache/2.4.29 (Ubuntu)<br />
<strong>Content-Type</strong>: text/html<br />
<strong>Transfer-Encoding</strong>: chunked</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Page&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;This is an example HTML page.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>
<p>响应行：响应数据的第一行,响应行包含三块内容，分别是 HTTP/1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述]</p>
</li>
<li>
<p>响应头：第二行开始，格式为key：value形式响应头中会包含若干个属性，常见的HTTP响应头有:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；</span><br><span class="line">Content-Length：表示该响应内容的长度（字节数）；</span><br><span class="line">Content-Encoding：表示该响应压缩算法，例如gzip；</span><br><span class="line">Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>响应体： 最后一部分,存放响应数据。上图中<html>…</html>这部分内容就是响应体，它和响应头之间有一个空行隔开。</p>
</li>
</ul>
<h3 id="232-响应状态码"><a class="markdownIt-Anchor" href="#232-响应状态码"></a> 2.3.2 响应状态码</h3>
<p>三个主要响应状态码：</p>
<ul>
<li>200 ok 客户端请求成功</li>
<li>404 Not Found 请求资源不存在</li>
<li>500 Internal Server Error 服务端发生不可预期的错误</li>
</ul>
<h1 id="3-tomcat"><a class="markdownIt-Anchor" href="#3-tomcat"></a> 3. Tomcat</h1>
<p><strong>Tomcat的LOGO</strong></p>
<img src="/img/tomcat logo.png" />
<p>这里仅对Tomcat进行简单的介绍，具体用法网上有很详细的步骤。Tomcat是Web服务器，以下先介绍Web服务器。</p>
<p>Web服务器是一种应用程序或软件，能够接收来自客户端的HTTP请求，并向客户端发送HTTP响应，以提供网上信息浏览服务。Web开发人员可以将自己编写的Web项目（如网站、Web应用等）部署到Web服务器上，通过Web服务器来处理用户的访问请求和返回响应结果。<strong>Tomcat</strong>是一个免费开源的Web服务器软件，支持Java Servlet和JSP技术，并可以作为Java Web应用程序的运行环境。</p>
<p><strong>Tomcat相关概念：</strong></p>
<blockquote>
<ul>
<li>Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP等少量JavaEE规范。</li>
<li>JavaEE规范: Java Enterprise Edition,Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF。</li>
<li>因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。</li>
<li>Tomcat的官网: <a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> 从官网上可以下载对应的版本进行使用。</li>
</ul>
</blockquote>
<p>Web服务器软件使用步骤：</p>
<ul>
<li>准备静态资源</li>
<li>下载安装Web服务器软件</li>
<li>将静态资源部署到Web服务器上</li>
<li>启动Web服务器</li>
<li>使用浏览器访问对应的资源</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC/DI：第三方bean的配置管理、注解开发和整合开发</title>
    <url>/2023/12/11/IOC-DI%EF%BC%9A%E7%AC%AC%E4%B8%89%E6%96%B9bean%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E3%80%81%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%92%8C%E6%95%B4%E5%90%88%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="1-iocdi配置管理第三方bean"><a class="markdownIt-Anchor" href="#1-iocdi配置管理第三方bean"></a> 1. IOC/DI配置管理第三方bean</h2>
<h3 id="11-案例数据源对象管理"><a class="markdownIt-Anchor" href="#11-案例数据源对象管理"></a> 1.1 案例:数据源对象管理</h3>
<p>本次将使用数据源<code>Druid(德鲁伊)</code>和<code>C3P0(是一个数据库连接池)</code>来配置学习。</p>
<h4 id="111-环境准备"><a class="markdownIt-Anchor" href="#111-环境准备"></a> 1.1.1 环境准备</h4>
<p>学习之前，先来准备下案例环境:</p>
<ul>
<li>
<p>pom.xml添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>resources下添加spring的配置文件applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编写一个运行类App</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="112-思路分析"><a class="markdownIt-Anchor" href="#112-思路分析"></a> 1.1.2 思路分析</h4>
<p>在上述环境下，来对数据源进行配置管理，先来分析下思路:</p>
<blockquote>
<p>需求:使用Spring的IOC容器来管理Druid连接池对象</p>
<p>1.使用第三方的技术，需要在pom.xml添加依赖</p>
<p>2.在配置文件中将【第三方的类】制作成一个bean，让IOC容器进行管理</p>
<p>3.数据库连接需要基础的四要素<code>驱动</code>、<code>连接</code>、<code>用户名</code>和<code>密码</code>，【如何注入】到对应的bean中</p>
<p>4.从IOC容器中获取对应的bean对象，将其打印到控制台查看结果</p>
</blockquote>
<h4 id="113-实现druid管理"><a class="markdownIt-Anchor" href="#113-实现druid管理"></a> 1.1.3 实现Druid管理</h4>
<h5 id="步骤1导入druid的依赖"><a class="markdownIt-Anchor" href="#步骤1导入druid的依赖"></a> 步骤1:导入<code>druid</code>的依赖</h5>
<p>pom.xml中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="步骤2配置第三方bean"><a class="markdownIt-Anchor" href="#步骤2配置第三方bean"></a> 步骤2:配置第三方bean</h5>
<p>在applicationContext.xml配置文件中添加<code>DruidDataSource</code>的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--管理DruidDataSource对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>driverClassName:数据库驱动</li>
<li>url:数据库连接地址</li>
<li>username:数据库连接用户名</li>
<li>password:数据库连接密码</li>
<li>数据库连接的四要素要和自己使用的数据库信息一致。</li>
</ul>
<h5 id="步骤3从ioc容器中获取对应的bean对象"><a class="markdownIt-Anchor" href="#步骤3从ioc容器中获取对应的bean对象"></a> 步骤3:从IOC容器中获取对应的bean对象</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">       <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) ctx.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">       System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤4运行程序"><a class="markdownIt-Anchor" href="#步骤4运行程序"></a> 步骤4:运行程序</h5>
<p>打印如下结果: 说明第三方bean对象已经被spring的IOC容器进行管理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  CreateTime:&quot;2023-12-11 19:06:56&quot;,</span><br><span class="line">  ActiveCount:0,</span><br><span class="line">  PoolingCount:0,</span><br><span class="line">  CreateCount:0,</span><br><span class="line">  DestroyCount:0,</span><br><span class="line">  CloseCount:0,</span><br><span class="line">  ConnectCount:0,</span><br><span class="line">  Connections:[</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>第三方的类指的是什么?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DruidDataSource</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如何注入数据库连接四要素?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setter注入</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="114-实现c3p0管理"><a class="markdownIt-Anchor" href="#114-实现c3p0管理"></a> 1.1.4 实现C3P0管理</h4>
<p>完成了DruidDataSource的管理，接下来再来加深下练习，这次来管理<code>C3P0</code>数据源，具体的实现步骤是什么呢?</p>
<blockquote>
<p>需求:使用Spring的IOC容器来管理C3P0连接池对象</p>
<p>实现方案和上面基本一致，重点要关注管理的是哪个bean对象`?</p>
</blockquote>
<h5 id="步骤1导入c3p0的依赖"><a class="markdownIt-Anchor" href="#步骤1导入c3p0的依赖"></a> 步骤1:导入<code>C3P0</code>的依赖</h5>
<p>pom.xml中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>对于新的技术，不知道具体的坐标该如何查找?</strong></p>
<ul>
<li>
<p>直接百度搜索</p>
</li>
<li>
<p>从mvn的仓库<code>https://mvnrepository.com/</code>中进行搜索</p>
</li>
</ul>
<h5 id="步骤2配置第三方bean-2"><a class="markdownIt-Anchor" href="#步骤2配置第三方bean-2"></a> 步骤2:配置第三方bean</h5>
<p>在applicationContext.xml配置文件中添加配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><mark>注意:</mark></strong></p>
<ul>
<li>ComboPooledDataSource的属性是通过setter方式进行注入</li>
<li>想注入属性就需要在ComboPooledDataSource类或其上层类中有提供属性对应的setter方法</li>
<li>C3P0的四个属性和Druid的四个属性是不一样的</li>
</ul>
<h5 id="步骤3运行程序"><a class="markdownIt-Anchor" href="#步骤3运行程序"></a> 步骤3:运行程序</h5>
<p>程序会报错，错误如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">警告: Could not load driverClass com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>报的错为<mark>ClassNotFoundException</mark>,翻译出来是<code>类没有发现的异常</code>，具体的类为<code>com.mysql.jdbc.Driver</code>。错误的原因是缺少mysql的驱动包。</p>
<p>分析出错误的原因，具体的解决方案就比较简单，只需要在pom.xml把驱动包引入即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加完mysql的驱动包以后，再次运行App,就可以打印出结果并不报错</p>
<p><strong>注意：</strong></p>
<ul>
<li>数据连接池在配置属性的时候，除了可以注入数据库连接四要素外还可以配置很多其他的属性，具体都有哪些属性用到的时候再去查，一般配置基础的四个，其他都有自己的默认值</li>
<li>Druid和C3P0在没有导入mysql驱动包的前提下，一个没报错一个报错，说明Druid在初始化的时候没有去加载驱动，而C3P0刚好相反</li>
<li>Druid程序运行虽然没有报错，但是当调用DruidDataSource的getConnection()方法获取连接的时候，也会报找不到驱动类的错误</li>
</ul>
<h3 id="12-加载properties文件"><a class="markdownIt-Anchor" href="#12-加载properties文件"></a> 1.2 加载properties文件</h3>
<p>上节中已经完成两个数据源<code>druid</code>和<code>C3P0</code>的配置，但是其中包含了一些问题，来分析下:</p>
<ul>
<li>这两个数据源中都使用到了一些固定的常量如数据库连接四要素，把这些值写在Spring的配置文件中不利于后期维护</li>
<li>需要将这些值提取到一个外部的properties配置文件中</li>
<li>Spring框架如何从配置文件中读取属性值来配置就是接下来要解决的问题。</li>
</ul>
<p>问题提出来后，具体该如何实现?</p>
<h4 id="121-第三方bean属性优化"><a class="markdownIt-Anchor" href="#121-第三方bean属性优化"></a> 1.2.1 第三方bean属性优化</h4>
<h5 id="1211-实现思路"><a class="markdownIt-Anchor" href="#1211-实现思路"></a> 1.2.1.1 实现思路</h5>
<blockquote>
<p>需求:将数据库连接四要素提取到properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入。</p>
<p>1.在resources下创建一个jdbc.properties(文件的名称可以任意)</p>
<p>2.将数据库连接四要素配置到配置文件中</p>
<p>3.在Spring的配置文件中加载properties文件</p>
<p>4.使用加载到的值实现属性注入</p>
<p>其中第3，4步骤是需要重点关注，具体是如何实现。</p>
</blockquote>
<h5 id="1212-实现步骤"><a class="markdownIt-Anchor" href="#1212-实现步骤"></a> 1.2.1.2 实现步骤</h5>
<h6 id="步骤1准备properties配置文件"><a class="markdownIt-Anchor" href="#步骤1准备properties配置文件"></a> 步骤1:准备properties配置文件</h6>
<p>resources下创建一个jdbc.properties文件,并添加对应的属性键值对</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<h6 id="步骤2开启context命名空间"><a class="markdownIt-Anchor" href="#步骤2开启context命名空间"></a> 步骤2:开启<code>context</code>命名空间</h6>
<p>在applicationContext.xml中开<code>context</code>命名空间</p>
<p><img src="1629980280952.png" alt="1629980280952" /></p>
<h6 id="步骤3加载properties配置文件"><a class="markdownIt-Anchor" href="#步骤3加载properties配置文件"></a> 步骤3:加载properties配置文件</h6>
<p>在配置文件中使用<code>context</code>命名空间下的标签来加载properties配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="步骤4完成属性注入"><a class="markdownIt-Anchor" href="#步骤4完成属性注入"></a> 步骤4:完成属性注入</h6>
<p>使用<code>$&#123;key&#125;</code>来读取properties配置文件中的内容并完成属性注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>至此，读取外部properties配置文件中的内容就已经完成。</p>
<h4 id="122-读取单个属性"><a class="markdownIt-Anchor" href="#122-读取单个属性"></a> 1.2.2 读取单个属性</h4>
<h5 id="1221-实现思路"><a class="markdownIt-Anchor" href="#1221-实现思路"></a> 1.2.2.1 实现思路</h5>
<p>对于上面的案例，效果不是很明显，可以换个案例来演示下:</p>
<blockquote>
<p>需求:从properties配置文件中读取key为name的值，并将其注入到BookDao中并在save方法中进行打印。</p>
<p>1.在项目中添加BookDao和BookDaoImpl类</p>
<p>2.为BookDaoImpl添加一个name属性并提供setter方法</p>
<p>3.在jdbc.properties中添加数据注入到bookDao中打印方便查询结果</p>
<p>4.在applicationContext.xml添加配置完成配置文件加载、属性注入(${key})</p>
</blockquote>
<h5 id="1222-实现步骤"><a class="markdownIt-Anchor" href="#1222-实现步骤"></a> 1.2.2.2 实现步骤</h5>
<h6 id="步骤1在项目中添对应的类"><a class="markdownIt-Anchor" href="#步骤1在项目中添对应的类"></a> 步骤1:在项目中添对应的类</h6>
<p>BookDao和BookDaoImpl类，并在BookDaoImpl类中添加<code>name</code>属性与setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="步骤2完成配置文件的读取与注入"><a class="markdownIt-Anchor" href="#步骤2完成配置文件的读取与注入"></a> 步骤2:完成配置文件的读取与注入</h6>
<p>在applicationContext.xml添加配置，<code>bean的配置管理</code>、<code>读取外部properties</code>、<code>依赖注入</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="步骤3运行程序-2"><a class="markdownIt-Anchor" href="#步骤3运行程序-2"></a> 步骤3:运行程序</h6>
<p>在App类中，从IOC容器中获取bookDao对象，调用方法，查看值是否已经被获取到并打印控制台</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book dao save ...com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
<h5 id="1223-注意事项"><a class="markdownIt-Anchor" href="#1223-注意事项"></a> 1.2.2.3 注意事项</h5>
<p>至此，读取properties配置文件中的内容就已经完成，但是在使用的时候，有些注意事项:</p>
<ul>
<li>
<p>问题一:键值对的key为<code>username</code>引发的问题</p>
<p>1.在properties中配置键值对的时候，如果key设置为<code>username</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=root666</span><br></pre></td></tr></table></figure>
<p>2.在applicationContext.xml注入该属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.运行后，在控制台打印的却不是<code>root666</code>，而是自己电脑的用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book dao save ...自己电脑的用户名</span><br></pre></td></tr></table></figure>
<p>4.出现问题的原因是<code>&lt;context:property-placeholder/&gt;</code>标签会加载系统的环境变量，而且环境变量的值会被优先加载，如何查看系统的环境变量?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">      Map&lt;String, String&gt; env = System.getenv();</span><br><span class="line">    System.out.println(env);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以自行运行，在打印出来的结果中会有一个USERNAME=XXX[自己电脑的用户名称]</p>
<p>5.解决方案</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">              http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">              http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">              http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">              http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>system-properties-mode:设置为NEVER,表示不加载系统属性，就可以解决上述问题。</p>
<p>当然还有一个解决方案就是避免使用<code>username</code>作为属性的<code>key</code>。</p>
</li>
<li>
<p>问题二:当有多个properties配置文件需要被加载，该如何配置?</p>
<p>1.调整下配置文件的内容，在resources下添加<code>jdbc.properties</code>,<code>jdbc2.properties</code>,内容如下:</p>
<p>jdbc.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>jdbc2.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root666</span></span><br></pre></td></tr></table></figure>
<p>2.修改applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式一 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties,jdbc2.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式三 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式四--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>方式一:可以实现，如果配置文件多的话，每个都需要配置</li>
<li>方式二:<code>*.properties</code>代表所有以properties结尾的文件都会被加载，可以解决方式一的问题，但是不标准</li>
<li>方式三:标准的写法，<code>classpath:</code>代表的是从根路径下开始查找，但是只能查询当前项目的根路径</li>
<li>方式四:不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件</li>
</ul>
</li>
</ul>
<h4 id="123-加载properties文件小结"><a class="markdownIt-Anchor" href="#123-加载properties文件小结"></a> 1.2.3 加载properties文件小结</h4>
<p>本节主要讲解的是properties配置文件的加载，需要掌握的内容有:</p>
<ul>
<li>
<p>如何开启<code>context</code>命名空间</p>
<p><img src="1629980280952.png" alt="1629980280952" /></p>
</li>
<li>
<p>如何加载properties配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如何在applicationContext.xml引入properties配置文件中的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;key&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-核心容器"><a class="markdownIt-Anchor" href="#2-核心容器"></a> 2. 核心容器</h2>
<p>前面已经完成bean与依赖注入的相关知识学习，接下来主要学习的是IOC容器中的<mark>核心容器</mark>。</p>
<p>这里所说的核心容器，可以把它简单的理解为<code>ApplicationContext</code>:</p>
<ul>
<li>如何创建容器?</li>
<li>创建好容器后，如何从容器中获取bean对象?</li>
<li>容器类的层次结构是什么?</li>
<li>BeanFactory是什么?</li>
</ul>
<h3 id="21-环境准备"><a class="markdownIt-Anchor" href="#21-环境准备"></a> 2.1 环境准备</h3>
<p>在学习和解决上述问题之前，先来准备下案例环境:</p>
<ul>
<li>
<p>创建一个Maven项目</p>
</li>
<li>
<p>pom.xml添加Spring的依赖</p>
</li>
<li>
<p>resources下添加applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加BookDao和BookDaoImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建运行类App</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="22-容器"><a class="markdownIt-Anchor" href="#22-容器"></a> 2.2 容器</h3>
<h4 id="221-容器的创建方式"><a class="markdownIt-Anchor" href="#221-容器的创建方式"></a> 2.2.1 容器的创建方式</h4>
<p>案例中创建<code>ApplicationContext</code>的方式为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这种方式翻译为:<mark>类路径下的XML配置文件</mark></p>
<p>除了上面这种方式，Spring还提供了另外一种创建方式(<mark>不推荐此方式</mark>):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\\workspace\\spring\\spring_10_container\\src\\main\\resources\\applicationContext.xml&quot;</span>); </span><br></pre></td></tr></table></figure>
<p>这种方式翻译为:<mark>文件系统下的XML配置文件</mark></p>
<h4 id="222-bean的三种获取方式"><a class="markdownIt-Anchor" href="#222-bean的三种获取方式"></a> 2.2.2 Bean的三种获取方式</h4>
<p>方式一，就是目前案例中获取的方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这种方式存在的问题是每次获取的时候都需要进行类型转换，有没有更简单的方式呢?</p>
<p>方式二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BookDao bookDao = ctx.getBean(&quot;bookDao&quot;，BookDao.class);</span><br></pre></td></tr></table></figure>
<p>这种方式可以解决类型强转问题，但是参数又多加了一个，相对来说没有简化多少。</p>
<p>方式三:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BookDao bookDao = ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure>
<p>这种方式就类似之前所学习依赖注入中的按类型注入。必须要确保IOC容器中该类型对应的bean对象只能有一个。</p>
<h4 id="223-beanfactory的使用"><a class="markdownIt-Anchor" href="#223-beanfactory的使用"></a> 2.2.3 BeanFactory的使用</h4>
<p>使用BeanFactory来创建IOC容器的具体实现方式为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resources);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bf.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Spring中，<code>BeanFactory</code>和<code>ApplicationContext</code>都是用来管理和提供对象的容器。它们之间的主要区别在于实例化和初始化bean对象的时机。</p>
<p><code>BeanFactory</code>采用延迟加载策略，即只有在你通过调用<code>getBean()</code>方法获取bean对象时，才会触发相应的实例化和初始化过程。这意味着在容器加载时，并不会创建所有的bean对象，而是在需要时按需创建。</p>
<p>相反，<code>ApplicationContext</code>是立即加载的，即在容器加载的过程中就会创建和初始化所有的bean对象。这是因为<code>ApplicationContext</code>在创建的同时会解析和实例化所有的bean定义，并初始化它们的依赖关系，以提供更快的访问速度和更早的错误检测。</p>
<p>因此，如果你希望延迟加载和按需创建bean对象，可以使用<code>BeanFactory</code>。如果你需要在应用程序启动时立即加载和初始化所有的bean对象，可以使用<code>ApplicationContext</code>。</p>
<p>值得注意的是，<code>ApplicationContext</code>是<code>BeanFactory</code>的子接口，它提供了更多的功能，如国际化支持、事件发布、AOP等。因此，在大多数情况下，我们<mark>更倾向于使用<code>ApplicationContext</code>来管理bean对象</mark>。</p>
<ul>
<li>
<p>BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建</p>
</li>
<li>
<p>ApplicationContext是立即加载，容器加载的时候就会创建bean对象</p>
</li>
<li>
<p>ApplicationContext要想成为延迟加载，只需要按照如下方式进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>  <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>小结</strong></p>
<p>这一节中所讲的知识点包括:</p>
<ul>
<li>
<p>容器创建的两种方式</p>
<ul>
<li>ClassPathXmlApplicationContext[掌握]</li>
<li>FileSystemXmlApplicationContext[知道即可]</li>
</ul>
</li>
<li>
<p>获取Bean的三种方式</p>
<ul>
<li>getBean(“名称”):需要类型转换</li>
<li>getBean(“名称”,类型.class):多了一个参数</li>
<li>getBean(类型.class):容器中不能有多个该类的bean对象</li>
</ul>
<p>上述三种方式，各有各的优缺点，用哪个都可以。</p>
</li>
<li>
<p>容器类层次结构</p>
<ul>
<li>只需要知晓容器的最上级的父接口为 BeanFactory即可</li>
</ul>
</li>
<li>
<p>BeanFactory</p>
<ul>
<li>使用BeanFactory创建的容器是延迟加载</li>
<li>使用ApplicationContext创建的容器是立即加载</li>
<li>具体BeanFactory如何创建只需要了解即可。</li>
</ul>
</li>
</ul>
<h3 id="23-核心容器总结"><a class="markdownIt-Anchor" href="#23-核心容器总结"></a> 2.3 核心容器总结</h3>
<h4 id="231-容器相关"><a class="markdownIt-Anchor" href="#231-容器相关"></a> 2.3.1 容器相关</h4>
<ul>
<li>BeanFactory是IOC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li>
<li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li>
<li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li>
<li>ApplicationContext接口常用初始化类
<ul>
<li><strong><mark>ClassPathXmlApplicationContext(常用)</mark></strong></li>
<li>FileSystemXmlApplicationContext</li>
</ul>
</li>
</ul>
<h4 id="232-bean相关"><a class="markdownIt-Anchor" href="#232-bean相关"></a> 2.3.2 bean相关</h4>
<p><img src="1629986510487.png" alt="1629986510487" /></p>
<p>其实整个配置中最常用的就两个属性<mark>id</mark>和<mark>class</mark>。</p>
<h2 id="3-iocdi注解开发"><a class="markdownIt-Anchor" href="#3-iocdi注解开发"></a> 3. IOC/DI注解开发</h2>
<p>Spring的IOC/DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在<mark>配置文件</mark>。</p>
<p>前面聊Spring的时候说过，Spring可以简化代码的开发，到现在并没有体会到。</p>
<p>所以Spring到底是如何简化代码开发的呢?</p>
<p>要想真正简化开发，就需要用到Spring的注解开发</p>
<p>关于注解开发，会讲解两块内容<code>注解开发定义bean</code>和<code>纯注解开发</code>。</p>
<p>注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。</p>
<h3 id="31-环境准备"><a class="markdownIt-Anchor" href="#31-环境准备"></a> 3.1 环境准备</h3>
<p>在学习注解开发之前，先来准备下案例环境:</p>
<ul>
<li>
<p>创建一个Maven项目</p>
</li>
<li>
<p>pom.xml添加Spring的依赖</p>
</li>
<li>
<p>resources下添加applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加BookDao、BookDaoImpl、BookService、BookServiceImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建运行类App</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="32-注解开发定义bean"><a class="markdownIt-Anchor" href="#32-注解开发定义bean"></a> 3.2 注解开发定义bean</h3>
<h4 id="步骤1删除原xml配置"><a class="markdownIt-Anchor" href="#步骤1删除原xml配置"></a> 步骤1:删除原XML配置</h4>
<p>将配置文件中的<code>&lt;bean&gt;</code>标签删除掉</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="步骤2dao上添加注解"><a class="markdownIt-Anchor" href="#步骤2dao上添加注解"></a> 步骤2:Dao上添加注解</h4>
<p>在BookDaoImpl类上添加<code>@Component</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>注意:@Component注解不可以添加在接口上，因为接口是无法创建对象的。</mark></p>
<p>XML与注解配置的对应关系:</p>
<p><img src="1629990315619.png" alt="1629990315619" /></p>
<h4 id="步骤3配置spring的注解包扫描"><a class="markdownIt-Anchor" href="#步骤3配置spring的注解包扫描"></a> 步骤3:配置Spring的注解包扫描</h4>
<p>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>component-scan</p>
<ul>
<li>component:组件,Spring将管理的bean视作自己的一个组件</li>
<li>scan:扫描</li>
</ul>
<p>base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</p>
<ul>
<li>包路径越多[如:com.itheima.dao.impl]，扫描的范围越小速度越快</li>
<li>包路径越少[如:com.itheima],扫描的范围越大速度越慢</li>
<li>一般扫描到项目的组织名称即Maven的groupId下[如:com.itheima]即可。</li>
</ul>
<h4 id="步骤4运行程序-2"><a class="markdownIt-Anchor" href="#步骤4运行程序-2"></a> 步骤4：运行程序</h4>
<h4 id="步骤5service上添加注解"><a class="markdownIt-Anchor" href="#步骤5service上添加注解"></a> 步骤5:Service上添加注解</h4>
<p>在BookServiceImpl类上也添加<code>@Component</code>交给Spring框架管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="步骤6运行程序"><a class="markdownIt-Anchor" href="#步骤6运行程序"></a> 步骤6:运行程序</h4>
<p>在App类中，从IOC容器中获取BookServiceImpl对应的bean对象，打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        <span class="comment">//按类型获取bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        System.out.println(bookService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印观察结果，两个bean对象都已经打印到控制台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.dao.impl.BookDaoImpl@57f23557</span><br><span class="line">com.itheima.service.impl.BookServiceImpl@43d7741f</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>
<p>BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象</p>
</li>
<li>
<p>@Component注解如果不起名称，会有一个默认值就是<code>当前类名首字母小写</code>，所以也可以按照名称获取，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService)ctx.getBean(<span class="string">&quot;bookServiceImpl&quot;</span>);</span><br><span class="line">System.out.println(bookService);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code></p>
<p>通过查看源码会发现这三个注解和@Component注解的作用是一样的，为什么要衍生出这三个呢?</p>
<p>具体来说，这些注解的作用和功能与<code>@Component</code>完全相同，都是将Java类标记为Spring组件，并交由Spring容器管理。但是，它们的语义和用途略有不同，如下所示：</p>
<ul>
<li><code>@Controller</code>注解用于标记控制器层（MVC中的控制器），主要用于处理用户请求和响应。</li>
<li><code>@Service</code>注解用于标记服务层（业务层），主要实现业务逻辑的处理。</li>
<li><code>@Repository</code>注解用于标记数据访问层，主要实现数据访问和持久化操作。</li>
</ul>
<h4 id="知识点1component等"><a class="markdownIt-Anchor" href="#知识点1component等"></a> 知识点1:@Component等</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>@Component/@Controller/@Service/@Repository</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>类注解</td>
</tr>
<tr>
<td>位置</td>
<td>类定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>设置该类为spring管理的bean</td>
</tr>
<tr>
<td>属性</td>
<td>value（默认）：定义bean的id</td>
</tr>
</tbody>
</table>
<h3 id="32-纯注解开发模式"><a class="markdownIt-Anchor" href="#32-纯注解开发模式"></a> 3.2 纯注解开发模式</h3>
<p>上面已经可以使用注解来配置bean,但是依然有用到配置文件，在配置文件中对包进行了扫描，Spring在3.0版已经支持纯注解开发</p>
<ul>
<li>Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道</li>
</ul>
<p>具体如何实现?</p>
<h4 id="321-思路分析"><a class="markdownIt-Anchor" href="#321-思路分析"></a> 3.2.1 思路分析</h4>
<p>实现思路为:</p>
<ul>
<li>将配置文件applicationContext.xml删除掉，使用类来替换。</li>
</ul>
<h4 id="322-实现步骤"><a class="markdownIt-Anchor" href="#322-实现步骤"></a> 3.2.2 实现步骤</h4>
<h5 id="步骤1创建配置类"><a class="markdownIt-Anchor" href="#步骤1创建配置类"></a> 步骤1:创建配置类</h5>
<p>创建一个配置类<code>SpringConfig</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="步骤2标识该类为配置类"><a class="markdownIt-Anchor" href="#步骤2标识该类为配置类"></a> 步骤2:标识该类为配置类</h5>
<p>在配置类上添加<code>@Configuration</code>注解，将其标识为一个配置类,替换<code>applicationContext.xml</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤3用注解替换包扫描配置"><a class="markdownIt-Anchor" href="#步骤3用注解替换包扫描配置"></a> 步骤3:用注解替换包扫描配置</h5>
<p>在配置类上添加包扫描注解<code>@ComponentScan</code>替换<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤4创建运行类并执行"><a class="markdownIt-Anchor" href="#步骤4创建运行类并执行"></a> 步骤4:创建运行类并执行</h5>
<p>创建一个新的运行类<code>AppForAnnotation</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAnnotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        System.out.println(bookService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行AppForAnnotation,可以看到两个对象依然被获取成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.dao.impl.BookDaoImpl@57f23557</span><br><span class="line">com.itheima.service.impl.BookServiceImpl@43d7741f</span><br></pre></td></tr></table></figure>
<p>至此，纯注解开发的方式就已经完成了，主要内容包括:</p>
<ul>
<li>
<p>Java类替换Spring核心配置文件</p>
<p><img src="1630029254372.png" alt="1630029254372" /></p>
</li>
<li>
<p>@Configuration注解用于设定当前类为配置类</p>
</li>
<li>
<p>@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>读取<strong>Spring核心配置文件初始化容器对象</strong>切换为读取<strong>Java配置类初始化容器对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载配置文件初始化容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="comment">//加载配置类初始化容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="知识点1configuration"><a class="markdownIt-Anchor" href="#知识点1configuration"></a> 知识点1：@Configuration</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>@Configuration</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>类注解</td>
</tr>
<tr>
<td>位置</td>
<td>类定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>设置该类为spring配置类</td>
</tr>
<tr>
<td>属性</td>
<td>value（默认）：定义bean的id</td>
</tr>
</tbody>
</table>
<h4 id="知识点2componentscan"><a class="markdownIt-Anchor" href="#知识点2componentscan"></a> 知识点2：@ComponentScan</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>@ComponentScan</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>类注解</td>
</tr>
<tr>
<td>位置</td>
<td>类定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td>
</tr>
<tr>
<td>属性</td>
<td>value（默认）：扫描路径，此路径可以逐层向下扫描</td>
</tr>
</tbody>
</table>
<p><strong>小结:</strong></p>
<p>这一节重点掌握的是使用注解完成Spring的bean管理，需要掌握的内容为:</p>
<ul>
<li>记住<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>四个注解</li>
<li><code>applicationContext.xml</code>中<code>&lt;context:component-san/&gt;</code>的作用是指定扫描包路径，注解为<code>@ComponentScan</code></li>
<li><code>@Configuration</code>标识该类为配置类，使用类替换<code>applicationContext.xml</code>文件</li>
<li><code>ClassPathXmlApplicationContext</code>是加载XML配置文件</li>
<li><code>AnnotationConfigApplicationContext</code>是加载配置类</li>
</ul>
<h3 id="33-注解开发bean作用范围与生命周期管理"><a class="markdownIt-Anchor" href="#33-注解开发bean作用范围与生命周期管理"></a> 3.3 注解开发bean作用范围与生命周期管理</h3>
<p>使用注解已经完成了bean的管理，接下来按照前面所学习的内容，将通过配置实现的内容都换成对应的注解实现，包含两部分内容:<code>bean作用范围</code>和<code>bean生命周期</code>。</p>
<h4 id="331-环境准备"><a class="markdownIt-Anchor" href="#331-环境准备"></a> 3.3.1 环境准备</h4>
<p>老规矩，学习之前先来准备环境:</p>
<ul>
<li>
<p>创建一个Maven项目</p>
</li>
<li>
<p>pom.xml添加Spring的依赖</p>
</li>
<li>
<p>添加一个配置类<code>SpringConfig</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加BookDao、BookDaoImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建运行类App</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="332-bean的作用范围"><a class="markdownIt-Anchor" href="#332-bean的作用范围"></a> 3.3.2 Bean的作用范围</h4>
<p>(1)先运行App类,在控制台打印两个一摸一样的地址，说明默认情况下bean是单例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.BookDaoImpl@71809907</span><br><span class="line">com.itheima.BookDaoImpl@71809907</span><br></pre></td></tr></table></figure>
<p>(2)要想将BookDaoImpl变成非单例，只需要在其类上添加<code>@scope</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="comment">//@Scope设置bean的作用范围</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次执行App类，打印结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.BookDaoImpl@6356695f</span><br><span class="line">com.itheima.BookDaoImpl@4f18837a</span><br></pre></td></tr></table></figure>
<h5 id="知识点1scope"><a class="markdownIt-Anchor" href="#知识点1scope"></a> 知识点1：@Scope</h5>
<table>
<thead>
<tr>
<th>名称</th>
<th>@Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>类注解</td>
</tr>
<tr>
<td>位置</td>
<td>类定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>设置该类创建对象的作用范围<br/>可用于设置创建出的bean是否为单例对象</td>
</tr>
<tr>
<td>属性</td>
<td>value（默认）：定义bean作用范围，<br/><mark>默认值singleton（单例），可选值prototype（非单例）</mark></td>
</tr>
</tbody>
</table>
<h4 id="333-bean的生命周期"><a class="markdownIt-Anchor" href="#333-bean的生命周期"></a> 3.3.3 Bean的生命周期</h4>
<p>(1)在BookDaoImpl中添加两个方法，<code>init</code>和<code>destroy</code>,方法名可以任意</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(2)如何对方法进行标识，哪个是初始化方法，哪个是销毁方法?</p>
<p>只需要在对应的方法上添加<code>@PostConstruct</code>和<code>@PreDestroy</code>注解即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">//在构造方法之后执行，替换 init-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">//在销毁方法之前执行,替换 destroy-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(3)要想看到两个方法执行，需要注意的是<code>destroy</code>只有在容器关闭的时候，才会执行，所以需要修改App的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">        ctx.close(); <span class="comment">//关闭容器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)运行App,类查看打印结果，证明init和destroy方法都被执行了。</p>
<p>单例模式下的执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init ...</span><br><span class="line">com.itheima.BookDaoImpl@436813f3</span><br><span class="line">com.itheima.BookDaoImpl@436813f3</span><br><span class="line">destroy ...</span><br></pre></td></tr></table></figure>
<p><mark><strong>注意:</strong>@PostConstruct和@PreDestroy注解如果找不到，需要导入下面的jar包</mark></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.annotation&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.3</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>找不到的原因是，从JDK9以后jdk中的javax.annotation包被移除了，这两个注解刚好就在这个包中。</p>
<h5 id="知识点1postconstruct"><a class="markdownIt-Anchor" href="#知识点1postconstruct"></a> 知识点1：@PostConstruct</h5>
<table>
<thead>
<tr>
<th>名称</th>
<th>@PostConstruct</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>方法注解</td>
</tr>
<tr>
<td>位置</td>
<td>方法上</td>
</tr>
<tr>
<td>作用</td>
<td>设置该方法为初始化方法</td>
</tr>
<tr>
<td>属性</td>
<td>无</td>
</tr>
</tbody>
</table>
<h5 id="知识点2predestroy"><a class="markdownIt-Anchor" href="#知识点2predestroy"></a> 知识点2：@PreDestroy</h5>
<table>
<thead>
<tr>
<th>名称</th>
<th>@PreDestroy</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>方法注解</td>
</tr>
<tr>
<td>位置</td>
<td>方法上</td>
</tr>
<tr>
<td>作用</td>
<td>设置该方法为销毁方法</td>
</tr>
<tr>
<td>属性</td>
<td>无</td>
</tr>
</tbody>
</table>
<p><strong>小结</strong></p>
<p><img src="1630033039358.png" alt="1630033039358" /></p>
<h3 id="34-注解开发依赖注入"><a class="markdownIt-Anchor" href="#34-注解开发依赖注入"></a> 3.4 注解开发依赖注入</h3>
<p>Spring为了使用注解简化开发，并没有提供<code>构造函数注入</code>、<code>setter注入</code>对应的注解，只提供了自动装配的注解实现。</p>
<h4 id="341-环境准备"><a class="markdownIt-Anchor" href="#341-环境准备"></a> 3.4.1 环境准备</h4>
<p>在学习之前，把案例环境介绍下:</p>
<ul>
<li>
<p>创建一个Maven项目</p>
</li>
<li>
<p>pom.xml添加Spring的依赖</p>
</li>
<li>
<p>添加一个配置类<code>SpringConfig</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加BookDao、BookDaoImpl、BookService、BookServiceImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建运行类App</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>环境准备好后，运行后会发现有问题:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;com.itheima.dao.BookDao.save()&quot; because &quot;this.bookDao&quot; is null</span><br></pre></td></tr></table></figure>
<p>出现问题的原因是，在BookServiceImpl类中添加了BookDao的属性，并提供了setter方法，但是目前是没有提供配置注入BookDao的，所以bookDao对象为Null,调用其save方法就会报<code>控指针异常</code>。</p>
<h4 id="342-注解实现按照类型注入"><a class="markdownIt-Anchor" href="#342-注解实现按照类型注入"></a> 3.4.2 注解实现按照类型注入</h4>
<p>对于这个问题使用注解该如何解决?</p>
<p>(1) 在BookServiceImpl类的bookDao属性上添加<code>@Autowired</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    public void setBookDao(BookDao bookDao) &#123;</span></span><br><span class="line"><span class="comment">//        this.bookDao = bookDao;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>@Autowired可以写在属性上，也可也写在setter方法上，最简单的处理方式是<code>写在属性上并将setter方法删除掉</code></li>
<li>为什么setter方法可以删除呢?
<ul>
<li>自动装配基于反射设计创建对象并通过暴力反射为私有属性进行设值</li>
<li>普通反射只能获取public修饰的内容</li>
<li>暴力反射除了获取public修饰的内容还可以获取private修改的内容</li>
<li>所以此处无需提供setter方法</li>
</ul>
</li>
</ul>
<p>(2)@Autowired是按照类型注入，那么对应BookDao接口如果有多个实现类，比如添加BookDaoImpl2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候再次运行App，就会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException</span><br></pre></td></tr></table></figure>
<p>此时，按照类型注入就无法区分到底注入哪个对象，解决方案:<code>按照名称注入</code></p>
<ul>
<li>
<p>先给两个Dao类分别起个名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository(&quot;bookDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时就可以注入成功，但是得思考个问题:</p>
<ul>
<li>
<p>@Autowired是按照类型注入的，给BookDao的两个实现起了名称，它还是有两个bean对象，为什么不报错?</p>
</li>
<li>
<p>@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫<code>bookDao</code>而容器中也有一个<code>booDao</code>，所以可以成功注入。</p>
</li>
<li>
<p>分析下面这种情况是否能完成注入呢?</p>
<p><img src="1630036236150.png" alt="1630036236150" /></p>
</li>
<li>
<p>不行，因为按照类型会找到多个bean对象，此时会按照<code>bookDao</code>名称去找，因为IOC容器只有名称叫<code>bookDao1</code>和<code>bookDao2</code>,所以找不到，会报<code>NoUniqueBeanDefinitionException</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="343-注解实现按照名称注入"><a class="markdownIt-Anchor" href="#343-注解实现按照名称注入"></a> 3.4.3 注解实现按照名称注入</h4>
<p>当根据类型在容器中找到多个bean,注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;bookDao1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Qualifier注解后的值就是需要注入的bean的名称。</p>
<p><mark>注意:@Qualifier不能独立使用，必须和@Autowired一起使用</mark></p>
<h4 id="344-简单数据类型注入"><a class="markdownIt-Anchor" href="#344-简单数据类型注入"></a> 3.4.4 简单数据类型注入</h4>
<p>引用类型看完，简单类型注入就比较容易懂了。简单类型注入的是基本数据类型或者字符串类型，下面在<code>BookDaoImpl</code>类中添加一个<code>name</code>属性，用其进行简单类型注入</p>
<p>数据类型换了，对应的注解也要跟着换，这次使用<code>@Value</code>注解，将值写入注解的参数中就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;itheima&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意数据格式要匹配，如将&quot;abc&quot;注入给int值，这样程序就会报错。</p>
<p>介绍完后，会有一种感觉就是这个注解好像没什么用，跟直接赋值是一个效果，还没有直接赋值简单，所以这个注解存在的意义是什么?</p>
<h4 id="345-注解读取properties配置文件"><a class="markdownIt-Anchor" href="#345-注解读取properties配置文件"></a> 3.4.5 注解读取properties配置文件</h4>
<p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p>
<h5 id="步骤1resource下准备properties文件"><a class="markdownIt-Anchor" href="#步骤1resource下准备properties文件"></a> 步骤1：resource下准备properties文件</h5>
<p>jdbc.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">itheima888</span></span><br></pre></td></tr></table></figure>
<h5 id="步骤2-使用注解加载properties配置文件"><a class="markdownIt-Anchor" href="#步骤2-使用注解加载properties配置文件"></a> 步骤2: 使用注解加载properties配置文件</h5>
<p>在配置类上添加<code>@PropertySource</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="步骤3使用value读取配置文件中的内容"><a class="markdownIt-Anchor" href="#步骤3使用value读取配置文件中的内容"></a> 步骤3：使用@Value读取配置文件中的内容</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤4运行程序-3"><a class="markdownIt-Anchor" href="#步骤4运行程序-3"></a> 步骤4:运行程序</h5>
<p>运行App类，查看运行结果，说明配置文件中的内容已经被加载到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book service save ...</span><br><span class="line">book dao save ...itheima888</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>
<p>如果读取的properties配置文件有多个，可以使用<code>@PropertySource</code>的属性来指定多个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;xxx.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>@PropertySource</code>注解属性中不支持使用通配符<code>*</code>,运行会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;*.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>@PropertySource</code>注解属性中可以把<code>classpath:</code>加上,代表从当前项目的根路径找文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="知识点1autowired"><a class="markdownIt-Anchor" href="#知识点1autowired"></a> 知识点1：@Autowired</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>@Autowired</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>属性注解  或  方法注解（了解）  或  方法形参注解（了解）</td>
</tr>
<tr>
<td>位置</td>
<td>属性定义上方  或  标准set方法上方  或  类set方法上方  或  方法形参前面</td>
</tr>
<tr>
<td>作用</td>
<td>为引用类型属性设置值</td>
</tr>
<tr>
<td>属性</td>
<td>required：true/false，定义该属性是否允许为null</td>
</tr>
</tbody>
</table>
<h4 id="知识点2qualifier"><a class="markdownIt-Anchor" href="#知识点2qualifier"></a> 知识点2：@Qualifier</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>@Qualifier</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>属性注解  或  方法注解（了解）</td>
</tr>
<tr>
<td>位置</td>
<td>属性定义上方  或  标准set方法上方  或  类set方法上方</td>
</tr>
<tr>
<td>作用</td>
<td>为引用类型属性指定注入的beanId</td>
</tr>
<tr>
<td>属性</td>
<td>value（默认）：设置注入的beanId</td>
</tr>
</tbody>
</table>
<h4 id="知识点3value"><a class="markdownIt-Anchor" href="#知识点3value"></a> 知识点3：@Value</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>属性注解  或  方法注解（了解）</td>
</tr>
<tr>
<td>位置</td>
<td>属性定义上方  或  标准set方法上方  或  类set方法上方</td>
</tr>
<tr>
<td>作用</td>
<td>为  基本数据类型  或  字符串类型  属性设置值</td>
</tr>
<tr>
<td>属性</td>
<td>value（默认）：要注入的属性值</td>
</tr>
</tbody>
</table>
<h4 id="知识点4propertysource"><a class="markdownIt-Anchor" href="#知识点4propertysource"></a> 知识点4：@PropertySource</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>@PropertySource</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>类注解</td>
</tr>
<tr>
<td>位置</td>
<td>类定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>加载properties文件中的属性值</td>
</tr>
<tr>
<td>属性</td>
<td>value（默认）：设置加载的properties文件对应的文件名或文件名组成的数组</td>
</tr>
</tbody>
</table>
<h2 id="4-iocdi注解开发管理第三方bean"><a class="markdownIt-Anchor" href="#4-iocdi注解开发管理第三方bean"></a> 4. IOC/DI注解开发管理第三方bean</h2>
<p>前面定义bean的时候都是在自己开发的类上面写个注解就完成了，但如果是第三方的类，这些类都是在jar包中，没有办法在类上面添加注解，这个时候该怎么办?</p>
<p>遇到上述问题，就需要有一种更加灵活的方式来定义bean,这种方式不能在原始代码上面书写注解，一样能定义bean,这就用到了一个全新的注解==@Bean==。</p>
<h3 id="41-环境准备"><a class="markdownIt-Anchor" href="#41-环境准备"></a> 4.1 环境准备</h3>
<p>学习@Bean注解之前先来准备环境:</p>
<ul>
<li>
<p>创建一个Maven项目</p>
</li>
<li>
<p>pom.xml添加Spring的依赖</p>
</li>
<li>
<p>添加一个配置类<code>SpringConfig</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加BookDao、BookDaoImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建运行类App</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="42-注解开发管理第三方bean"><a class="markdownIt-Anchor" href="#42-注解开发管理第三方bean"></a> 4.2 注解开发管理第三方bean</h3>
<p>在上述环境中完成对<code>Druid</code>数据源的管理，具体的实现步骤为:</p>
<h4 id="步骤1导入对应的jar包"><a class="markdownIt-Anchor" href="#步骤1导入对应的jar包"></a> 步骤1:导入对应的jar包</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="步骤2在配置类中添加一个方法"><a class="markdownIt-Anchor" href="#步骤2在配置类中添加一个方法"></a> 步骤2:在配置类中添加一个方法</h4>
<h4 id="步骤3在方法上添加bean注解"><a class="markdownIt-Anchor" href="#步骤3在方法上添加bean注解"></a> 步骤3:在方法上添加<code>@Bean</code>注解</h4>
<p>@Bean注解的作用是将方法的返回值制作为Spring管理的一个bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">  	<span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:不能使用<code>DataSource ds = new DruidDataSource()</code></strong></p>
<p>因为DataSource接口中没有对应的setter方法来设置属性。</p>
<h4 id="步骤4从ioc容器中获取对象并打印"><a class="markdownIt-Anchor" href="#步骤4从ioc容器中获取对象并打印"></a> 步骤4:从IOC容器中获取对象并打印</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	CreateTime:&quot;2023-12-11 21:24:00&quot;,</span><br><span class="line">	ActiveCount:0,</span><br><span class="line">	PoolingCount:0,</span><br><span class="line">	CreateCount:0,</span><br><span class="line">	DestroyCount:0,</span><br><span class="line">	CloseCount:0,</span><br><span class="line">	ConnectCount:0,</span><br><span class="line">	Connections:[</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此使用@Bean来管理第三方bean的案例就已经完成。</p>
<p>如果有多个bean要被Spring管理，直接在配置类中多些几个方法，方法上添加@Bean注解即可。</p>
<h3 id="43-引入外部配置类"><a class="markdownIt-Anchor" href="#43-引入外部配置类"></a> 4.3 引入外部配置类</h3>
<p>如果把所有的第三方bean都配置到Spring的配置类<code>SpringConfig</code>中，虽然可以，但是不利于代码阅读和分类管理，所有就想能不能按照类别将这些bean配置到不同的配置类中?</p>
<p>对于数据源的bean,新建一个<code>JdbcConfig</code>配置类，并把数据源配置到该类下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在的问题是，这个配置类如何能被Spring配置类加载到，并创建DataSource对象在IOC容器中?</p>
<p>针对这个问题，有两个解决方案:</p>
<h4 id="431-使用包扫描引入不推荐"><a class="markdownIt-Anchor" href="#431-使用包扫描引入不推荐"></a> 4.3.1 使用包扫描引入(<mark>不推荐</mark>)</h4>
<h5 id="步骤1在spring的配置类上添加包扫描"><a class="markdownIt-Anchor" href="#步骤1在spring的配置类上添加包扫描"></a> 步骤1:在Spring的配置类上添加包扫描</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.config&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2在jdbcconfig上添加配置注解"><a class="markdownIt-Anchor" href="#步骤2在jdbcconfig上添加配置注解"></a> 步骤2:在JdbcConfig上添加配置注解</h5>
<p>JdbcConfig类要放入到<code>com.itheima.config</code>包下，需要被Spring的配置类扫描到即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤3运行程序-3"><a class="markdownIt-Anchor" href="#步骤3运行程序-3"></a> 步骤3:运行程序</h5>
<p>依然能获取到bean对象并打印控制台。</p>
<p>这种方式虽然能够扫描到，但是不能很快的知晓都引入了哪些配置类，所有这种方式不推荐使用。</p>
<h4 id="432-使用import引入推荐"><a class="markdownIt-Anchor" href="#432-使用import引入推荐"></a> 4.3.2 使用<code>@Import</code>引入(<mark>推荐</mark>)</h4>
<p>方案一实现起来有点小复杂，Spring早就想到了这一点，于是又给提供了第二种方案。</p>
<p>这种方案可以不用加<code>@Configuration</code>注解，但是必须在Spring配置类上使用<code>@Import</code>注解手动引入需要加载的配置类</p>
<h5 id="步骤1去除jdbcconfig类上的注解"><a class="markdownIt-Anchor" href="#步骤1去除jdbcconfig类上的注解"></a> 步骤1:去除JdbcConfig类上的注解</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2在spring配置类中引入"><a class="markdownIt-Anchor" href="#步骤2在spring配置类中引入"></a> 步骤2:在Spring配置类中引入</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan(&quot;com.itheima.config&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>
<p>扫描注解可以移除</p>
</li>
<li>
<p>@Import参数需要的是一个数组，可以引入多个配置类。</p>
</li>
<li>
<p>@Import注解在配置类中只能写一次，下面的方式是<mark>不允许的</mark></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan(&quot;com.itheima.config&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="meta">@Import(Xxx.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="步骤3运行程序-4"><a class="markdownIt-Anchor" href="#步骤3运行程序-4"></a> 步骤3:运行程序</h5>
<p>依然能获取到bean对象并打印控制台</p>
<h3 id="知识点1bean"><a class="markdownIt-Anchor" href="#知识点1bean"></a> 知识点1：@Bean</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>@Bean</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>方法注解</td>
</tr>
<tr>
<td>位置</td>
<td>方法定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>设置该方法的返回值作为spring管理的bean</td>
</tr>
<tr>
<td>属性</td>
<td>value（默认）：定义bean的id</td>
</tr>
</tbody>
</table>
<h3 id="知识点2import"><a class="markdownIt-Anchor" href="#知识点2import"></a> 知识点2：@Import</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>@Import</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>类注解</td>
</tr>
<tr>
<td>位置</td>
<td>类定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>导入配置类</td>
</tr>
<tr>
<td>属性</td>
<td>value（默认）：定义导入的配置类类名，<br/>当配置类有多个时使用数组格式一次性导入多个配置类</td>
</tr>
</tbody>
</table>
<h3 id="44-注解开发实现为第三方bean注入资源"><a class="markdownIt-Anchor" href="#44-注解开发实现为第三方bean注入资源"></a> 4.4 注解开发实现为第三方bean注入资源</h3>
<p>在使用@Bean创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办?</p>
<p>这些资源会有两大类，分别是<code>简单数据类型</code> 和<code>引用数据类型</code>。</p>
<h4 id="441-简单数据类型"><a class="markdownIt-Anchor" href="#441-简单数据类型"></a> 4.4.1 简单数据类型</h4>
<h5 id="4411-需求分析"><a class="markdownIt-Anchor" href="#4411-需求分析"></a> 4.4.1.1 需求分析</h5>
<p>对于下面代码关于数据库的四要素不应该写死在代码中，应该是从properties配置文件中读取。如何来优化下面的代码?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4412-注入简单数据类型步骤"><a class="markdownIt-Anchor" href="#4412-注入简单数据类型步骤"></a> 4.4.1.2 注入简单数据类型步骤</h5>
<h6 id="步骤1类中提供四个属性"><a class="markdownIt-Anchor" href="#步骤1类中提供四个属性"></a> 步骤1:类中提供四个属性</h6>
<h6 id="步骤2使用value注解引入值"><a class="markdownIt-Anchor" href="#步骤2使用value注解引入值"></a> 步骤2:使用<code>@Value</code>注解引入值</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc:mysql://localhost:3306/spring_db&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;password&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">  	<span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h6>
<p>现在的数据库连接四要素还是写在代码中，需要做的是将这些内容提</p>
<p>取到jdbc.properties配置文件，思考下该如何实现?</p>
<blockquote>
<p>1.resources目录下添加jdbc.properties</p>
<p>2.配置文件中提供四个键值对分别是数据库的四要素</p>
<p>3.使用@PropertySource加载jdbc.properties配置文件</p>
<p>4.修改@Value注解属性的值，将其修改为<code>$&#123;key&#125;</code>，key就是键值对中的键的值</p>
</blockquote>
<p>具体的实现就交由自行实现下。</p>
<h4 id="442-引用数据类型"><a class="markdownIt-Anchor" href="#442-引用数据类型"></a> 4.4.2 引用数据类型</h4>
<h5 id="4421-需求分析"><a class="markdownIt-Anchor" href="#4421-需求分析"></a> 4.4.2.1 需求分析</h5>
<p>假设在构建DataSource对象的时候，需要用到BookDao对象，该如何把BookDao对象注入进方法内让其使用呢?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4422-注入引用数据类型步骤"><a class="markdownIt-Anchor" href="#4422-注入引用数据类型步骤"></a> 4.4.2.2 注入引用数据类型步骤</h5>
<h6 id="步骤1在springconfig中扫描bookdao"><a class="markdownIt-Anchor" href="#步骤1在springconfig中扫描bookdao"></a> 步骤1:在SpringConfig中扫描BookDao</h6>
<p>扫描的目的是让Spring能管理到BookDao,也就是说要让IOC容器中有一个bookDao对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.dao&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="步骤2在jdbcconfig类的方法上添加参数"><a class="markdownIt-Anchor" href="#步骤2在jdbcconfig类的方法上添加参数"></a> 步骤2:在JdbcConfig类的方法上添加参数</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(BookDao bookDao)</span>&#123;</span><br><span class="line">    System.out.println(bookDao);</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(driver);</span><br><span class="line">    ds.setUrl(url);</span><br><span class="line">    ds.setUsername(userName);</span><br><span class="line">    ds.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象。</mark></p>
<h6 id="步骤3运行程序-5"><a class="markdownIt-Anchor" href="#步骤3运行程序-5"></a> 步骤3:运行程序</h6>
<h2 id="5-spring整合"><a class="markdownIt-Anchor" href="#5-spring整合"></a> 5. Spring整合</h2>
<p>学习到这里，已经对Spring有一个简单的认识了，Spring有一个容器，叫做IOC容器，里面保存bean。在进行企业级开发的时候，其实除了将自己写的类让Spring管理之外，还有一部分重要的工作就是使用第三方的技术。下面结合IOC和DI，整合2个常用技术，进一步加深对Spring的使用理解。</p>
<p><a href="https://www.bilibili.com/video/BV1Fi4y1S7ix?p=28&amp;vd_source=2e36878d9aabdc582c635ef654da6eaa">spring整合mybatis思路分析</a></p>
<p><a href="https://www.bilibili.com/video/BV1Fi4y1S7ix?p=30&amp;vd_source=2e36878d9aabdc582c635ef654da6eaa">Spring整合JUnit_</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown画图神器Mermaid</title>
    <url>/2023/11/25/Markdown%E7%94%BB%E5%9B%BE%E7%A5%9E%E5%99%A8Mermaid/</url>
    <content><![CDATA[<h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1. 前言</h1>
<ul>
<li><big><strong>碎碎念</strong></big>:握草，刚刚发现markdown里面居然可以画图，我刚才想让chatgpt给我花流程图，他给我发了一串什么的代码，之前也是发，但我没注意，这次看了后无意见贴到了Typora中，发现居然是图形，太酷了。</li>
<li>Mermaid 是一个基于 JavaScript 的图表绘制工具，它使用 Markdown 启发的文本定义和渲染器来创建和修改复杂的图表。[Mermaid中文官网](<a href="https://mermaid.nodejs.cn/intro/">关于 Mermaid | Mermaid 中文网 (nodejs.cn)</a>)</li>
<li>Mermaid用法我还不太会</li>
</ul>
<h1 id="2-hexo中next主题配置mermaid"><a class="markdownIt-Anchor" href="#2-hexo中next主题配置mermaid"></a> 2. Hexo中Next主题配置Mermaid</h1>
<p>升级Hexo到V6.x, 升级NexT版本到V8.11.0后，无需通过安装插件使用，只需修改NexT配置文件，修改Hexo配置文件即可。</p>
<p><big><strong><a href="https://theme-next.js.org/docs/tag-plugins/mermaid.html">参考链接</a></strong></big></p>
<ul>
<li>
<p><big><strong>步骤一：</strong></big>修改next主题配置文件_config.xml，只需mermaid的值由<code>false -&gt; true</code>即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Mermaid tag</span><br><span class="line">mermaid:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available themes: default | dark | forest | neutral</span><br><span class="line">  theme:</span><br><span class="line">    light: default</span><br><span class="line">    dark: dark</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><big><strong>步骤二：</strong></big>修改hexo的配置文件_config.xml，找到highlight，<strong>手动添加</strong>内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  exclude_languages:</span><br><span class="line">    - mermaid</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><big><strong>步骤三：</strong></big>执行<code>hexo cl</code>和<code>hexo g</code>命令行重新生成页面即可。</p>
</li>
</ul>
<h1 id="3-mermaid画图效果演示"><a class="markdownIt-Anchor" href="#3-mermaid画图效果演示"></a> 3. Mermaid画图效果演示</h1>
<p>[简单教程（非官方）](<a href="https://zhuanlan.zhihu.com/p/355997933">Mermaid从入门到入土——Markdown进阶语法 - 知乎 (zhihu.com)</a>)</p>
<ul>
<li>
<p>朱元璋家谱简图，圆圈代表皇帝</p>
<pre><code class="highlight mermaid">graph LR
emperor((朱八八))-.子.-&gt;朱五四-.子.-&gt;朱四九-.子.-&gt;朱百六


朱雄英--长子--&gt;朱标--长子--&gt;emperor
emperor2((朱允炆))--次子--&gt;朱标
朱樉--次子--&gt;emperor
朱棡--三子--&gt;emperor
emperor3((朱棣))--四子--&gt;emperor
emperor4((朱高炽))--长子--&gt;emperor3</code></pre>
</li>
<li>
<p>饼状图</p>
<pre><code class="highlight mermaid">pie
    title 为什么总是宅在家里？
    &quot;喜欢宅&quot; : 15
    &quot;天气太热或太冷&quot; : 20
    &quot;穷&quot; : 500</code></pre>
</li>
<li>
<p>流程图</p>
<pre><code class="highlight mermaid">graph LR
    A[Start] --&gt; B&#123;Is it?&#125;;
    B -- Yes --&gt; C[OK];
    C --&gt; D[Rethink];
    D --&gt; B;
    B -- No ----&gt; E[End];</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>markdown画图</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis练习</title>
    <url>/2023/11/28/Mybatis%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="mybatis练习"><a class="markdownIt-Anchor" href="#mybatis练习"></a> Mybatis练习</h2>
<p><strong>目标</strong></p>
<blockquote>
<ul>
<li>能够使用映射配置文件实现CRUD操作</li>
<li>能够使用注解实现CRUD操作</li>
</ul>
</blockquote>
<h2 id="1-配置文件实现crud"><a class="markdownIt-Anchor" href="#1-配置文件实现crud"></a> 1. 配置文件实现CRUD</h2>
<p>一般项目里面包含了品牌数据的 <code>查询</code> 、<code>按条件查询</code>、<code>添加</code>、<code>删除</code>、<code>批量删除</code>、<code>修改</code> 等功能，而这些功能其实就是对数据库表中的数据进行CRUD操作。接下来我们就使用Mybatis完成品牌数据的增删改查操作。以下是我们要完成功能列表：</p>
<blockquote>
<ul>
<li>查询
<ul>
<li>查询所有数据</li>
<li>查询详情</li>
<li>条件查询</li>
</ul>
</li>
<li>添加</li>
<li>修改
<ul>
<li>修改全部字段</li>
<li>修改动态字段</li>
</ul>
</li>
<li>删除
<ul>
<li>删除一个</li>
<li>批量删除</li>
</ul>
</li>
</ul>
</blockquote>
<p>我们先将必要的环境准备一下。</p>
<h3 id="11-环境准备"><a class="markdownIt-Anchor" href="#11-环境准备"></a> 1.1  环境准备</h3>
<ul>
<li>
<p>数据库表（tb_brand）及数据准备</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除tb_brand表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_brand;</span><br><span class="line"><span class="comment">-- 创建tb_brand表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_brand</span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- id 主键</span></span><br><span class="line">    id           <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    <span class="comment">-- 品牌名称</span></span><br><span class="line">    brand_name   <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="comment">-- 企业名称</span></span><br><span class="line">    company_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="comment">-- 排序字段</span></span><br><span class="line">    ordered      <span class="type">int</span>,</span><br><span class="line">    <span class="comment">-- 描述信息</span></span><br><span class="line">    description  <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="comment">-- 状态：0：禁用  1：启用</span></span><br><span class="line">    status       <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;三只松鼠&#x27;</span>, <span class="string">&#x27;三只松鼠股份有限公司&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;好吃不上火&#x27;</span>, <span class="number">0</span>),</span><br><span class="line">       (<span class="string">&#x27;华为&#x27;</span>, <span class="string">&#x27;华为技术有限公司&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">       (<span class="string">&#x27;小米&#x27;</span>, <span class="string">&#x27;小米科技有限公司&#x27;</span>, <span class="number">50</span>, <span class="string">&#x27;are you ok&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实体类 Brand</p>
<p>在 <code>com.itheima.pojo</code> 包下创建 Brand 实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    <span class="comment">// id 主键</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">// 品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String brandName;</span><br><span class="line">    <span class="comment">// 企业名称</span></span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="comment">// 排序字段</span></span><br><span class="line">    <span class="keyword">private</span> Integer ordered;</span><br><span class="line">    <span class="comment">// 描述信息</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// 状态：0：禁用  1：启用</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略 setter and getter... 自己写时要补全这部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编写测试用例</p>
<p>测试代码需要在 <code>test/java</code> 目录下创建包及测试用例。项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-demo</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       │   └── com</span><br><span class="line">│       │       └── itheima</span><br><span class="line">│       │           └── test</span><br><span class="line">│       │               └── MyBatisTest.java</span><br><span class="line">│       └── resources</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装 MyBatisX 插件</p>
<ul>
<li>
<p>MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。</p>
</li>
<li>
<p>主要功能</p>
<ul>
<li>XML映射配置文件 和 接口方法 间相互跳转</li>
<li>根据接口方法生成 statement ,即根据接口自动生成配置文件中的SQL语句</li>
</ul>
</li>
<li>
<p>安装方式</p>
<p>点击 <code>file</code> ，选择 <code>settings</code> ，点击<code>Plugins</code>,搜索<code>MybatisX</code> 安装,MybatisX 图标如下，是一只小鸟</p>
<img src="/img/mybatisx图标.png" />
<blockquote>
<p>注意：安装完毕后需要重启IDEA</p>
</blockquote>
</li>
<li>
<p>插件效果</p>
<img src="/img/mybatisx效果.png" style="zoom:70%;" />
<p>红色头绳的表示映射配置文件，蓝色头绳的表示mapper接口。在mapper接口点击红色头绳的小鸟图标会自动跳转到对应的映射配置文件，在映射配置文件中点击蓝色头绳的小鸟图标会自动跳转到对应的mapper接口。也可以在mapper接口中定义方法,**在爆红的地方使用<code>alt + 回车</code>，自动生成statement，自动生成映射配置文件中的 <code>statement</code> **，如图所示</p>
</li>
</ul>
</li>
</ul>
<h3 id="12-查询所有数据"><a class="markdownIt-Anchor" href="#12-查询所有数据"></a> 1.2  查询所有数据</h3>
<p>接下来我们就来讲查询所有数据功能，而实现该功能我们分以下步骤进行实现：</p>
<ul>
<li>
<p>编写接口方法：Mapper接口</p>
<ul>
<li>
<p>参数：无</p>
<p>查询所有数据功能是不需要根据任何条件进行查询的，所以此方法不需要参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结果：List<Brand></p>
<p>我们会将查询出来的每一条数据封装成一个 <code>Brand</code> 对象，而多条数据封装多个 <code>Brand</code> 对象，需要将这些对象封装到List集合中返回。</p>
</li>
<li>
<p>执行方法、测试</p>
</li>
</ul>
</li>
</ul>
<h4 id="121-编写接口方法"><a class="markdownIt-Anchor" href="#121-编写接口方法"></a> 1.2.1  编写接口方法</h4>
<p>在 <code>com.itheima.mapper</code> 包写创建名为 <code>BrandMapper</code> 的接口。并在该接口中定义 <code>List&lt;Brand&gt; selectAll()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BrandMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="122-编写sql语句"><a class="markdownIt-Anchor" href="#122-编写sql语句"></a> 1.2.2  编写SQL语句</h4>
<p>在 <code>reources</code> 下创建 <code>com/itheima/mapper</code> 目录结构，并在该目录下创建名为 <code>BrandMapper.xml</code> 的映射配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.BrandMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from tb_brand;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="123-编写测试方法"><a class="markdownIt-Anchor" href="#123-编写测试方法"></a> 1.2.3  编写测试方法</h4>
<p>在 <code>MybatisTest</code> 类中编写测试查询所有的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    List&lt;Brand&gt; brands = brandMapper.selectAll();</span><br><span class="line">    System.out.println(brands);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：现在我们感觉测试这部分代码写起来特别麻烦，我们可以先忍忍。以后我们只会写上面的第3步的代码，其他的都不需要我们来完成。</p>
</blockquote>
<p>执行测试方法结果如下，以下为<strong>日志输出：</strong> （其中注释是自己补的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[DEBUG] 12:19:32.403 [main] c.i.m.B.selectA11 - ==&gt; Preparing: select * from tb_brand;  // 执行的sql语句</span><br><span class="line">[DEBUG] 12:19:32.428 [main] c.i.m.B.selectAll - ==&gt; Parameters: </span><br><span class="line">[DEBUG] 12:19:32.446 [main] c.i.m.B.selectAll - ==&gt; Total: 3  // 查询到的结果</span><br><span class="line">[Brand&#123;id=1, brandName=&#x27;null&#x27;, companyName=&#x27;null&#x27;, ordered=5, description=&#x27;好吃不上火&#x27;, status=0&#125;, Brand&#123;id=2, brandName=&#x27;null&#x27;, companyName=&#x27;null&#x27;, ordered=10, description=&#x27;好喝不腻&#x27;, status=1&#125;]</span><br></pre></td></tr></table></figure>
<p>从上面结果我们看到了问题，有些数据封装成功了，而有些数据并没有封装成功。像id、ordered等封装成功，brandName和companyName就封装失败，为什么这样呢？</p>
<blockquote>
<p>实体类属性名 和 数据库表列名 不一致，不能自动封装数据</p>
<ul>
<li>**起别名：**在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样
<ul>
<li>可以定义 <sql>片段，提升复用性</li>
</ul>
</li>
<li>**resultMap：**定义<resultMap> 完成不一致的属性名和列名的映射</li>
</ul>
</blockquote>
<p>这个问题可以通过两种方式进行解决(<strong>第二个方法更常用</strong>)：</p>
<ul>
<li>给字段起别名</li>
<li><strong><big>使用resultMap定义字段和属性的映射关系</big></strong></li>
</ul>
<h4 id="124-起别名解决上述问题"><a class="markdownIt-Anchor" href="#124-起别名解决上述问题"></a> 1.2.4  起别名解决上述问题</h4>
<p>从上面结果可以看到 <code>brandName</code> 和 <code>companyName</code> 这两个属性的数据没有封装成功，查询 实体类 和 表中的字段 发现，在<strong>实体类中属性名</strong>是 <code>brandName</code> 和 <code>companyName</code> ，而<strong>表中的字段名</strong>为 <code>brand_name</code> 和 <code>company_name</code>。那么我们只需要保持这两部分的名称一致这个问题就迎刃而解。</p>
<p>我们可以在写sql语句时给这两个字段起别名，将别名定义成和属性名一致即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    id, brand_name as brandName, company_name as companyName, ordered, description, status</span><br><span class="line">    from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而上面的SQL语句中的字段列表书写麻烦，如果表中还有更多的字段，同时其他的功能也需要查询这些字段时就显得我们的代码不够精炼。Mybatis提供了<code>sql</code> 片段可以提高sql的复用性。</p>
<p><strong>SQL片段：</strong></p>
<ul>
<li>
<p>将需要复用的SQL片段抽取到 <code>sql</code> 标签中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;brand_column&quot;</span>&gt;</span></span><br><span class="line">	id, brand_name as brandName, company_name as companyName, ordered, description, status</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>id属性值是唯一标识，引用时也是通过该值进行引用。</p>
</li>
<li>
<p>在原sql语句中进行引用</p>
<p>使用 <code>include</code> 标签引用上述的 SQL 片段，而 <code>refid</code> 指定上述 SQL 片段的id值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;brand_column&quot;</span> /&gt;</span></span><br><span class="line">    from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="125-推荐-使用resultmap解决上述问题"><a class="markdownIt-Anchor" href="#125-推荐-使用resultmap解决上述问题"></a> 1.2.5 （推荐） 使用resultMap解决上述问题</h4>
<p>起别名 + sql片段的方式可以解决上述问题，但是它也存在问题。如果还有功能只需要查询部分字段，而不是查询所有字段，那么我们就需要再定义一个 SQL 片段，这就显得不是那么灵活。</p>
<p>那么我们也可以使用<code>resultMap</code>来定义字段和属性的映射关系的方式解决上述问题。</p>
<ul>
<li>
<p>在映射配置文件中使用resultMap定义 字段 和 属性 的映射关系</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// id:唯一标识    type：映射的类型，支持别名,映射结果的 Java 类型，这里是 brand 类型。</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            id：完成主键字段的映射</span></span><br><span class="line"><span class="comment">                column：表的列名</span></span><br><span class="line"><span class="comment">                property：实体类的属性名</span></span><br><span class="line"><span class="comment">            result：完成一般字段的映射</span></span><br><span class="line"><span class="comment">                column：表的列名</span></span><br><span class="line"><span class="comment">                property：实体类的属性名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在上面只需要定义 字段名 和 属性名 不一样的映射，而一样的则不需要专门定义出来。</p>
</blockquote>
</li>
<li>
<p>SQL语句正常编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="126-小结"><a class="markdownIt-Anchor" href="#126-小结"></a> 1.2.6  小结</h4>
<p>实体类属性名 和 数据库表列名 不一致，不能自动封装数据</p>
<ul>
<li>**起别名：**在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样
<ul>
<li>可以定义 <sql>片段，提升复用性</li>
</ul>
</li>
<li>**resultMap：**定义<resultMap> 完成不一致的属性名和列名的映射</li>
</ul>
<p><big><strong>而我们最终选择使用 resultMap的方式。</strong></big>查询映射配置文件中查询所有的 statement 书写如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            id：完成主键字段的映射</span></span><br><span class="line"><span class="comment">                column：表的列名</span></span><br><span class="line"><span class="comment">                property：实体类的属性名</span></span><br><span class="line"><span class="comment">            result：完成一般字段的映射</span></span><br><span class="line"><span class="comment">                column：表的列名</span></span><br><span class="line"><span class="comment">                property：实体类的属性名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="13-查询详情"><a class="markdownIt-Anchor" href="#13-查询详情"></a> 1.3  查询详情</h3>
<p>有些数据的属性比较多，在页面表格中无法全部实现，而只会显示部分，而其他属性数据的查询可以通过 <code>查看详情</code> 来进行查询。</p>
<p>查看详情功能实现步骤：</p>
<ul>
<li>
<p>编写接口方法：Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Brand <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>参数：id</p>
<p>查看详情就是查询某一行数据，所以需要根据id进行查询。而id以后是由页面传递过来。</p>
</li>
<li>
<p>结果：Brand</p>
<p>根据id查询出来的数据只要一条，而将一条数据封装成一个Brand对象即可</p>
</li>
</ul>
</li>
<li>
<p>编写SQL语句：SQL映射文件，以下代码中的parameterType可以省略</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByld&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">	select &quot;from tb_brand where id =#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>执行方法、进行测试</p>
</li>
</ul>
<h4 id="131-编写接口方法"><a class="markdownIt-Anchor" href="#131-编写接口方法"></a> 1.3.1  编写接口方法</h4>
<p>在 <code>BrandMapper</code> 接口中定义根据id查询数据的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查看详情：根据Id查询</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">Brand <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="132-编写sql语句"><a class="markdownIt-Anchor" href="#132-编写sql语句"></a> 1.3.2  编写SQL语句</h4>
<p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：上述SQL中的参数 #{id}先这样写，一会我们再详细讲解</p>
</blockquote>
<h4 id="133-编写测试方法"><a class="markdownIt-Anchor" href="#133-编写测试方法"></a> 1.3.3  编写测试方法</h4>
<p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数，该id以后需要传递过来</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> brandMapper.selectById(id);</span><br><span class="line">    System.out.println(brand);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行测试方法结果的部分日志信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BUG] 15:51:35.400 [main] c.i.m.B.selectById -==&gt; Preparing: select * from tb_brand where id = ?;  //SQL语句</span><br><span class="line">[BUG] 15:51:35.437 [main] c.i.m.B.selectById -==&gt; Parameters: 1(Integer) // 传递的参数值</span><br><span class="line">[BUG] 15:51:35.460 [main] c.i.m.B.selectById - ==&gt; Brand&#123;id=1, brandName=&#x27;三只松鼠&#x27;，companyName=&#x27;三只松鼠股份有限公司&#x27;，ordered=5, description=&#x27;好吃不上火&#x27;，status=0&#125; // 查询到的结构</span><br></pre></td></tr></table></figure>
<h4 id="134-参数占位符"><a class="markdownIt-Anchor" href="#134-参数占位符"></a> 1.3.4  参数占位符</h4>
<p>查询到的结果很好理解就是id为1的这行数据。而这里我们需要看控制台显示的SQL语句，能看到使用？进行占位。说明我们在映射配置文件中的写的 <code>#&#123;id&#125;</code> 最终会被 ？进行占位。接下来我们就聊聊映射配置文件中的参数占位符。</p>
<p>mybatis提供了两种参数占位符，<big><strong>主要使用第一个<code>#&#123;&#125;</code>：</strong></big></p>
<ul>
<li>
<p>#{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。从上述例子可以看出使用#{} 底层使用的是 <code>PreparedStatement</code></p>
</li>
<li>
<p>${} ：拼接SQL。底层使用的是 <code>Statement</code>，会存在SQL注入问题。如下图将 映射配置文件中的 #{} 替换成 ${} 来看效果</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand where id = $&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重新运行查看结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BUG] 15:51:35.400 [main] c.i.m.B.selectById -==&gt; Preparing: select * from tb_brand where id = 1;  //直接将数据拼接到SQL语句中</span><br><span class="line">[BUG] 15:51:35.437 [main] c.i.m.B.selectById -==&gt; Parameters: 1(Integer) // 传递的参数值</span><br><span class="line">[BUG] 15:51:35.460 [main] c.i.m.B.selectById - ==&gt; Brand&#123;id=1, brandName=&#x27;三只松鼠&#x27;，companyName=&#x27;三只松鼠股份有限公司&#x27;，ordered=5, description=&#x27;好吃不上火&#x27;，status=0&#125; // 查询到的结构</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>注意：从上面两个例子可以看出，以后开发我们使用 #{} 参数占位符</strong></p>
</blockquote>
<h4 id="135-parametertype使用"><a class="markdownIt-Anchor" href="#135-parametertype使用"></a> 1.3.5  parameterType使用</h4>
<p>对于有参数的mapper接口方法，我们在映射配置文件中应该配置 <code>ParameterType</code> 来指定参数类型。只不过<strong>该属性都可以省略</strong>。如下图：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand where id = $&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="136-sql语句中特殊字段处理"><a class="markdownIt-Anchor" href="#136-sql语句中特殊字段处理"></a> 1.3.6  SQL语句中特殊字段处理</h4>
<p>以后肯定会在SQL语句中写一下特殊字符，比如某一个字段大于某个值，如下图</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">	    where id &lt; #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在IDEA中可以看出报错了，因为映射配置文件是xml类型的问题，而 &gt; &lt; 等这些字符在xml中有特殊含义，所以此时我们需要将这些符号进行转义，可以使用以下两种方式进行转义</p>
<ul>
<li>
<p>转义字符</p>
<p>下图的 <code>&amp;lt;</code> 就是 <code>&lt;</code> 的转义字符。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">	    where id <span class="symbol">&amp;lt;</span> #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<![CDATA[内容]]>，直接输入大写的`CD`会有自动提示
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span> </span><br><span class="line">    select * </span><br><span class="line">    from tb_brand </span><br><span class="line">    where id </span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">		&lt;</span><br><span class="line">	]]&gt; </span><br><span class="line">    #&#123;id&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="14-多条件查询"><a class="markdownIt-Anchor" href="#14-多条件查询"></a> 1.4  多条件查询</h3>
<p>我们经常会遇到多条件查询,像是同时通过企业名称和品牌名称来查询，而我们做这个功能需要分析最终的SQL语句应该是什么样，思考两个问题</p>
<ul>
<li>条件表达式</li>
<li>如何连接</li>
</ul>
<p>条件字段 <code>企业名称</code>  和 <code>品牌名称</code> 需要进行模糊查询，所以条件应该是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> status <span class="operator">=</span> ? <span class="keyword">and</span> company_name <span class="keyword">like</span> ? <span class="keyword">and</span> brand_name <span class="keyword">like</span> ?;</span><br></pre></td></tr></table></figure>
<p>简单的分析后，我们来看功能实现的步骤：</p>
<ul>
<li>
<ol>
<li>
<p>编写接口方法</p>
<ul>
<li>
<p>参数：所有查询条件</p>
</li>
<li>
<p>结果：List<Brand></p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<ol start="2">
<li>在映射配置文件中编写SQL语句</li>
</ol>
</li>
<li>
<ol start="3">
<li>编写测试方法并执行</li>
</ol>
</li>
</ul>
<h4 id="141-编写接口方法"><a class="markdownIt-Anchor" href="#141-编写接口方法"></a> 1.4.1  编写接口方法</h4>
<p>在 <code>BrandMapper</code> 接口中定义多条件查询的方法。</p>
<p>而该功能有三个参数，我们就需要考虑定义接口时，参数应该如何定义。Mybatis针对多参数有多种实现</p>
<ul>
<li>
<p>使用 <code>@Param(&quot;参数名称&quot;)</code> 标记每一个参数，在映射配置文件中就需要使用 <code>#&#123;参数名称&#125;</code> 进行占位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(<span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status, <span class="meta">@Param(&quot;companyName&quot;)</span> String companyName,<span class="meta">@Param(&quot;brandName&quot;)</span> String brandName)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的内容必须和实体类属性名保持一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的内容必须和map集合中键的名称一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; selectByCondition(Map map);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="142-编写sql语句"><a class="markdownIt-Anchor" href="#142-编写sql语句"></a> 1.4.2  编写SQL语句</h4>
<p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where status = #&#123;status&#125;</span><br><span class="line">    and company_name like #&#123;companyName&#125;</span><br><span class="line">    and brand_name like #&#123;brandName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="143-编写测试方法"><a class="markdownIt-Anchor" href="#143-编写测试方法"></a> 1.4.3  编写测试方法</h4>
<p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByCondition</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理参数,模糊查询语句 SELECT * FROM your_table WHERE your_column LIKE &#x27;%华为%&#x27;;</span></span><br><span class="line">    companyName = <span class="string">&quot;%&quot;</span> + companyName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    brandName = <span class="string">&quot;%&quot;</span> + brandName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">	<span class="comment">//方式一 ：接口方法参数使用 @Param 方式调用的方法</span></span><br><span class="line">    <span class="comment">//List&lt;Brand&gt; brands = brandMapper.selectByCondition(status, companyName, brandName);</span></span><br><span class="line">    <span class="comment">//方式二 ：接口方法参数是 实体类对象 方式调用的方法</span></span><br><span class="line">     <span class="comment">//封装对象</span></span><br><span class="line">    <span class="comment">/* Brand brand = new Brand();</span></span><br><span class="line"><span class="comment">        brand.setStatus(status);</span></span><br><span class="line"><span class="comment">        brand.setCompanyName(companyName);</span></span><br><span class="line"><span class="comment">        brand.setBrandName(brandName);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//List&lt;Brand&gt; brands = brandMapper.selectByCondition(brand);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式三 ：接口方法参数是 map集合对象 方式调用的方法</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;status&quot;</span> , status);</span><br><span class="line">    map.put(<span class="string">&quot;companyName&quot;</span>, companyName);</span><br><span class="line">    map.put(<span class="string">&quot;brandName&quot;</span> , brandName);</span><br><span class="line">    List&lt;Brand&gt; brands = brandMapper.selectByCondition(map);</span><br><span class="line">    System.out.println(brands);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="144-动态sql"><a class="markdownIt-Anchor" href="#144-动态sql"></a> 1.4.4  动态SQL</h4>
<p>上述功能实现存在很大的问题。用户在输入条件时，肯定不会所有的条件都填写，这个时候我们的SQL语句就不能那样写的</p>
<p>例如用户只输入 当前状态 时，SQL语句就是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> status <span class="operator">=</span> #&#123;status&#125;</span><br></pre></td></tr></table></figure>
<p>而用户如果只输入企业名称时，SQL语句就是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> company_name <span class="keyword">like</span> #&#123;companName&#125;</span><br></pre></td></tr></table></figure>
<p>而用户如果输入了 <code>当前状态</code> 和 <code>企业名称</code> 时，SQL语句又不一样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> status <span class="operator">=</span> #&#123;status&#125; <span class="keyword">and</span> company_name <span class="keyword">like</span> #&#123;companName&#125;</span><br></pre></td></tr></table></figure>
<p>针对上述的需要，Mybatis对动态SQL有很强大的支撑，可以使用if等语句决定哪些部分需要和不需要：</p>
<blockquote>
<ul>
<li>
<p>if</p>
</li>
<li>
<p>choose (when, otherwise)</p>
</li>
<li>
<p>trim (where, set)</p>
</li>
<li>
<p>foreach</p>
</li>
</ul>
</blockquote>
<p>我们先学习 if 标签和 where 标签：</p>
<ul>
<li>
<p>if 标签：条件判断</p>
<ul>
<li>test 属性：逻辑表达式</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            status = #&#123;status&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and company_name like #&#123;companyName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and brand_name like #&#123;brandName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上的这种SQL语句就会根据传递的参数值进行动态的拼接。如果此时status和companyName有值那么就会值拼接这两个条件。</p>
<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//日志输出</span><br><span class="line"></span><br><span class="line">selectByCondition -==&gt; Preparing: select from tb_brand where status = ? and company_name like ?</span><br><span class="line">selectBycondition -==&gt; Parameters: 1 (Integer), %华为%(String)</span><br><span class="line">selectByCondition -==&gt; 	Total: 1</span><br></pre></td></tr></table></figure>
<p>但是它也存在问题，如果此时给的参数值是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">// map.put(&quot;status&quot; , status);</span></span><br><span class="line">map.put(<span class="string">&quot;companyName&quot;</span>, companyName);</span><br><span class="line">map.put(<span class="string">&quot;brandName&quot;</span> , brandName);</span><br></pre></td></tr></table></figure>
<p>拼接的SQL语句就变成了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> <span class="keyword">and</span> company_name <span class="keyword">like</span> ? <span class="keyword">and</span> brand_name <span class="keyword">like</span> ?</span><br></pre></td></tr></table></figure>
<p>而上面的语句中 where 关键后直接跟 and 关键字，这就是一条错误的SQL语句。这个就可以使用 where 标签解决</p>
</li>
<li>
<p>where 标签</p>
<ul>
<li>作用：
<ul>
<li>替换where关键字</li>
<li>会动态的去掉第一个条件前的 and</li>
<li><big><strong>如果所有的参数没有值则不加where关键字</strong></big></li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            and status = #&#123;status&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and company_name like #&#123;companyName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and brand_name like #&#123;brandName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><big><strong>注意：需要给每个条件前都加上 and 关键字。</strong></big></p>
</blockquote>
</li>
</ul>
<h3 id="15-单个条件动态sql"><a class="markdownIt-Anchor" href="#15-单个条件动态sql"></a> 1.5 单个条件（动态SQL）</h3>
<p>若在查询时只能选择 <code>品牌名称</code>、<code>当前状态</code>、<code>企业名称</code> 这三个条件中的一个，但是用户到底选择哪儿一个，我们并不能确定。这种就属于单个条件的动态SQL语句。</p>
<p>这种需求需要使用到  <code>choose（when，otherwise）标签</code>  实现，  而 <code>choose</code> 标签类似于Java 中的switch语句，对应<code>switch(case, default)</code>。</p>
<p>通过一个案例来使用这些标签</p>
<h4 id="151-编写接口方法"><a class="markdownIt-Anchor" href="#151-编写接口方法"></a> 1.5.1  编写接口方法</h4>
<p>在 <code>BrandMapper</code> 接口中定义单条件查询的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 单条件动态查询</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> brand</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">List&lt;Brand&gt; <span class="title function_">selectByConditionSingle</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="152-编写sql语句"><a class="markdownIt-Anchor" href="#152-编写sql语句"></a> 1.5.2  编写SQL语句</h4>
<p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByConditionSingle&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span><span class="comment">&lt;!--相当于switch--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span><span class="comment">&lt;!--相当于case--&gt;</span></span><br><span class="line">                status = #&#123;status&#125; //此时前面不用加 and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span><span class="comment">&lt;!--相当于case--&gt;</span></span><br><span class="line">                company_name like #&#123;companyName&#125; //此时前面不用加 and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span><span class="comment">&lt;!--相当于case--&gt;</span></span><br><span class="line">                brand_name like #&#123;brandName&#125; //此时前面不用加 and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="153-编写测试方法"><a class="markdownIt-Anchor" href="#153-编写测试方法"></a> 1.5.3  编写测试方法</h4>
<p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByConditionSingle</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理参数</span></span><br><span class="line">    companyName = <span class="string">&quot;%&quot;</span> + companyName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    brandName = <span class="string">&quot;%&quot;</span> + brandName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装对象</span></span><br><span class="line">    <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">    <span class="comment">//brand.setStatus(status);</span></span><br><span class="line">    brand.setCompanyName(companyName);</span><br><span class="line">    <span class="comment">//brand.setBrandName(brandName);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    List&lt;Brand&gt; brands = brandMapper.selectByConditionSingle(brand);</span><br><span class="line">    System.out.println(brands);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行测试方法结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 日志信息</span><br><span class="line"></span><br><span class="line">[DEBUG] 21:14:55.483 [main] c.i.m.B.selectByConditionsingle -==&gt; Preparing: select * from tb_brand WHERE company_name like ?</span><br><span class="line">[DEBUG] 21:14:55.540 [main] c.i.m.B.selectByConditionsingle -==&gt; Parameters: %华为(String)</span><br><span class="line">[DEBUG] 21:14:55.579 [main] c.i.m.B.selectByConditionsingle -==&gt; 	Total: 1</span><br></pre></td></tr></table></figure>
<h3 id="16-添加数据"><a class="markdownIt-Anchor" href="#16-添加数据"></a> 1.6  添加数据</h3>
<p>我们平时在添加数据时在页面输入想要的数据后添加 <code>提交</code> 按钮，就会将这些数据添加到数据库中。接下来我们就来实现添加数据的操作，暂不需要返回值，后续通过异常判定解决。</p>
<ul>
<li>
<p>编写接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure>
<p>参数：除了id之外的所有的数据。id对应的是表中主键值，而主键我们是 <strong>自动增长</strong> 生成的。</p>
</li>
<li>
<p>编写SQL语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编写测试方法并执行</p>
</li>
</ul>
<p>明确了该功能实现的步骤后，接下来我们进行具体的操作。</p>
<h4 id="161-编写接口方法"><a class="markdownIt-Anchor" href="#161-编写接口方法"></a> 1.6.1  编写接口方法</h4>
<p>在 <code>BrandMapper</code> 接口中定义添加方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="162-编写sql语句"><a class="markdownIt-Anchor" href="#162-编写sql语句"></a> 1.6.2  编写SQL语句</h4>
<p>在 <code>BrandMapper.xml</code> 映射配置文件中编写添加数据的 <code>statement</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="163-编写测试方法"><a class="markdownIt-Anchor" href="#163-编写测试方法"></a> 1.6.3  编写测试方法</h4>
<p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;波导手机&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;波导&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;手机中的战斗机&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ordered</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装对象</span></span><br><span class="line">    <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">    brand.setStatus(status);</span><br><span class="line">    brand.setCompanyName(companyName);</span><br><span class="line">    brand.setBrandName(brandName);</span><br><span class="line">    brand.setDescription(description);</span><br><span class="line">    brand.setOrdered(ordered);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true); //设置自动提交事务，这种情况不需要手动提交事务了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    brandMapper.add(brand);</span><br><span class="line">    <span class="comment">//提交事务，要手动提交，不提交的话会导致在日志中显示添加成功但是在数据库中却没有，因为发生了事务回滚</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未提交事务前（未更新到数据库，发生了回滚）：</p>
<blockquote>
<p>// 日志信息如下：</p>
<p>[DEBUG] 21:55:56.100 [main] o.a.i.t.j.JdbcTransaction- <strong><big>Setting autocommit to false</big></strong> on JDBC Connection<br />
[DEBUG] 21:55:56.105 [main] c.i.m.B.add -<mark>&gt; Preparing: insert into tb_brand (brand_name, company_name, ordered, description, status) values (?, ?, ?, ?, ?)<br />
[DEBUG] 21:55:56.110 [main] c.i.m.B.add -</mark>&gt; Parameters: 波导 (String), 波导手机 (String), 1 (Integer), 手机中的战斗机 (String), 1 (Integer)<br />
[DEBUG] 21:55:56.115 [main] c.i.m.B.add -&lt;== Updates: 1<br />
[DEBUG] 21:55:56.120 [main] o.a.i.t.j.JdbcTransaction - <strong><big>Rolling back JDBC Connection </big></strong></p>
</blockquote>
<p>提交事务后，执行结果如下（数据库更新成功）：</p>
<blockquote>
<p>// 日志信息如下：</p>
<p>[DEBUG] 21:55:56.110 [main] o.a.i.t.j.JdbcTransaction- <strong><big>Setting autocommit to false</big></strong> on JDBC Connection<br />
[DEBUG] 21:55:56.115 [main] c.i.m.B.add -<mark>&gt; Preparing: insert into tb_brand (brand_name, company_name, ordered, description, status) values (?, ?, ?, ?, ?)<br />
[DEBUG] 21:55:56.120 [main] c.i.m.B.add -</mark>&gt; Parameters: 波导 (String), 波导手机 (String), 1 (Integer), 手机中的战斗机 (String), 1 (Integer)<br />
[DEBUG] 21:55:56.125 [main] c.i.m.B.add -&lt;== Updates: 1<br />
[DEBUG] 21:55:56.130 [main] o.a.i.t.j.JdbcTransaction - <strong><big>Committing JDBC Connection </big></strong></p>
</blockquote>
<ul>
<li>MyBatis事务：
<ul>
<li>openSession():默认开启事务，进行增删改操作后需要使用sqlSession.commit();手动提交事务</li>
<li>openSession(true):可以设置为自动提交事务（关闭事务）</li>
</ul>
</li>
</ul>
<h4 id="164-添加-主键返回"><a class="markdownIt-Anchor" href="#164-添加-主键返回"></a> 1.6.4  添加-主键返回</h4>
<p>在数据添加成功后，有时候需要获取插入数据库数据的主键（主键是自增长）。</p>
<p>比如：添加订单和订单项，以下就是一个订单和订单项的例子：</p>
<p><strong>订单数据存储在订单表中，订单项存储在订单项表中。</strong></p>
<blockquote>
<p>好的，我给你一个具体的例子来说明订单和订单项的关系以及返回主键的目的。</p>
<p>假设我们有两个表：订单表（orders）和订单项表（order_items）。</p>
<p>订单表包含以下字段：</p>
<ul>
<li>order_id (主键)</li>
<li>customer_id</li>
<li>order_date</li>
<li>total_amount</li>
</ul>
<p>订单项表包含以下字段：</p>
<ul>
<li>item_id (主键)</li>
<li>order_id (外键，与订单表的order_id关联)</li>
<li>product_id</li>
<li>quantity</li>
<li>price</li>
</ul>
<p>现在我们要添加一笔新的订单，并且需要添加多个订单项。</p>
<ol>
<li>
<p>向订单表中添加订单记录：<br />
假设我们添加了一条订单记录，订单号为&quot;20231127001&quot;，顾客ID为&quot;1001&quot;，订单日期为&quot;2023-11-27&quot;，总金额为&quot;5000元&quot;。数据库会为该订单生成一个唯一的订单主键(order_id)。</p>
</li>
<li>
<p>向订单项表中添加订单项记录：<br />
接下来，我们需要为该订单添加多个订单项。假设订单项1的商品ID为&quot;001&quot;，数量为&quot;2&quot;，价格为&quot;100元&quot;；订单项2的商品ID为&quot;002&quot;，数量为&quot;3&quot;，价格为&quot;200元&quot;。在添加每个订单项时，我们会使用刚刚生成的订单主键(order_id)作为外键与订单表进行关联。</p>
</li>
<li>
<p>返回主键的作用：<br />
通过返回的订单主键(order_id)，我们可以在订单项表中建立订单和订单项之间的关联。每个订单项的记录中都会包含与特定订单关联的订单主键(order_id)。</p>
</li>
</ol>
<p>例如，订单项表中的记录可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">item_id     order_id     product_id     quantity     price</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">1           20231127001  001            2            100元</span><br><span class="line">2           20231127001  002            3            200元</span><br></pre></td></tr></table></figure>
<p>通过订单主键(order_id)，我们可以轻松地查询特定订单的所有订单项，进行数据的管理和操作。</p>
<p>这就是在订单和订单项中返回主键的具体例子，主键的作用是建立关联、方便查询和管理数据。希望这个例子能够帮助你理解。如果还有其他问题，请随时提问。</p>
</blockquote>
<p>明白了什么时候 <code>主键返回</code> 。接下来我们简单模拟一下，在添加完数据后打印id属性值，能打印出来说明已经获取到了。</p>
<p>我们将上面添加品牌数据的案例中映射配置文件里 <code>statement</code> 进行修改，如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 insert 标签上添加如下属性：</p>
<ul>
<li>useGeneratedKeys：是够获取自动增长的主键值。true表示获取</li>
<li>keyProperty  ：指定将获取到的主键值封装到哪儿个属性里</li>
</ul>
</blockquote>
<p>我们用以下代码检验有没有获得主键：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">brandMapper.add(brand);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> brand.getId();</span><br><span class="line">System.out.println(id);</span><br></pre></td></tr></table></figure>
<ul>
<li>当没有在 insert 标签上添加属性时，执行结果返回 <code>null</code></li>
<li>当在 insert 标签上添加属性时，执行结果返回 <code>主键</code></li>
</ul>
<h3 id="17-修改"><a class="markdownIt-Anchor" href="#17-修改"></a> 1.7  修改</h3>
<p>在修改页面中，用户在该页面书写需要修改的数据，点击 <code>提交</code> 按钮，就会将数据库中对应的数据进行修改。注意一点，如果哪儿个输入框没有输入内容，我们是将表中数据对应字段值替换为空白还是保留字段之前的值？答案肯定是保留之前的数据。</p>
<p>接下来我们就具体来实现</p>
<h4 id="171-编写接口方法"><a class="markdownIt-Anchor" href="#171-编写接口方法"></a> 1.7.1  编写接口方法</h4>
<p>在 <code>BrandMapper</code> 接口中定义修改方法，返回结果void和int都可，int表示修改的行数，void会在后面用异常处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 修改</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Brand brand)</span>; <span class="comment">//返回结果void和int都可，int表示修改的行数，void会在后面用异常处理。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述方法参数 Brand 就是封装了需要修改的数据，而id肯定是有数据的，这也是和添加方法的区别。</p>
</blockquote>
<h4 id="172-编写sql语句"><a class="markdownIt-Anchor" href="#172-编写sql语句"></a> 1.7.2  编写SQL语句</h4>
<p>在 <code>BrandMapper.xml</code> 映射配置文件中编写修改数据的 <code>statement</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">    update tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            brand_name = #&#123;brandName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            company_name = #&#123;companyName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ordered != null&quot;</span>&gt;</span></span><br><span class="line">            ordered = #&#123;ordered&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;description != null and description != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            description = #&#123;description&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            status = #&#123;status&#125;   // 注意最后一个没有逗号</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>set</em> 标签可以用于动态包含需要更新的列，忽略其它不更新的列，还可解决if语句中逗号的问题。</p>
</blockquote>
<h4 id="173-编写测试方法"><a class="markdownIt-Anchor" href="#173-编写测试方法"></a> 1.7.3  编写测试方法</h4>
<p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;波导手机&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;波导&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;波导手机,手机中的战斗机&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ordered</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装对象</span></span><br><span class="line">    <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">    brand.setStatus(status);</span><br><span class="line">    <span class="comment">//        brand.setCompanyName(companyName);</span></span><br><span class="line">    <span class="comment">//        brand.setBrandName(brandName);</span></span><br><span class="line">    <span class="comment">//        brand.setDescription(description);</span></span><br><span class="line">    <span class="comment">//        brand.setOrdered(ordered);</span></span><br><span class="line">    brand.setId(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> brandMapper.update(brand);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行测试方法结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[DEBUG] main c.i.m.B.update -==&gt; Preparing: update tb_brand SET status = ? where id = ?</span><br><span class="line">[DEBUG] main c.i.m.B.update -==&gt; Parameters: 5 (Integer), 1 (Integer)</span><br><span class="line">[DEBUG] main c.i.m.B.update -==&gt; 	Updates: 1</span><br></pre></td></tr></table></figure>
<p>从结果中SQL语句可以看出，只修改了 <code>status</code>  字段值，因为我们给的数据中只给Brand实体对象的 <code>status</code> 属性设置值了。这就是 <code>set</code> 标签的作用。</p>
<h3 id="18-删除一行数据"><a class="markdownIt-Anchor" href="#18-删除一行数据"></a> 1.8  删除一行数据</h3>
<p>后台管理中一般每行数据后面都有一个 <code>删除</code> 按钮，当用户点击了该按钮，就会将改行数据删除掉。那我们就需要思考，这种删除是根据什么进行删除呢？是通过主键id删除，因为id是表中数据的唯一标识。</p>
<p>接下来就来实现该功能。</p>
<h4 id="181-编写接口方法"><a class="markdownIt-Anchor" href="#181-编写接口方法"></a> 1.8.1  编写接口方法</h4>
<p>在 <code>BrandMapper</code> 接口中定义根据id删除方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据id删除</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="182-编写sql语句"><a class="markdownIt-Anchor" href="#182-编写sql语句"></a> 1.8.2  编写SQL语句</h4>
<p>在 <code>BrandMapper.xml</code> 映射配置文件中编写删除一行数据的 <code>statement</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">    delete from tb_brand where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="183-编写测试方法"><a class="markdownIt-Anchor" href="#183-编写测试方法"></a> 1.8.3  编写测试方法</h4>
<p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    brandMapper.deleteById(id);</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行过程只要没报错，直接到数据库查询数据是否还存在。</p>
<h3 id="19-批量删除"><a class="markdownIt-Anchor" href="#19-批量删除"></a> 1.9  批量删除</h3>
<p>用户还可以选择多条数据，然后点击上面的 <code>删除</code> 按钮，就会删除数据库中对应的多行数据。</p>
<h4 id="191-编写接口方法"><a class="markdownIt-Anchor" href="#191-编写接口方法"></a> 1.9.1  编写接口方法</h4>
<p>在 <code>BrandMapper</code> 接口中定义删除多行数据的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 批量删除</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(<span class="type">int</span>[] ids)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数是一个数组，数组中存储的是多条数据的id</p>
</blockquote>
<h4 id="192-编写sql语句"><a class="markdownIt-Anchor" href="#192-编写sql语句"></a> 1.9.2  编写SQL语句</h4>
<p>在 <code>BrandMapper.xml</code> 映射配置文件中编写删除多条数据的 <code>statement</code>。</p>
<p>编写SQL时需要遍历数组来拼接SQL语句。Mybatis 提供了 <code>foreach</code> 标签供我们使用</p>
<p><strong>foreach 标签</strong></p>
<p>用来迭代任何可迭代的对象（如数组，集合）。</p>
<ul>
<li>collection 属性：
<ul>
<li>mybatis会将数组参数，封装为一个Map集合。
<ul>
<li>默认：如果是数组的话，键:“array” =  值: 对应的数组</li>
<li>使用@Param注解改变map集合的默认key的名称</li>
</ul>
</li>
</ul>
</li>
<li>item 属性：本次迭代获取到的元素。</li>
<li>separator 属性：集合项迭代之间的分隔符。<code>foreach</code> 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。</li>
<li>open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次，是左括号</li>
<li>close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次，是右括号</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;！--</span><br><span class="line">mybatis会将数组参数，封装为一个Map集合.</span><br><span class="line">*默认：如果是数组的话，键:&quot;array&quot; =  值:对应的数组</span><br><span class="line">*使用@Param注解改变map集合的默认key的名称</span><br><span class="line">     </span><br><span class="line">****当我们传递一个 List 实例或者数组Array作为参数对象传给 MyBatis。当你这么做的时候,MyBatis 会自动将它包装在一个 Map 中,用名称在作为键。List 实例将会以“list” 作为键,而数组实例将会以“array”作为键。所以，当我们传递的是一个Array集合时，mybatis会自动把我们的array集合包装成以array为Key值的map。</span><br><span class="line">--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete from tb_brand where id</span><br><span class="line">    in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    ;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>假如数组中的id数据是{1,2,3}，那么拼接后的sql语句就是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><big><strong>细节：</strong></big></p>
<blockquote>
<p>如果想要delete标签中collection的值为ids，就需要使用@Param注解，是<code>void deleteByIds(@Param(&quot;ids&quot;) int[] ids);</code></p>
</blockquote>
<h4 id="193-编写测试方法"><a class="markdownIt-Anchor" href="#193-编写测试方法"></a> 1.9.3  编写测试方法</h4>
<p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByIds</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span>[] ids = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    brandMapper.deleteByIds(ids);</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="110-mybatis参数传递"><a class="markdownIt-Anchor" href="#110-mybatis参数传递"></a> 1.10  Mybatis参数传递</h3>
<p><big><strong>建议：统一都使用@Param注解</strong></big></p>
<p>Mybatis 接口方法中可以接收各种各样的参数，如下：</p>
<ul>
<li>多个参数</li>
<li>单个参数：单个参数又可以是如下类型
<ul>
<li>POJO 类型（像我们自定义的User类和Brand类）</li>
<li>Map 集合类型</li>
<li>Collection 集合类型</li>
<li>List 集合类型</li>
<li>Array 类型</li>
<li>其他类型</li>
</ul>
</li>
</ul>
<h4 id="1101-多个参数"><a class="markdownIt-Anchor" href="#1101-多个参数"></a> 1.10.1  多个参数</h4>
<p>如下面的代码，就是接收两个参数，而接收多个参数需要使用 <code>@Param</code> 注解，那么为什么要加该注解呢？这个问题要弄明白就必须来研究Mybatis 底层对于这些参数是如何处理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username,<span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">	select *</span><br><span class="line">    from tb_user</span><br><span class="line">    where </span><br><span class="line">    	username=#&#123;username&#125;</span><br><span class="line">    	and password=#&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 <code>@Param</code> 注解时有以下命名规则：</p>
<ul>
<li>
<p>以 arg 开头  ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如：</p>
<blockquote>
<p>map.put(“arg0”，参数值1);</p>
<p>map.put(“arg1”，参数值2);</p>
</blockquote>
</li>
<li>
<p>以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如：</p>
<blockquote>
<p>map.put(“param1”，参数值1);</p>
<p>map.put(“param2”，参数值2);</p>
</blockquote>
</li>
</ul>
<ul>
<li>
<p><big><strong>注意：</strong></big><strong>arg0和param1都对应同一个参数值1，同样的，arg1和param2也都对应同一个参数值2</strong>,类似以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.put(&quot;arg0&quot;，&quot;zhangsan&quot;);</span><br><span class="line">map.put(&quot;arg1&quot;，&quot;123&quot;);</span><br><span class="line">map.put(&quot;param1&quot;，&quot;zhangsan&quot;);</span><br><span class="line">map.put(&quot;param2&quot;，&quot;123&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>代码验证：</strong></p>
<ul>
<li>
<p>在 <code>UserMapper</code> 接口中定义如下方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(String username,String password)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 <code>UserMapper.xml</code> 映射配置文件中定义SQL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">	select *</span><br><span class="line">    from tb_user</span><br><span class="line">    where </span><br><span class="line">    	username=#&#123;arg0&#125;</span><br><span class="line">    	and password=#&#123;arg1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">	select *</span><br><span class="line">    from tb_user</span><br><span class="line">    where </span><br><span class="line">    	username=#&#123;param1&#125;</span><br><span class="line">    	and password=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行代码结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[DEBUG] main c.i.m.B.select -==&gt; Preparing: select * from tb_user where username = ? and password = ?</span><br><span class="line">[DEBUG] main c.i.m.B.select -==&gt; Parameters: zhangsan(String), 123(String)</span><br><span class="line">[DEBUG] main c.i.m.B.select -==&gt; 	Total: 1</span><br></pre></td></tr></table></figure>
<p>在映射配合文件的SQL语句中使用用 <code>arg</code> 开头的和 <code>param</code> 书写，代码的可读性会变的特别差，此时可以使用 <code>@Param</code> 注解。</p>
</li>
</ul>
<p>在接口方法参数上使用 <code>@Param</code> 注解，Mybatis 会将 <code>arg</code> 开头的键名替换为对应注解的属性值。</p>
<p><strong>代码验证：</strong></p>
<ul>
<li>
<p>在 <code>UserMapper</code> 接口中定义如下方法，在 <code>username</code> 参数前加上 <code>@Param</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, String password)</span>;</span><br></pre></td></tr></table></figure>
<p>Mybatis 在封装 Map 集合时，键名就会变成如下：</p>
<blockquote>
<p>map.put(“username”，参数值1);</p>
<p>map.put(“arg1”，参数值2);</p>
<p>map.put(“param1”，参数值1);</p>
<p>map.put(“param2”，参数值2);</p>
</blockquote>
</li>
<li>
<p>在 <code>UserMapper.xml</code> 映射配置文件中定义SQL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">	select *</span><br><span class="line">    from tb_user</span><br><span class="line">    where </span><br><span class="line">    	username=#&#123;username&#125;</span><br><span class="line">    	and password=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行程序结果没有报错。而如果将 <code>#&#123;&#125;</code> 中的 <code>username</code> 还是写成  <code>arg0</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">	select *</span><br><span class="line">    from tb_user</span><br><span class="line">    where </span><br><span class="line">    	username=#&#123;arg0&#125;</span><br><span class="line">    	and password=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行程序则可以看到错误</p>
<blockquote>
<p>Parameter ‘arg0’ not found.Available parameters are [arg1,param1,username,param2]</p>
<p>// 意思是没有找到arg0这样的参数，参数名称变成了arg1,param1,username,param2</p>
</blockquote>
</li>
</ul>
<p><strong>结论：以后接口参数是多个时，在每个参数上都使用 <code>@Param</code> 注解。这样代码的可读性更高。</strong></p>
<h4 id="1102-单个参数"><a class="markdownIt-Anchor" href="#1102-单个参数"></a> 1.10.2  单个参数</h4>
<ul>
<li>
<p>POJO 类型</p>
<p>直接使用。要求 <code>属性名</code> 和 <code>参数占位符名称</code> 一致</p>
</li>
<li>
<p>Map 集合类型</p>
<p>直接使用。要求 <code>map集合的键名</code> 和 <code>参数占位符名称</code> 一致</p>
</li>
<li>
<p>Collection 集合类型</p>
<p>Mybatis 会将集合封装到 map 集合中，如下：</p>
<blockquote>
<p>map.put(“arg0”，collection集合);</p>
<p>map.put(“collection”，collection集合;</p>
<p>注意：此时两个不同键arg0和collection对应同一个值collections集合</p>
</blockquote>
<p><strong>可以使用 <code>@Param</code> 注解替换map集合中默认的 arg 键名。</strong></p>
</li>
<li>
<p>List 集合类型</p>
<p>Mybatis 会将集合封装到 map 集合中，如下：</p>
<blockquote>
<p>map.put(“arg0”，list集合);</p>
<p>map.put(“collection”，list集合);</p>
<p>map.put(“list”，list集合);</p>
<p>注意：此时三个键对应的都是同一个list集合</p>
</blockquote>
<p><strong>可以使用 <code>@Param</code> 注解替换map集合中默认的 arg 键名。</strong></p>
</li>
<li>
<p>Array 类型</p>
<p>Mybatis 会将集合封装到 map 集合中，如下：</p>
<blockquote>
<p>map.put(“arg0”，数组);</p>
<p>map.put(“array”，数组);</p>
<p>注意：此时两个键对应同一个数组</p>
</blockquote>
<p><strong>可以使用 <code>@Param</code> 注解替换map集合中默认的 arg 键名。</strong></p>
</li>
<li>
<p>其他类型</p>
<p>比如int类型，<code>参数占位符名称</code> 叫什么都可以。尽量做到见名知意</p>
</li>
</ul>
<h2 id="2注解实现crud不推荐"><a class="markdownIt-Anchor" href="#2注解实现crud不推荐"></a> 2，注解实现CRUD（不推荐）</h2>
<p>使用注解开发会比配置文件开发更加方便。如下就是使用注解进行开发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(value = &quot;select * from tb_user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">select</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 <code>statement</code></li>
</ul>
</blockquote>
<p>Mybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下：</p>
<ul>
<li>查询 ：@Select</li>
<li>添加 ：@Insert</li>
<li>修改 ：@Update</li>
<li>删除 ：@Delete</li>
</ul>
<p>接下来我们做一个案例来使用 Mybatis 的注解开发</p>
<p><strong>代码实现：</strong></p>
<ul>
<li>
<p>将之前案例中 <code>UserMapper.xml</code> 中的 根据id查询数据 的 <code>statement</code> 注释掉</p>
</li>
<li>
<p>在 <code>UserMapper</code> 接口的 <code>selectById</code> 方法上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from tb_user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行测试程序也能正常查询到数据</p>
</li>
</ul>
<p><strong>注解完成简单功能，配置文件完成复杂功能。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP</title>
    <url>/2023/12/01/JSP/</url>
    <content><![CDATA[<h2 id="jsp"><a class="markdownIt-Anchor" href="#jsp"></a> JSP</h2>
<p><strong>今日目标：</strong></p>
<blockquote>
<ul>
<li>理解 JSP 及 JSP 原理</li>
<li>能在 JSP中使用 <code>EL表达式</code> 和 <code>JSTL标签</code></li>
<li>理解 <code>MVC模式</code> 和 <code>三层架构</code></li>
<li>能完成品牌数据的增删改查功能</li>
</ul>
</blockquote>
<h2 id="1-jsp-概述"><a class="markdownIt-Anchor" href="#1-jsp-概述"></a> 1. JSP 概述</h2>
<p>**JSP（全称：Java Server Pages）：Java 服务端页面。**是一种动态的网页技术，其中既可以定义 HTML、JS、CSS等静态内容，还可以定义 Java代码的动态内容，也就是 <code>JSP = HTML + Java</code>。如下就是jsp代码</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;JSP,Hello World&lt;/h1&gt;</span><br><span class="line">        &lt;%</span><br><span class="line">        	System.out.println(<span class="string">&quot;hello,jsp~&quot;</span>);</span><br><span class="line">        %&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码 <code>h1</code> 标签内容是展示在页面上，而 Java 的输出语句是输出在 idea 的控制台。<big><strong>但是因为各种各样的原因，<code>System.out.println(&quot;hello,jsp~&quot;);</code>在我的电脑上不能在控制台输出，大概率是因为tomcat和jdk版本不匹配的原因。</strong></big></p>
<p>那么，JSP 能做什么呢？现在我们只用 <code>servlet</code> 实现往网页输出内容的功能，我们看看它里面的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;&lt;body class=\&quot;index\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;&lt;div class=\&quot;mod_container\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;    &lt;!--无障碍占位--&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;    &lt;div id=\&quot;J_accessibility\&quot;&gt;&lt;/div&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;    &lt;!--顶通占位 --&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;    &lt;div id=\&quot;J_promotional-top\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;    &lt;/div&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;    &lt;h1 align=\&quot;center\&quot;&gt;&quot;</span>+username+<span class="string">&quot;,欢迎您&lt;/h1&gt;&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;    &lt;div id=\&quot;shortcut\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;        &lt;div class=\&quot;w\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;            &lt;ul class=\&quot;fl\&quot; clstag=\&quot;h|keycount|head|topbar_01\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;                &lt;li class=\&quot;dropdown\&quot; id=\&quot;ttbar-mycity\&quot;&gt;&lt;/li&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;            &lt;/ul&gt;\r\n&quot;</span>);</span><br><span class="line">           writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码有大量使用到 <code>writer</code> 对象向页面写标签内容，这样我们的代码就显得很麻烦；将来如果展示的效果出现了问题，排错也显得有点力不从心。而 JSP 是如何解决这个问题的呢？</p>
<p>在JSP中里面基本都是 <code>HTML</code> 标签，而动态数据使用 Java 代码进行展示；这样操作看起来要比用 <code>servlet</code> 实现要舒服很多。</p>
<p>JSP 作用：简化开发，避免了在Servlet中直接输出HTML标签。</p>
<h2 id="2-jsp-快速入门"><a class="markdownIt-Anchor" href="#2-jsp-快速入门"></a> 2. JSP 快速入门</h2>
<p>接下来我们做一个简单的快速入门代码。</p>
<h3 id="21-搭建环境"><a class="markdownIt-Anchor" href="#21-搭建环境"></a> 2.1  搭建环境</h3>
<p>创建一个maven的 web 项目，项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsp-demo</span><br><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       ├── java</span><br><span class="line">│       │   └── java代码</span><br><span class="line">│       ├── resources</span><br><span class="line">│       │   └──...</span><br><span class="line">│       └── webapp</span><br><span class="line">│           ├── WEB-INF</span><br><span class="line">│               └── web.xml</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure>
<p><code>pom.xml</code> 文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http=//maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">xsi</span>=<span class="string">&quot;http=//www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi</span>=<span class="string">schemaLocation</span>=<span class="string">&quot;http=//maven.apache.org/POM/4.0.0 http=//maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="22-导入-jsp-依赖"><a class="markdownIt-Anchor" href="#22-导入-jsp-依赖"></a> 2.2  导入 JSP 依赖</h3>
<p>在 <code>dependencies</code> 标签中导入 JSP 的依赖，如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该依赖的 <code>scope</code> 必须设置为 <code>provided</code>，因为 tomcat 中有这个jar包了，所以在打包时我们是不希望将该依赖打进到我们工程的war包中。</p>
<h3 id="23-创建-jsp-页面"><a class="markdownIt-Anchor" href="#23-创建-jsp-页面"></a> 2.3  创建 jsp 页面</h3>
<p>在项目的 <code>webapp</code> 下创建jsp页面</p>
<p>通过上面方式创建一个名为 <code>hello.jsp</code> 的页面。</p>
<h3 id="24-编写代码"><a class="markdownIt-Anchor" href="#24-编写代码"></a> 2.4  编写代码</h3>
<p>在 <code>hello.jsp</code> 页面中书写 <code>HTML</code> 标签和 <code>Java</code> 代码，如下</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;hello jsp&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,jsp~&quot;</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="25-测试"><a class="markdownIt-Anchor" href="#25-测试"></a> 2.5  测试</h3>
<p>启动服务器并在浏览器地址栏输入 <code>http=//localhost=8080/jsp-demo/hello.jsp</code>，我们可以在页面上看到如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello jsp</span><br></pre></td></tr></table></figure>
<p>同时也可以看到在 <code>idea</code> 的控制台看到输出的 <code>hello,jsp~</code> 内容。</p>
<h2 id="3-jsp-原理"><a class="markdownIt-Anchor" href="#3-jsp-原理"></a> 3. JSP 原理</h2>
<p>我们之前说 JSP 就是一个页面，那么在 JSP 中写 <code>html</code> 标签，我们能理解，但是为什么还可以写 <code>Java</code> 代码呢？</p>
<p>因为 **JSP 本质上就是一个 Servlet。**接下来我们聊聊访问jsp时的流程</p>
<p><img src="image-20210818111039350.png" alt="" /></p>
<ol>
<li>浏览器第一次访问 <code>hello.jsp</code> 页面</li>
<li><code>tomcat</code> 会将 <code>hello.jsp</code> 转换为名为 <code>hello_jsp.java</code> 的一个 <code>Servlet</code></li>
<li><code>tomcat</code> 再将转换的 <code>servlet</code> 编译成字节码文件 <code>hello_jsp.class</code></li>
<li><code>tomcat</code> 会执行该字节码文件，向外提供服务</li>
</ol>
<p>我们可以到项目所在磁盘目录下找 <code>target\tomcat\work\Tomcat\localhost\jsp-demo\org\apache\jsp</code> 目录，而这个目录下就能看到转换后的 <code>servlet</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello_jsp.class		CLASS文件		4kb</span><br><span class="line">hello_jsp.java		JAVA文件		4kb</span><br></pre></td></tr></table></figure>
<p>通过查看<code>hello_jsp.java代码得知</code>， <code>hello_jsp</code> 这个类就间接的继承了 <code>HttpServlet</code> ，也就说明 <code>hello_jsp</code> 是一个 <code>servlet</code>。</p>
<p>继续阅读 <code>hello_jsp</code> 类的代码，可以看到有一个名为 <code>_jspService()</code> 的方法，该方法就是每次访问 <code>jsp</code> 时自动执行的方法，和 <code>servlet</code> 中的 <code>service</code> 方法一样 。</p>
<p>而在 <code>_jspService()</code> 方法中可以看到往浏览器写标签的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out.write (<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">out.write (<span class="string">&quot;&lt;html&gt;\r\n&quot;</span>);</span><br><span class="line">out.write (<span class="string">&quot;&lt;head&gt;\r\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;</span></span><br><span class="line"><span class="string">&lt;title&gt;Title&lt;/title&gt;\r\n&quot;</span>);</span><br><span class="line">out.write (<span class="string">&quot;&lt;/head&gt;\r\n&quot;</span>);</span><br><span class="line">out.write (<span class="string">&quot;&lt;body&gt;\r\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">out.write (<span class="string">&quot;</span></span><br><span class="line"><span class="string">&lt;h1&gt;hello jsp&lt;/h1&gt;\r\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot; &quot;</span>)</span><br><span class="line">System.out.printin (<span class="string">&quot;hello,jsp~&quot;</span>);</span><br><span class="line"><span class="type">int</span> i=<span class="number">3</span>;</span><br><span class="line">out.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">out.write (<span class="string">&quot;&lt;/body&gt;\r\n&quot;</span>);</span><br><span class="line">out.write (<span class="string">&quot;&lt;/html&gt;\r\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以前我们自己写 <code>servlet</code> 时，这部分代码是由我们自己来写，现在有了 <code>jsp</code> 后，由tomcat完成这部分功能，自己只需要写html即可。</p>
<h2 id="4-jsp-脚本"><a class="markdownIt-Anchor" href="#4-jsp-脚本"></a> 4. JSP 脚本</h2>
<p>JSP脚本用于在 JSP页面内定义 Java代码。在之前的入门案例中我们就在 JSP 页面定义的 Java 代码就是 JSP 脚本。</p>
<h3 id="41-jsp-脚本分类"><a class="markdownIt-Anchor" href="#41-jsp-脚本分类"></a> 4.1  JSP 脚本分类</h3>
<p>JSP 脚本有如下三个分类：</p>
<ul>
<li>&lt;%…%&gt;：内容会直接放到_jspService()方法之中</li>
<li>&lt;%=…%&gt;：内容会放到out.print()中，作为out.print()的参数</li>
<li>&lt;%!…%&gt;：内容会放到_jspService()方法之外，被类直接包含</li>
</ul>
<p><strong>代码演示：</strong></p>
<p>在 <code>hello.jsp</code> 中书写</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    System.out.println(<span class="string">&quot;hello,jsp~&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>通过浏览器访问 <code>hello.jsp</code> 后，查看转换的 <code>hello_jsp.java</code> 文件，i 变量定义在了 <code>_jspService()</code> 方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello,jsp~&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>hello.jsp</code> 中书写</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%=<span class="string">&quot;hello&quot;</span>%&gt;</span><br><span class="line">&lt;%=i%&gt;</span><br></pre></td></tr></table></figure>
<p>通过浏览器访问 <code>hello.jsp</code> 后，查看转换的 <code>hello_jsp.java</code> 文件，该脚本的内容被放在了 <code>out.print()</code> 中，作为参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">out.print(i);</span><br></pre></td></tr></table></figure>
<p>在 <code>hello.jsp</code> 中书写</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">void</span>  <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>通过浏览器访问 <code>hello.jsp</code> 后，查看转换的 <code>hello_jsp.java</code> 文件，该脚本的内容被放在了成员位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">hello_jsp</span> <span class="keyword">extends</span> <span class="title class_">org</span>.apache.jasper.runtime.HttpJspBase</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">org</span>.apache.jasper.runtime.JspSourceDependent&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">show</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="42-jsp-缺点"><a class="markdownIt-Anchor" href="#42-jsp-缺点"></a> 4.2  JSP 缺点</h3>
<p>JSP 也有很多缺点。</p>
<p>由于 JSP页面内，既可以定义 HTML 标签，又可以定义 Java代码，造成了以下问题：</p>
<ul>
<li>
<p>书写麻烦：特别是复杂的页面</p>
<p>既要写 HTML 标签，还要写 Java 代码</p>
</li>
<li>
<p>阅读麻烦</p>
<p>当代码很多的时候你后期再看这段代码时还需要花费很长的时间去梳理</p>
</li>
<li>
<p>复杂度高：运行需要依赖于各种环境，JRE，JSP容器，JavaEE…</p>
</li>
<li>
<p>占内存和磁盘：JSP会自动生成.java和.class文件占磁盘，运行的是.class文件占内存</p>
</li>
<li>
<p>调试困难：出错后，需要找到自动生成的.java文件进行调试</p>
</li>
<li>
<p>不利于团队协作：前端人员不会 Java，后端人员不精 HTML</p>
<p>如果页面布局发生变化，前端工程师对静态页面进行修改，然后再交给后端工程师，由后端工程师再将该页面改为 JSP 页面</p>
</li>
</ul>
<p>由于上述的问题， **JSP 已逐渐退出历史舞台，**以后开发更多的是使用 <strong>HTML +  Ajax</strong> 来替代。Ajax 是我们后续会重点学习的技术。有个这个技术后，前端工程师负责前端页面开发，而后端工程师只负责前端代码开发。下来对技术的发展进行简单的说明</p>
<pre><code class="highlight mermaid">graph LR
    A(Servlet) --&gt; B(JSP)
    B --&gt; C(Servlet+JSP)
    C --&gt; D(Servlet+JSP+ajax)</code></pre>
<ol>
<li>
<p>第一阶段：使用 <code>servlet</code> 即实现逻辑代码编写，也对页面进行拼接。这种模式我们之前也接触过</p>
</li>
<li>
<p>第二阶段：随着技术的发展，出现了 <code>JSP</code> ，人们发现 <code>JSP</code> 使用起来比 <code>Servlet</code> 方便很多，但是还是要在 <code>JSP</code> 中嵌套 <code>Java</code> 代码，也不利于后期的维护</p>
</li>
<li>
<p>第三阶段：使用 <code>Servlet</code> 进行逻辑代码开发，而使用 <code>JSP</code> 进行数据展示</p>
<pre><code class="highlight mermaid">graph LR
    A(不要直接在JSP里写Java代码) --&gt; B(Servlet 逻辑处理-封装数据)
    A --&gt; C(JSP 获取数据-便利展现数据)</code></pre>
</li>
<li>
<p>第四阶段：使用 <code>servlet</code> 进行后端逻辑代码开发，而使用 <code>HTML</code> 进行数据展示。而这里面就存在问题，<code>HTML</code> 是静态页面，怎么进行动态数据展示呢？这就是 <code>ajax</code> 的作用了。</p>
</li>
</ol>
<p>那既然 JSP 已经逐渐的退出历史舞台，那我们为什么还要学习 <code>JSP</code> 呢？原因有两点：</p>
<ul>
<li>一些公司可能有些老项目还在用 <code>JSP</code> ，所以要求我们必须了解 <code>JSP</code></li>
<li>我们如果不经历这些复杂的过程，就不能体现后面阶段开发的简单</li>
</ul>
<p>接下来我们来学习第三阶段，使用 <code>EL表达式</code> 和 <code>JSTL</code> 标签库替换 <code>JSP</code> 中的 <code>Java</code> 代码。</p>
<h2 id="5-el-表达式"><a class="markdownIt-Anchor" href="#5-el-表达式"></a> 5. EL 表达式</h2>
<p><strong>在jsp中可能会发现<code>EL表达式</code>不起作用的情况，此时需要在jsp中添加以下代码放在页面开头：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@page isELIgnored=&quot;false&quot; %&gt;</span><br></pre></td></tr></table></figure>
<h3 id="51-概述"><a class="markdownIt-Anchor" href="#51-概述"></a> 5.1  概述</h3>
<p>EL（全称Expression Language ）表达式语言，用于简化 JSP 页面内的 Java 代码。</p>
<p>EL 表达式的主要作用是 <strong>获取数据</strong>。其实就是从域对象中获取数据，然后将数据展示在页面上。</p>
<p>而 EL 表达式的语法也比较简单， <code>$&#123;expression&#125;</code> 。例如：${brands} 就是获取域中存储的 key 为 brands 的数据。</p>
<h3 id="52-代码演示"><a class="markdownIt-Anchor" href="#52-代码演示"></a> 5.2  代码演示</h3>
<ul>
<li>
<p>定义servlet，在 servlet 中封装一些数据并存储到 request 域对象中并转发到 <code>el-demo.jsp</code> 页面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 准备数据</span></span><br><span class="line">        List&lt;Brand&gt; brands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Brand&gt;();</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">1</span>,<span class="string">&quot;三只松鼠&quot;</span>,<span class="string">&quot;三只松鼠&quot;</span>,<span class="number">100</span>,<span class="string">&quot;三只松鼠，好吃不上火&quot;</span>,<span class="number">1</span>));</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">2</span>,<span class="string">&quot;优衣库&quot;</span>,<span class="string">&quot;优衣库&quot;</span>,<span class="number">200</span>,<span class="string">&quot;优衣库，服适人生&quot;</span>,<span class="number">0</span>));</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">3</span>,<span class="string">&quot;小米&quot;</span>,<span class="string">&quot;小米科技有限公司&quot;</span>,<span class="number">1000</span>,<span class="string">&quot;为发烧而生&quot;</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 存储到request域中</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;brands&quot;</span>,brands);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 转发到 el-demo.jsp</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/el-demo.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 此处需要用转发，因为转发才可以使用 request 对象作为域对象进行数据共享</p>
</blockquote>
</li>
<li>
<p>在 <code>el-demo.jsp</code> 中通过 EL表达式 获取数据</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    $&#123;brands&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在浏览器的地址栏输入 <code>http=//localhost=8080/jsp-demo/demo1</code> ，页面效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Brand&#123;&quot;id&quot;=1,&quot;brandName&quot;=&quot;三只松鼠&quot;,&quot;companyName&quot;=&quot;三只松鼠&quot;,&quot;ordered&quot;=100,&quot;description&quot;=&quot;三只松鼠，好吃不上火&quot;,&quot;status&quot;=1,&quot;Brandfid&quot;=2&#125;,Brand&#123;&quot;id&quot;=2,&quot;brandName&quot;=&quot;优衣库&quot;,&quot;companyName&quot;=&quot;优衣库&quot;,&quot;ordered&quot;=200,&quot;description&quot;=&quot;优衣库，服适人生&quot;,&quot;status&quot;=0,&quot;Brandfid&quot;=3&#125;,Brand&#123;&quot;id&quot;=3,&quot;brandName&quot;=&quot;小米&quot;,&quot;companyName&quot;=&quot;小米科技有限公司&quot;,&quot;ordered&quot;=1000,&quot;description&quot;=&quot;为发烧而生&quot;,&quot;status&quot;=1&#125;]</span><br></pre></td></tr></table></figure>
<p>如果<code>EL表达式</code>不起作用，可以在el-demo.jsp中添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@page isELIgnored=&quot;false&quot; %&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="53-域对象"><a class="markdownIt-Anchor" href="#53-域对象"></a> 5.3  域对象</h3>
<p>JavaWeb中有四大域对象，分别是：</p>
<ul>
<li>page：当前页面有效</li>
<li>request：当前请求有效</li>
<li>session：当前会话有效</li>
<li>application：当前应用有效</li>
</ul>
<p>el 表达式获取数据，会依次从这4个域中寻找，直到找到为止。例如： ${brands}，el 表达式获取数据，会先从page域对象中获取数据，如果没有再到 requet 域对象中获取数据，如果再没有再到 session 域对象中获取，如果还没有才会到 application 中获取数据。</p>
<h2 id="6-jstl标签"><a class="markdownIt-Anchor" href="#6-jstl标签"></a> 6. JSTL标签</h2>
<h3 id="61-概述"><a class="markdownIt-Anchor" href="#61-概述"></a> 6.1  概述</h3>
<p>JSP标准标签库(Jsp Standarded Tag Library) ，使用标签取代JSP页面上的Java代码。如下代码就是JSTL标签</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c=<span class="keyword">if</span> test=<span class="string">&quot;$&#123;flag == 1&#125;&quot;</span>&gt;</span><br><span class="line">    男</span><br><span class="line">&lt;/c=<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;c=<span class="keyword">if</span> test=<span class="string">&quot;$&#123;flag == 2&#125;&quot;</span>&gt;</span><br><span class="line">    女</span><br><span class="line">&lt;/c=<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码看起来是不是比 JSP 中嵌套 Java 代码看起来舒服好了。而且前端工程师对标签是特别敏感的，他们看到这段代码是能看懂的。</p>
<p>JSTL 提供了很多标签，如下图:</p>
<table>
<thead>
<tr>
<th>JSTL 标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;c:if&gt;</code></td>
<td>条件判断标签，用于执行条件语句</td>
</tr>
<tr>
<td><code>&lt;c:choose&gt;</code></td>
<td>多路选择标签，类似于 switch 语句</td>
</tr>
<tr>
<td><code>&lt;c:forEach&gt;</code></td>
<td>迭代循环标签，用于遍历集合或数组</td>
</tr>
<tr>
<td><code>&lt;c:set&gt;</code></td>
<td>变量赋值标签，用于设置变量的值</td>
</tr>
<tr>
<td><code>&lt;c:out&gt;</code></td>
<td>输出标签，用于输出变量或表达式的值</td>
</tr>
<tr>
<td><code>&lt;c:url&gt;</code></td>
<td>URL 标签，用于构建 URL 地址</td>
</tr>
<tr>
<td><code>&lt;c:import&gt;</code></td>
<td>导入标签，用于导入其他页面或资源</td>
</tr>
<tr>
<td><code>&lt;c:redirect&gt;</code></td>
<td>重定向标签，用于进行页面重定向</td>
</tr>
<tr>
<td><code>&lt;c:param&gt;</code></td>
<td>参数标签，用于传递参数到其他页面或资源</td>
</tr>
<tr>
<td><code>&lt;c:catch&gt;</code></td>
<td>异常捕获标签，用于捕获并处理异常</td>
</tr>
<tr>
<td><code>&lt;c:remove&gt;</code></td>
<td>移除标签，用于移除指定作用域中的属性</td>
</tr>
</tbody>
</table>
<p>我们只对两个最常用的标签进行讲解，<code>&lt;c=forEach&gt;</code> 标签和 <code>&lt;c=if&gt;</code> 标签。</p>
<p>JSTL 使用也是比较简单的，分为如下步骤：</p>
<ul>
<li>
<p>导入坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在JSP页面上引入JSTL标签库</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http=//java.sun.com/jsp/jstl/core&quot;</span> %&gt; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用标签</p>
</li>
</ul>
<h3 id="62-if-标签"><a class="markdownIt-Anchor" href="#62-if-标签"></a> 6.2  if 标签</h3>
<p><code>&lt;c=if&gt;</code>：相当于 if 判断</p>
<ul>
<li>属性：test，用于定义条件表达式</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c=<span class="keyword">if</span> test=<span class="string">&quot;$&#123;flag == 1&#125;&quot;</span>&gt;</span><br><span class="line">    男</span><br><span class="line">&lt;/c=<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;c=<span class="keyword">if</span> test=<span class="string">&quot;$&#123;flag == 2&#125;&quot;</span>&gt;</span><br><span class="line">    女</span><br><span class="line">&lt;/c=<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>代码演示：</strong></p>
<ul>
<li>
<p>定义一个 <code>servlet</code> ，在该 <code>servlet</code> 中向 request 域对象中添加 键是 <code>status</code> ，值为 <code>1</code> 的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 存储数据到request域中</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;status&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 转发到 jstl-if.jsp</span></span><br><span class="line">        数据request.getRequestDispatcher(<span class="string">&quot;/jstl-if.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义 <code>jstl-if.jsp</code> 页面，在该页面使用 <code>&lt;c=if&gt;</code> 标签</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http=//java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--</span><br><span class="line">        c=<span class="keyword">if</span>：来完成逻辑判断，替换java  <span class="keyword">if</span> <span class="keyword">else</span></span><br><span class="line">    --%&gt;</span><br><span class="line">    &lt;c=<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == 1&#125;&quot;</span>&gt;</span><br><span class="line">        启用</span><br><span class="line">    &lt;/c=<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;c=<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == 0&#125;&quot;</span>&gt;</span><br><span class="line">        禁用</span><br><span class="line">    &lt;/c=<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 在该页面已经要引入 JSTL核心标签库</p>
<p><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http=//java.sun.com/jsp/jstl/core&quot; %&gt;</code></p>
</blockquote>
</li>
</ul>
<h3 id="63-foreach-标签"><a class="markdownIt-Anchor" href="#63-foreach-标签"></a> 6.3  forEach 标签</h3>
<p><code>&lt;c=forEach&gt;</code>：相当于 for 循环。java中有增强for循环和普通for循环，JSTL 中的 <code>&lt;c=forEach&gt;</code> 也有两种用法</p>
<h4 id="631-用法一"><a class="markdownIt-Anchor" href="#631-用法一"></a> 6.3.1  用法一</h4>
<p>类似于 Java 中的增强for循环。涉及到的 <code>&lt;c=forEach&gt;</code> 中的属性如下</p>
<ul>
<li>
<p>items：被遍历的容器</p>
</li>
<li>
<p>var：遍历产生的临时变量</p>
</li>
<li>
<p>varStatus：遍历状态对象</p>
</li>
</ul>
<p>如下代码，是从域对象中获取名为 brands 数据，该数据是一个集合；遍历遍历，并给该集合中的每一个元素起名为 <code>brand</code>，是 Brand对象。在循环里面使用 EL表达式获取每一个Brand对象的属性值</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c=forEach items=<span class="string">&quot;$&#123;brands&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;brand&quot;</span>&gt;</span><br><span class="line">    &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.brandName&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.companyName&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;brand.description&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/c=forEach&gt;</span><br></pre></td></tr></table></figure>
<p><strong>代码演示：</strong></p>
<ul>
<li>
<p><code>servlet</code> 还是使用之前的名为 <code>ServletDemo1</code> 。</p>
</li>
<li>
<p>定义名为 <code>jstl-foreach.jsp</code> 页面，内容如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http=//java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;新增&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span> cellspacing=<span class="string">&quot;0&quot;</span> width=<span class="string">&quot;800&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;序号&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;品牌名称&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;企业名称&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;排序&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;品牌介绍&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;状态&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;c=forEach items=<span class="string">&quot;$&#123;brands&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;brand&quot;</span> varStatus=<span class="string">&quot;status&quot;</span>&gt;</span><br><span class="line">        &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">            &lt;%--&lt;td&gt;$&#123;brand.id&#125;&lt;/td&gt;--%&gt;</span><br><span class="line">            &lt;td&gt;$&#123;status.count&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;brand.brandName&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;brand.companyName&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;brand.ordered&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;brand.description&#125;&lt;/td&gt;</span><br><span class="line">            &lt;c=<span class="keyword">if</span> test=<span class="string">&quot;$&#123;brand.status == 1&#125;&quot;</span>&gt;</span><br><span class="line">                &lt;td&gt;启用&lt;/td&gt;</span><br><span class="line">            &lt;/c=<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;c=<span class="keyword">if</span> test=<span class="string">&quot;$&#123;brand.status != 1&#125;&quot;</span>&gt;</span><br><span class="line">                &lt;td&gt;禁用&lt;/td&gt;</span><br><span class="line">            &lt;/c=<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href=<span class="string">&quot;#&quot;</span>&gt;修改&lt;/a&gt; &lt;a href=<span class="string">&quot;#&quot;</span>&gt;删除&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c=forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="632-用法二"><a class="markdownIt-Anchor" href="#632-用法二"></a> 6.3.2  用法二</h4>
<p>类似于 Java 中的普通for循环。涉及到的 <code>&lt;c=forEach&gt;</code> 中的属性如下</p>
<ul>
<li>
<p>begin：开始数</p>
</li>
<li>
<p>end：结束数</p>
</li>
<li>
<p>step：步长</p>
</li>
</ul>
<p>实例代码：</p>
<p>从0循环到10，变量名是 <code>i</code> ，每次自增1</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c=forEach begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;10&quot;</span> step=<span class="string">&quot;1&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span>&gt;</span><br><span class="line">    $&#123;i&#125;</span><br><span class="line">&lt;/c=forEach&gt;</span><br></pre></td></tr></table></figure>
<h2 id="7-mvc模式和三层架构"><a class="markdownIt-Anchor" href="#7-mvc模式和三层架构"></a> 7. MVC模式和三层架构</h2>
<p>MVC 模式和三层架构是一些理论的知识，将来我们使用了它们进行代码开发会让我们代码维护性和扩展性更好。</p>
<h3 id="71-mvc模式"><a class="markdownIt-Anchor" href="#71-mvc模式"></a> 7.1  MVC模式</h3>
<p>MVC 是一种分层开发的模式，其中：</p>
<ul>
<li>
<p>M：Model，业务模型，处理业务</p>
</li>
<li>
<p>V：View，视图，界面展示</p>
</li>
<li>
<p>C：Controller，控制器，处理请求，调用模型和视图</p>
</li>
</ul>
<p>控制器（serlvlet）用来接收浏览器发送过来的请求，控制器调用模型（JavaBean）来获取数据，比如从数据库查询数据；控制器获取到数据后再交由视图（JSP）进行数据展示。</p>
<p><strong>MVC 好处：</strong></p>
<ul>
<li>
<p>职责单一，互不影响。每个角色做它自己的事，各司其职。</p>
</li>
<li>
<p>有利于分工协作。</p>
</li>
<li>
<p>有利于组件重用</p>
</li>
</ul>
<h3 id="72-三层架构"><a class="markdownIt-Anchor" href="#72-三层架构"></a> 7.2  三层架构</h3>
<p>三层架构是将我们的项目分成了三个层面，分别是 <code>表现层</code>、<code>业务逻辑层</code>、<code>数据访问层</code>。</p>
<p><img src="image-20210818164301154.png" alt="" /></p>
<ul>
<li>数据访问层：对数据库的CRUD基本操作</li>
<li>业务逻辑层：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能。例如 <code>注册业务功能</code> ，我们会先调用 <code>数据访问层</code> 的 <code>selectByName()</code> 方法判断该用户名是否存在，如果不存在再调用 <code>数据访问层</code> 的 <code>insert()</code> 方法进行数据的添加操作</li>
<li>表现层：接收请求，封装数据，调用业务逻辑层，响应数据</li>
</ul>
<p>而整个流程是，浏览器发送请求，表现层的Servlet接收请求并调用业务逻辑层的方法进行业务逻辑处理，而业务逻辑层方法调用数据访问层方法进行数据的操作，依次返回到serlvet，然后servlet将数据交由 JSP 进行展示。</p>
<p>三层架构的每一层都有特有的包名称：</p>
<ul>
<li>表现层： <code>com.itheima.controller</code> 或者 <code>com.itheima.web</code></li>
<li>业务逻辑层：<code>com.itheima.service</code></li>
<li>数据访问层：<code>com.itheima.dao</code> 或者 <code>com.itheima.mapper</code></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2023/11/25/Maven/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>之前胡乱吞枣的看过Maven的视频，当时就是啥也没记住，看完视频就算完了，然后在看Servlet时感觉前面的都忘掉了，想着再看一遍，既然都看了，就得留下点东西吧，既是总结，也是为了以后方便自己回顾。</p>
<h1 id="1-maven简介"><a class="markdownIt-Anchor" href="#1-maven简介"></a> 1. Maven简介</h1>
<p>Maven是专门用于管理和构建Java项目的<big><strong>工具</strong></big>，它基于项目对象模型(POM-Project Object Model)的概念，通过一小段描述信息来管理项目的构建、报告和文档，<a href="http://maven.apache.org/">Maven官网</a>，它的主要功能有：</p>
<blockquote>
<ul>
<li>
<p>提供了一套标准化的项目结构，便于不同IDE的项目可以通用</p>
</li>
<li>
<p>提供了一套标准化的构建流程（编译，测试，打包，发布……）</p>
</li>
<li>
<p>提供了一套依赖管理机制，方便管理项目依赖的第三方资源</p>
</li>
</ul>
</blockquote>
<p><big><strong>标准化的项目结构：</strong></big></p>
<blockquote>
<p>项目结构我们都知道，每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。我在eclipse中创建的项目，无法在IDEA中进行使用，这就造成了很大的不方便。</p>
<p>而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。下图就是Maven构建的项目结构：</p>
<img src="/img/maven项目结构.png" />
<p>其中pom.xml项目核心配置文件和src目录同级。</p>
</blockquote>
<p><big><strong>标准化的构建流程：</strong></big></p>
<p>我们开发了如上图所示的一套系统，代码需要进行<big><code>编译 -&gt; 测试 -&gt; 打包 -&gt;发布</code></big>，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。</p>
<p><big><strong>依赖管理机制：</strong></big></p>
<p>依赖管理就是管理项目所依赖的第三方资源（jar包、插件）。如项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包，复制到项目中，还要将jar包加入工作环境这一系列的操作。如下图所示：</p>
<img src="/img/依赖管理.png" />
<p>而Maven使用标准的 <strong>坐标</strong> 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。在pom.xml项目核心配置文件中进行配置：</p>
<img src="/img/maven依赖管理.png" />
<p>如上图右边所示就是mysql驱动包的坐标，在项目中只需要写这段配置，其他都不需要我们担心，Maven都帮我们进行操作，mysql驱动包会自动放到项目的External Libraries中。</p>
<h2 id="11-maven模型"><a class="markdownIt-Anchor" href="#11-maven模型"></a> 1.1 Maven模型</h2>
<p>Maven模型包含三部分：</p>
<ul>
<li>项目对象模型 (Project Object Model)</li>
<li>依赖管理模型(Dependency)</li>
<li>插件(Plugin)</li>
</ul>
<img src="/img/maven模型.png" title="maven模型" />
<p>如上图所示就是Maven的模型，红色框框起来的部分，用来完成 <code>标准化构建流程</code> 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。</p>
<p>上图中黑色框起来的部分，项目对象模型就是将我们自己的项目抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目模型，黑色框是当前项目坐标：</p>
<img src="/img/maven坐标.png" title="maven坐标" />
<p>依赖管理模型是使用坐标来描述当前项目依赖哪些第三方jar包，红色框框所示。</p>
<h2 id="12-maven仓库"><a class="markdownIt-Anchor" href="#12-maven仓库"></a> 1.2 Maven仓库</h2>
<p>有这样的场景，我们创建Maven项目，在项目中使用坐标来指定项目依赖的第三方jar包，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。</p>
<p><strong>Maven共有三种仓库</strong>，分别是：</p>
<ul>
<li>
<p>本地仓库：自己计算机上的一个目录</p>
</li>
<li>
<p>中央仓库：由Maven团队维护的全球唯一的仓库</p>
<ul>
<li>地址： <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li>
</ul>
</li>
<li>
<p>远程仓库(私服)：一般由公司团队搭建的私有仓库</p>
<p>今天我们只学习远程仓库的使用，并不会搭建。</p>
</li>
</ul>
<p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包：</p>
<ul>
<li>
<p>如果有，则在项目直接引用;</p>
</li>
<li>
<p>如果没有，则去中央仓库中下载对应的jar包到本地仓库。</p>
</li>
</ul>
<pre><code class="highlight mermaid">graph LR;
    A[Maven项目1] ----&gt; B[Maven本地仓库];
    D[Maven项目2] ----&gt; B[Maven本地仓库];
    B[Maven本地仓库] ----&gt; C[Maven中央仓库];
    
	A[Maven项目1] ----&gt; B[Maven本地仓库];
	D[Maven项目2] ----&gt; B[Maven本地仓库];
	C[Maven中央仓库] ----&gt; B[Maven本地仓库];
</code></pre>
<p>如果还可以搭建远程仓库，将来jar包的查找顺序则变为：</p>
<blockquote>
<p>本地仓库 --&gt; 远程仓库–&gt; 中央仓库</p>
</blockquote>
<pre><code class="highlight mermaid">graph LR;
    A[Maven项目1] ----&gt; B[Maven本地仓库];
    D[Maven项目2] ----&gt; B[Maven本地仓库];
    B --&gt; E[远程仓库]
    E --&gt; C[中央仓库]
    
	A[Maven项目1] ----&gt; B[Maven本地仓库];
	D[Maven项目2] ----&gt; B[Maven本地仓库];
	E --&gt; B
	C --&gt; E</code></pre>
<h1 id="2-maven安装配置"><a class="markdownIt-Anchor" href="#2-maven安装配置"></a> 2. Maven安装配置</h1>
<ul>
<li>
<ol>
<li>
<p>安装Maven到没有中文、特殊字符的路径下。</p>
<p>安装打开文件夹后的目录结构如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- bin (文件夹)</span><br><span class="line">|-- boot (文件夹)</span><br><span class="line">|-- conf (文件夹)</span><br><span class="line">|-- lib (文件夹)</span><br><span class="line">|-- LICENSE</span><br><span class="line">|-- NOTICE</span><br><span class="line">|-- README.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>bin目录：存放Maven可执行命令，例如mvn命令</li>
<li>conf目录 ：存放Maven的配置文件。<code>settings.xml</code> 配置文件后期需要修改。</li>
<li>lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。</li>
</ul>
</li>
</ol>
</li>
<li>
<ol start="2">
<li>
<p>配置环境变量</p>
<ul>
<li>
<p>在系统变量中新建一个变量<code>MAVEN_HOME</code></p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>MAVEN_HOME</th>
</tr>
</thead>
<tbody>
<tr>
<td>变量值</td>
<td>D:\apache-maven-3.9.5</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>在<code>PATH</code>中添加新的值<code>%MAVEN_HOME%\bin</code></p>
</li>
<li>
<p>在命令行窗口中输入<code>mvn --version</code>进行验证</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<ol start="3">
<li>配置本地仓库</li>
</ol>
</li>
</ul>
<blockquote>
<p>修改 conf/settings.xml 中的 <localRepository> 为一个指定目录作为本地仓库，用来存储jar包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\apache-maven-3.9.5\mvn_resp<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不配置的话本地仓库的默认目录为<code>C:\Users\用户名\.m2\repository</code></p>
</blockquote>
<ul>
<li>
<ol start="4">
<li>配置阿里云私服</li>
</ol>
<blockquote>
<p>中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p>
<p>修改 conf/settings.xml 中的 <mirrors>标签，为其添加如下子标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>   			         <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h1 id="3-maven基本使用"><a class="markdownIt-Anchor" href="#3-maven基本使用"></a> 3. Maven基本使用</h1>
<h2 id="31-maven常用命令"><a class="markdownIt-Anchor" href="#31-maven常用命令"></a> 3.1 Maven常用命令</h2>
<blockquote>
<ul>
<li><code>compile</code>：编译项目的源代码，将源代码编译成字节码文件。</li>
<li><code>clean</code>：清理项目，删除之前构建过程中生成的目录和文件，通常用于在重新构建项目之前执行。</li>
<li><code>test</code>：运行项目中的测试用例。</li>
<li><code>package</code>：将项目打包成可发布的格式，比如 JAR（Java Archive）或 WAR（Web Archive）。</li>
<li><code>install</code>：将项目打包结果安装到本地 Maven 仓库中，以供其他项目引用。</li>
</ul>
</blockquote>
<p>假设我们已经有了一个Maven构建的项目，项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maven-project</span><br><span class="line">​	|--- src (文件夹)</span><br><span class="line">​	|--- pom.xml</span><br></pre></td></tr></table></figure>
<p>我们使用上面命令需要在磁盘上进入到项目的 <code>pom.xml</code> 同级目录下，打开命令提示符。</p>
<ul>
<li>
<p><strong>编译命令演示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compile:编译</span><br><span class="line">mvn compile</span><br></pre></td></tr></table></figure>
<p>执行上述命令可以看到：</p>
<ul>
<li>
<p>从阿里云下载编译需要的插件的jar包，在本地仓库也能看到下载好的插件。</p>
</li>
<li>
<p>在项目下会生成一个 <code>target</code> 目录，编译后的字节码文件就放在<code>target</code>目录中。</p>
<p>此时的Maven项目结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maven-project</span><br><span class="line">	|--- src (代码文件夹)</span><br><span class="line">	|--- target (存放字节码文件)</span><br><span class="line">	|--- pom.xml</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>清理命令演示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clean:清理</span><br><span class="line">mvn clean</span><br></pre></td></tr></table></figure>
<p>执行上述命令可以看到</p>
<ul>
<li>
<p>从阿里云下载清理需要的插件jar包</p>
</li>
<li>
<p>删除项目下的 <code>target</code> 目录</p>
<p>此时的Maven项目结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maven-project</span><br><span class="line">	|--- src (代码文件夹)</span><br><span class="line">	|--- pom.xml</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>打包命令演示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package:打包</span><br><span class="line">mvn package</span><br></pre></td></tr></table></figure>
<p>执行上述命令可以看到：</p>
<ul>
<li>从阿里云下载打包需要的插件jar包</li>
<li>在项目的 <code>terget</code> 目录下有一个jar包（将当前项目打成的jar包，Web项目会打包成war包）</li>
</ul>
</li>
<li>
<p><strong>测试命令演示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test:测试</span><br><span class="line">mvn test</span><br></pre></td></tr></table></figure>
<p>该命令会执行所有的测试代码。</p>
</li>
<li>
<p><strong>安装命令演示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>
<p>该命令会将当前项目打成jar包（将当前项目打成的jar包，Web项目会打包成war包），并安装到本地仓库。</p>
</li>
</ul>
<h2 id="32-maven生命周期"><a class="markdownIt-Anchor" href="#32-maven生命周期"></a> 3.2 Maven生命周期</h2>
<p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件</p>
<p>Maven 对项目构建的生命周期划分为3套：</p>
<ul>
<li>clean ：清理工作。</li>
<li>default ：核心工作，例如编译，测试，打包，安装等。</li>
<li>site ： 产生报告，发布站点等。这套声明周期一般不会使用。</li>
</ul>
<p>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下：</p>
<pre><code class="highlight mermaid">graph LR
    A((开始)):::circle --&gt;|验证通过| B[compile]
    B --&gt;|编译成功| C[test]
    C --&gt;|测试通过| D[package]
    D --&gt;|打包成功| E[install]
    E --&gt;|安装成功| F((结束))
</code></pre>
<p>当我们执行 <code>install</code>（安装）命令时，它会先执行 <code>compile</code>命令，再执行 <code>test</code> 命令，再执行 <code>package</code> 命令，最后执行 <code>install</code> 命令。</p>
<p>当我们执行 <code>package</code> （打包）命令时，它会先执行 <code>compile</code> 命令，再执行 <code>test</code> 命令，最后执行 <code>package</code> 命令。</p>
<h1 id="4-idea使用maven"><a class="markdownIt-Anchor" href="#4-idea使用maven"></a> 4. IDEA使用Maven</h1>
<h2 id="41-idea配置maven环境"><a class="markdownIt-Anchor" href="#41-idea配置maven环境"></a> 4.1 IDEA配置Maven环境</h2>
<p>需要先在IDEA中配置Maven环境：</p>
<ul>
<li>
<p>在IDEA中点击File（或者alt + F打开），然后点击Settings。</p>
<p><code>IDEA -&gt; File -&gt; Settings</code></p>
</li>
<li>
<p>搜索maven</p>
</li>
<li>
<p>设置 IDEA 使用本地安装的 Maven，并修改配置文件路径，即修改<code>Maven home path</code>和<code>User settings file</code>。</p>
<ul>
<li>
<p><big><strong>修改前：</strong></big></p>
<blockquote>
<table>
<thead>
<tr>
<th>Maven home path:</th>
<th>Bundled (Maven 3)</th>
</tr>
</thead>
<tbody>
<tr>
<td>User settings file:</td>
<td>C:\Users\用户名.m2\settings.xml</td>
</tr>
<tr>
<td>Local repository:</td>
<td>C:\Users\用户名.m2\repository</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
<li>
<p><big><strong>修改后：</strong></big></p>
<blockquote>
<table>
<thead>
<tr>
<th>Maven home path:</th>
<th>D:\apache-maven-3.9.5</th>
</tr>
</thead>
<tbody>
<tr>
<td>User settings file:</td>
<td>D:\apache-maven-3.9.5\conf\settings.xml</td>
</tr>
<tr>
<td>Local repository:</td>
<td>D:\apache-maven-3.9.5\mvn_resp</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
</ul>
</li>
<li>
<p>点击Apply，再点击OK生效</p>
</li>
</ul>
<h2 id="42-maven坐标详解"><a class="markdownIt-Anchor" href="#42-maven坐标详解"></a> 4.2 Maven坐标详解</h2>
<p><strong>什么是坐标？</strong></p>
<ul>
<li>Maven 中的坐标是<strong>资源的唯一标识</strong></li>
<li>使用坐标来定义项目或引入项目中需要的依赖</li>
</ul>
<p><strong>Maven 坐标主要组成</strong></p>
<ul>
<li>groupId：定义当前Maven项目隶属<strong>组织名称</strong>（像是公司名称，通常是域名反写，例如：com.itheima）</li>
<li>artifactId：定义当前Maven<strong>项目名称</strong>（通常是模块名称，例如 order-service、goods-service）</li>
<li>version：定义当前项目版本号</li>
</ul>
<p>如下面就是使用坐标表示一个项目：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>上面所说的资源可以是插件(像编译maven所需插件或者打包所需插件)、依赖、当前项目。</li>
<li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li>
</ul>
</blockquote>
<h2 id="43-idea创建maven项目"><a class="markdownIt-Anchor" href="#43-idea创建maven项目"></a> 4.3 IDEA创建Maven项目</h2>
<ul>
<li>
<p>填写模块信息，点击Create</p>
<img src="/img/创建maven项目.png" />
</li>
<li>
<p>创建好的项目目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maven项目</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── com.itheima</span><br><span class="line">│   │   │       └── Main.java</span><br><span class="line">│   │   └── resources</span><br><span class="line">|   |</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       │   └── com.itheima</span><br><span class="line">│       │       └── MainTest.java</span><br><span class="line">│       └── resources   //注意，创建完项目后会发现test中没有resources文件夹，需要自己创建</span><br><span class="line">│           </span><br><span class="line">├── pom.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="44-idea导入maven项目"><a class="markdownIt-Anchor" href="#44-idea导入maven项目"></a> 4.4 IDEA导入Maven项目</h2>
<p>可以通过以下步骤进行项目的导入：</p>
<ul>
<li>
<p>选择右侧Maven面板，点击 + 号</p>
<img src="/img/导入maven项目1.png" />
</li>
<li>
<p>选中对应项目的pom.xml文件，双击即可</p>
<img src="/img/导入maven项目2.png" />
</li>
</ul>
<h2 id="45-配置maven-helper插件"><a class="markdownIt-Anchor" href="#45-配置maven-helper插件"></a> 4.5 配置Maven-Helper插件</h2>
<p>为方便Maven操作可在IDEA中下载Maven插件提高工作效率：</p>
<ul>
<li>
<p>选择 IDEA中 File --&gt; Settings</p>
</li>
<li>
<p>选择 Plugins</p>
</li>
<li>
<p>搜索 Maven，选择第一个 Maven Helper，点击Install安装，弹出面板中点击Accept</p>
</li>
<li>
<p>重启 IDEA</p>
</li>
</ul>
<p>安装完该插件后可以通过选中项目右键进行相关命令操作。</p>
<h1 id="5-依赖管理"><a class="markdownIt-Anchor" href="#5-依赖管理"></a> 5. 依赖管理</h1>
<h2 id="51-使用坐标引入jar包"><a class="markdownIt-Anchor" href="#51-使用坐标引入jar包"></a> 5.1 使用坐标引入jar包</h2>
<p><strong>使用坐标引入jar包的步骤：</strong></p>
<ul>
<li>
<p>在项目的 pom.xml 中编写 <dependencies> 标签</p>
</li>
<li>
<p>在 <dependencies> 标签中 使用 <dependency> 引入坐标</p>
</li>
<li>
<p>定义坐标的 groupId，artifactId，version</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>
<p>点击刷新按钮，使坐标生效</p>
<img src="/img/maven刷新.png" />
</li>
</ul>
<p><strong>自动导入设置：</strong></p>
<p>上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成</p>
<ul>
<li>
<p>选择 IDEA中 File --&gt; Settings</p>
</li>
<li>
<p>在弹出的面板中找到 Build Tools</p>
</li>
<li>
<p>选择 Any changes，点击 ok 即可生效</p>
</li>
</ul>
<h2 id="52-依赖范围"><a class="markdownIt-Anchor" href="#52-依赖范围"></a> 5.2 依赖范围</h2>
<p>通过设置坐标的依赖范围(scope)，可以设置对应jar包的作用范围：编译环境（在主工程java目录下可以使用依赖）、测试环境（在主工程test目录下可以使用依赖）、运行环境（打包成jar包或者war包后lib中有这个第三方依赖jar包）。</p>
<p>如下图所示给 <code>junit</code> 依赖通过 <code>scope</code> 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么 <code>scope</code> 都可以有哪些取值呢？</p>
<table>
<thead>
<tr>
<th><strong>依赖范围</strong></th>
<th>编译classpath</th>
<th>测试classpath</th>
<th>运行classpath</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>compile</strong>(默认范围)</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>logback</td>
</tr>
<tr>
<td><strong>test</strong></td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>Junit</td>
</tr>
<tr>
<td><strong>provided</strong></td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td><strong>runtime</strong></td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>jdbc驱动</td>
</tr>
<tr>
<td><strong>system</strong></td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>存储在本地的jar包</td>
</tr>
</tbody>
</table>
<ul>
<li>compile(默认范围) ：作用于编译环境、测试环境、运行环境。</li>
<li>test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值</li>
<li>provided ：作用于编译环境、测试环境。我们后面会学习 <code>servlet-api</code> ，在使用它时，必须将 <code>scope</code> 设置为该值，不然运行时就会报错</li>
<li>runtime  ： 作用于测试环境、运行环境。jdbc驱动一般将 <code>scope</code> 设置为该值，当然不设置也没有任何问题</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>如果引入坐标不指定 <code>scope</code> 标签时，默认就是 compile  值。以后大部分jar包都是使用默认值。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Request和Response</title>
    <url>/2023/11/29/Request%E5%92%8CResponse/</url>
    <content><![CDATA[<hr />
<h2 id="requestresponse"><a class="markdownIt-Anchor" href="#requestresponse"></a> Request&amp;Response</h2>
<p><strong>今日目标</strong></p>
<blockquote>
<ul>
<li>掌握Request对象的概念与使用</li>
<li>掌握Response对象的概念与使用</li>
<li>能够完成用户登录注册案例的实现</li>
<li>能够完成SqlSessionFactory工具类的抽取</li>
</ul>
</blockquote>
<h2 id="1request和response的概述"><a class="markdownIt-Anchor" href="#1request和response的概述"></a> 1，Request和Response的概述</h2>
<p>**Request是请求对象，Response是响应对象。**这两个对象在我们使用Servlet的时候有看到。</p>
<p>此时，我们就需要思考一个问题request和response这两个参数的作用是什么？</p>
<ul>
<li>request:<strong>获取请求数据</strong>
<ul>
<li>浏览器会发送HTTP请求到后台服务器[Tomcat]</li>
<li>HTTP的请求中会包含很多请求数据[请求行+请求头+请求体]</li>
<li>后台服务器[Tomcat]会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中</li>
<li>所存入的对象即为request对象，所以我们可以从request对象中获取请求的相关参数</li>
<li>获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务</li>
</ul>
</li>
<li>response:<strong>设置响应数据</strong>
<ul>
<li>业务处理完后，后台就需要给前端返回业务处理的结果即响应数据</li>
<li>把响应数据封装到response对象中</li>
<li>后台服务器[Tomcat]会解析response对象,按照[响应行+响应头+响应体]格式拼接结果</li>
<li>浏览器最终解析结果，把内容展示在浏览器给用户浏览</li>
</ul>
</li>
</ul>
<p>对于上述所讲的内容，我们通过一个案例来初步体验下request和response对象的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo3</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//使用request对象 获取请求数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);<span class="comment">//url?name=lisi</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用response对象 设置响应数据</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;h1&gt;&quot;</span>+name+<span class="string">&quot;,欢迎您！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动成功后就可以通过浏览器来访问，并且根据传入参数的不同就可以在页面上展示不同的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL: localhost:8080/request-demo/demo3?name=lisi</span><br><span class="line">--------------------------------------------</span><br><span class="line">网页显示：lisi，欢迎您！</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<p>在这节中，我们主要认识了下request对象和reponse对象:</p>
<ul>
<li>request对象是用来封装请求数据的对象</li>
<li>response对象是用来封装响应数据的对象</li>
</ul>
<p>目前我们只知道这两个对象是用来干什么的，那么它们具体是如何实现的，就需要我们继续深入的学习。接下来，就先从Request对象来学习,主要学习下面这些内容:</p>
<ul>
<li>
<p>request继承体系</p>
</li>
<li>
<p>request获取请求参数</p>
</li>
<li>
<p>request请求转发</p>
</li>
</ul>
<h2 id="2request对象"><a class="markdownIt-Anchor" href="#2request对象"></a> 2，Request对象</h2>
<h3 id="21-request获取请求数据"><a class="markdownIt-Anchor" href="#21-request获取请求数据"></a> 2.1 Request获取请求数据</h3>
<p>HTTP请求数据总共分为三部分内容，分别是<strong>请求行、请求头、请求体</strong>，对于这三部分内容的数据，分别该如何获取，首先我们先来学习请求行数据如何获取?</p>
<h4 id="211-获取请求行数据"><a class="markdownIt-Anchor" href="#211-获取请求行数据"></a> 2.1.1 获取请求行数据</h4>
<p>请求行包含三块内容，分别是<code>请求方式</code>、<code>请求资源路径</code>、<code>HTTP协议及版本</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET      /request-demo/req1?username=zhangsan   HTTP/1.1</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">请求方式		请求资源路径							HTTP协议及版本</span><br></pre></td></tr></table></figure>
<p>对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下:</p>
<ul>
<li>获取请求方式: <code>GET</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getMethod()</span><br></pre></td></tr></table></figure>
<ul>
<li>获取虚拟目录(项目访问路径): <code>/request-demo</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getContextPath()</span><br></pre></td></tr></table></figure>
<ul>
<li>获取URL(统一资源定位符): <code>http://localhost:8080/request-demo/req1</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer getRequestURL()</span><br></pre></td></tr></table></figure>
<ul>
<li>获取URI(统一资源标识符): <code>/request-demo/req1</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getRequestURI()</span><br></pre></td></tr></table></figure>
<ul>
<li>获取请求参数(GET方式): <code>username=zhangsan&amp;password=123</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getQueryString()</span><br></pre></td></tr></table></figure>
<p>介绍完上述方法后，咱们通过代码把上述方法都使用下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 获取请求数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// String getMethod()：获取请求方式： GET</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        System.out.println(method);<span class="comment">//GET</span></span><br><span class="line">        <span class="comment">// String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> req.getContextPath();</span><br><span class="line">        System.out.println(contextPath);</span><br><span class="line">        <span class="comment">// StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL();</span><br><span class="line">        System.out.println(url.toString());</span><br><span class="line">        <span class="comment">// String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">        <span class="comment">// String getQueryString()：获取请求参数（GET方式）： username=zhangsan</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queryString</span> <span class="operator">=</span> req.getQueryString();</span><br><span class="line">        System.out.println(queryString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务器，访问<code>http://localhost:8080/request-demo/req1?username=zhangsan&amp;passwrod=123</code>，获取的结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET</span><br><span class="line">/request-demo</span><br><span class="line">http://localhost:8080/request-demo/req1</span><br><span class="line">/request-demo/req1</span><br><span class="line">username=zhangsan&amp;password=123</span><br></pre></td></tr></table></figure>
<h4 id="212-获取请求头数据"><a class="markdownIt-Anchor" href="#212-获取请求头数据"></a> 2.1.2 获取请求头数据</h4>
<p>对于请求头的数据，格式为<code>key: value</code>如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent:Mozilla/5.0 Chrome/91.0.4472.106</span><br></pre></td></tr></table></figure>
<p>所以根据请求头名称获取对应值的方法为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getHeader(String name)</span><br></pre></td></tr></table></figure>
<p>接下来，在代码中如果想要获取客户端浏览器的版本信息，则可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 获取请求数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求头: user-agent: 浏览器的版本信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">agent</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;user-agent&quot;</span>);</span><br><span class="line">		System.out.println(agent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重新启动服务器后，<code>http://localhost:8080/request-demo/req1?username=zhangsan&amp;passwrod=123</code>，获取的结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 10.0;Win64;x64)AppleWebKit/537.36 (KHTML,Like  Gecko)Chrome/92.0.4515.131 Safari/537.36</span><br></pre></td></tr></table></figure>
<h4 id="213-获取请求体数据"><a class="markdownIt-Anchor" href="#213-获取请求体数据"></a> 2.1.3 获取请求体数据</h4>
<p>浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=superbaby&amp;password=123</span><br></pre></td></tr></table></figure>
<p>对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是:</p>
<ul>
<li>获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServletInputStream getInputStream()</span><br><span class="line">该方法可以获取字节</span><br></pre></td></tr></table></figure>
<ul>
<li>获取字符输入流，如果前端发送的是纯文本数据，则使用该方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader getReader()</span><br></pre></td></tr></table></figure>
<p>接下来，大家需要思考，要想获取到请求体的内容该如何实现?</p>
<blockquote>
<p>具体实现的步骤如下:</p>
<p>1.准备一个页面，在页面中添加form表单,用来发送post请求</p>
<p>2.在Servlet的doPost方法中获取请求体数据</p>
<p>3.在doPost方法中使用request的getReader()或者getInputStream()来获取</p>
<p>4.访问测试</p>
</blockquote>
<ol>
<li>在项目的webapp目录下添加一个html页面，名称为：<code>req.html</code></li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    action:form表单提交的请求地址</span></span><br><span class="line"><span class="comment">    method:请求方式，指定为post</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/request-demo/req1&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在Servlet的doPost方法中获取数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 获取请求数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//在此处获取请求体中的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 获取请求数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">         <span class="comment">//获取post 请求体：请求参数</span></span><br><span class="line">        <span class="comment">//1. 获取字符输入流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> req.getReader();</span><br><span class="line">        <span class="comment">//2. 读取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>BufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销毁后，BufferedReader流就会自动关闭，所以此处就不需要手动关闭流了。</p>
<ol start="4">
<li>启动服务器，通过浏览器访问<code>http://localhost:8080/request-demo/req.html</code>,分别输入用户名zhangsan和密码123后</li>
</ol>
<p>点击<code>提交</code>按钮后，就可以在控制台看到前端所发送的请求数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制台：</span><br><span class="line">-----------------</span><br><span class="line">username=zhangsan&amp;password=123</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<p>HTTP请求数据中包含了<code>请求行</code>、<code>请求头</code>和<code>请求体</code>，针对这三部分内容，Request对象都提供了对应的API方法来获取对应的值:</p>
<ul>
<li>请求行
<ul>
<li>getMethod()获取请求方式</li>
<li>getContextPath()获取项目访问路径</li>
<li>getRequestURL()获取请求URL</li>
<li>getRequestURI()获取请求URI</li>
<li>getQueryString()获取GET请求方式的请求参数</li>
</ul>
</li>
<li>请求头
<ul>
<li>getHeader(String name)根据请求头名称获取其对应的值</li>
</ul>
</li>
<li>请求体
<ul>
<li>注意: <strong>浏览器发送的POST请求才有请求体</strong></li>
<li>如果是纯文本数据:getReader()</li>
<li>如果是字节数据如文件数据:getInputStream()</li>
</ul>
</li>
</ul>
<h4 id="214-获取请求参数的通用方式"><a class="markdownIt-Anchor" href="#214-获取请求参数的通用方式"></a> 2.1.4 获取请求参数的通用方式</h4>
<p>在学习下面内容之前，我们先提出两个问题:</p>
<ul>
<li>什么是请求参数?</li>
<li>请求参数和请求数据的关系是什么?</li>
</ul>
<p>1.什么是请求参数?</p>
<p>​	为了能更好的回答上述两个问题，我们拿用户登录的例子来说明</p>
<p>​	1.1 想要登录网址，需要进入登录页面</p>
<p>​	1.2 在登录页面输入用户名和密码</p>
<p>​	1.3 将用户名和密码提交到后台</p>
<p>​	1.4 后台校验用户名和密码是否正确</p>
<p>​	1.5 如果正确，则正常登录，如果不正确，则提示用户名或密码错误</p>
<p>​	上述例子中，用户名和密码其实就是我们所说的请求参数。</p>
<p>2.什么是请求数据?</p>
<p>​	请求数据则是包含请求行、请求头和请求体的所有数据</p>
<p>3.请求参数和请求数据的关系是什么?</p>
<p>​	3.1 请求参数是请求数据中的部分内容</p>
<p>​	3.2 如果是GET请求，请求参数在请求行中</p>
<p>​	3.3 如果是POST请求，请求参数一般在请求体中</p>
<p>对于请求参数的获取,常用的有以下两种:</p>
<ul>
<li>GET方式:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getQueryString()</span><br></pre></td></tr></table></figure>
<ul>
<li>POST方式:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader getReader();</span><br></pre></td></tr></table></figure>
<p>有了上述的知识储备，我们来实现一个案例需求:</p>
<p>（1）发送一个GET请求并携带用户名，后台接收后打印到控制台</p>
<p>（2）发送一个POST请求并携带用户名，后台接收后打印到控制台</p>
<p>此处大家需要注意的是GET请求和POST请求接收参数的方式不一样，具体实现的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> req.getQueryString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> req.getReader();</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>对于上述的代码，会存在什么问题呢?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于获取请求参数的方式不一样，导致doGet和doPost中出现了重复代码。</span><br><span class="line">System.out.println(result);这行打印大家可以理解为很多相同的业务代码。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如何解决上述重复代码的问题呢?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求参数</span></span><br><span class="line">        <span class="comment">//将请求参数打印到控制台</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当然，也可以在doGet中调用doPost,在doPost中完成参数的获取和打印,另外需要注意的是，doGet和doPost方法都必须存在，不能删除任意一个。</p>
<p><strong>GET请求和POST请求获取请求参数的方式不一样，在获取请求参数这块该如何实现呢?</strong></p>
<p>要想实现，我们就需要<strong>思考</strong>:</p>
<p>GET请求方式和POST请求方式区别主要在于获取请求参数的方式不一样，是否可以提供一种<strong>统一</strong>获取请求参数的方式，从而<strong>统一</strong>doGet和doPost方法内的代码?</p>
<p>解决方案一（不推荐）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        <span class="comment">//获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line">            params = req.getQueryString();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> req.getReader();</span><br><span class="line">            params = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将请求参数进行打印控制台</span></span><br><span class="line">        System.out.println(params);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用request的getMethod()来获取请求方式，根据请求方式的不同分别获取请求参数值，这样就可以解决上述问题，但是以后每个Servlet都需要这样写代码，实现起来比较麻烦，这种方案我们不采用</p>
<p>解决方案二:</p>
<p>request对象已经将上述获取请求参数的方法进行了封装，并且request提供的方法实现的功能更强大，以后只需要调用request提供的方法即可，在request的方法中都实现了哪些操作?</p>
<p>(1)根据不同的请求方式获取请求参数，获取的内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=zhangsan&amp;hobby=1&amp;hobby=2</span><br></pre></td></tr></table></figure>
<p>(2)把获取到的内容进行分割，内容如下:</p>
<pre><code class="highlight mermaid">graph TB
    A(username=zhangsan&amp;hobby=1&amp;hobby=2)--&gt;B(username=zhangsan)
    A--&gt;C(hobby=1&amp;hobby=2)
    B--&gt;D(username)
    B--&gt;E(zhangsan)
    C--&gt;F(hobby=1)
    C--&gt;G(hobby=2)
    F--&gt;H(hobby)
    F--&gt;I(1)
    G--&gt;J(hobby)
    G--&gt;K(2)</code></pre>
<p>(3)把分割后端数据，存入到一个Map集合中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		Map</span><br><span class="line">username  zhangsan</span><br><span class="line">hobby	  1,2</span><br><span class="line">------------------</span><br><span class="line">Map&lt;String,String[]&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:因为参数的值可能是一个，也可能有多个，所以Map的值的类型为String数组。</p>
<p>基于上述理论，request对象为我们提供了如下方法:</p>
<ul>
<li>获取所有参数Map集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String[]&gt; getParameterMap()</span><br></pre></td></tr></table></figure>
<ul>
<li>根据名称获取参数值（数组）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] getParameterValues(String name)</span><br></pre></td></tr></table></figure>
<ul>
<li>根据名称获取参数值(单个值)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getParameter(String name)</span><br></pre></td></tr></table></figure>
<p>接下来，我们通过案例来把上述的三个方法进行实例演示:</p>
<p>1.修改req.html页面，添加爱好选项，爱好可以同时选多个</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/request-demo/req2&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span> 游泳</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span> 爬山 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.在Servlet代码中获取页面传递GET请求的参数值</p>
<p>2.1获取GET方式的所有请求参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 通用方式获取请求参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//GET请求逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;get....&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 获取所有参数的Map集合</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = req.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">// username:zhangsan lisi</span></span><br><span class="line">            System.out.print(key+<span class="string">&quot;:&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取值</span></span><br><span class="line">            String[] values = map.get(key);</span><br><span class="line">            <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">                System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取的结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get....</span><br><span class="line">username:zhangsan</span><br><span class="line">password:123</span><br><span class="line">hobby:1 2</span><br></pre></td></tr></table></figure>
<p>2.2获取GET请求参数中的爱好，结果是数组值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 通用方式获取请求参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//GET请求逻辑</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        String[] hobbies = req.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String hobby : hobbies) &#123;</span><br><span class="line">            System.out.println(hobby);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取的结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>2.3获取GET请求参数中的用户名和密码，结果是单个值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 通用方式获取请求参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//GET请求逻辑</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取的结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zhangsan</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>3.在Servlet代码中获取页面传递POST请求的参数值</p>
<pre><code>3.1将req.html页面form表单的提交方式改成post
</code></pre>
<p>​	 3.2将doGet方法中的内容复制到doPost方法中即可</p>
<p><strong>小结</strong></p>
<ul>
<li>
<p>req.getParameter()方法使用的频率会比较高</p>
</li>
<li>
<p><strong>以后我们再写代码的时候，就只需要按照如下格式来编写:</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RequestDemo1 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">       //采用request提供的获取请求参数的通用方式来获取请求参数</span><br><span class="line">       //编写其他的业务代码...</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        this.doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-idea快速创建servlet"><a class="markdownIt-Anchor" href="#22-idea快速创建servlet"></a> 2.2 IDEA快速创建Servlet</h3>
<p>使用通用方式获取请求参数后，屏蔽了GET和POST的请求方式代码的不同，则代码可以定义如下格式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于格式固定，所以我们可以使用IDEA提供的模板来制作一个Servlet的模板，这样我们后期在创建Servlet的时候就会更高效，具体步骤看我写的文章<big><strong>实用方法链接与方法</strong></big></p>
<h3 id="23-请求参数中文乱码问题"><a class="markdownIt-Anchor" href="#23-请求参数中文乱码问题"></a> 2.3 请求参数中文乱码问题</h3>
<p>问题展示:</p>
<p>(1)将req.html页面的请求方式修改为get</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;/request-demo/req2&quot; method=&quot;get&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt; 游泳</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt; 爬山 &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>(2)在Servlet方法中获取参数，并打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中文乱码问题解决方案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       <span class="comment">//1. 获取username</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">       System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）启动服务器，页面上的username用户名输入框中输入中文参数</p>
<p>（4）查看控制台打印内容</p>
<p>​		<code>å¼ ä¸</code></p>
<p>（5）把req.html页面的请求方式改成post,再次发送请求和中文参数</p>
<p>（6）查看控制台打印内容，依然为乱码</p>
<p>​	<code>å¼ ä¸</code></p>
<p>通过上面的案例，会发现，不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。具体该如何解决呢？</p>
<h4 id="231-post请求解决方案"><a class="markdownIt-Anchor" href="#231-post请求解决方案"></a> 2.3.1 POST请求解决方案</h4>
<ul>
<li>分析出现中文乱码的原因：
<ul>
<li>POST的请求参数是通过request的getReader()来获取流中的数据</li>
<li>TOMCAT在获取流的时候采用的编码是ISO-8859-1</li>
<li>ISO-8859-1编码是不支持中文的，所以会出现乱码</li>
</ul>
</li>
<li>解决方案：
<ul>
<li>页面设置的编码格式为UTF-8</li>
<li>把TOMCAT在获取流数据之前的编码设置为UTF-8</li>
<li>通过request.setCharacterEncoding(“UTF-8”)设置编码,UTF-8也可以写成小写</li>
</ul>
</li>
</ul>
<p>修改后的代码为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中文乱码问题解决方案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 解决乱码: POST getReader()</span></span><br><span class="line">        <span class="comment">//设置字符输入流的编码，设置的字符集要和页面保持一致</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">       <span class="comment">//2. 获取username</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">       System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新发送POST请求，就会在控制台看到正常展示的中文结果。</p>
<p>至此POST请求中文乱码的问题就已经解决，但是这种方案不适用于GET请求，这个原因是什么呢，咱们下面再分析。</p>
<h4 id="232-get请求解决方案"><a class="markdownIt-Anchor" href="#232-get请求解决方案"></a> 2.3.2 GET请求解决方案</h4>
<p>刚才提到一个问题是<code>POST请求的中文乱码解决方案为什么不适用GET请求？</code></p>
<ul>
<li>GET请求获取请求参数的方式是<code>request.getQueryString()</code></li>
<li>POST请求获取请求参数的方式是<code>request.getReader()</code></li>
<li>request.setCharacterEncoding(“utf-8”)是设置request处理流的编码</li>
<li>getQueryString方法并没有通过流的方式获取数据</li>
</ul>
<p>所以GET请求不能用设置编码的方式来解决中文乱码问题，那问题又来了，如何解决GET请求的中文乱码呢?</p>
<ol>
<li>首先我们需要先分析下GET请求出现乱码的原因:</li>
</ol>
<p><img src="1628829610823.png" alt="1628829610823" /></p>
<p>(1)浏览器通过HTTP协议发送请求和数据给后台服务器（Tomcat)</p>
<p>(2)浏览器在发送HTTP的过程中会对中文数据进行URL<strong>编码</strong></p>
<p>(3)在进行URL编码的时候会采用页面<code>&lt;meta&gt;</code>标签指定的UTF-8的方式进行编码，<code>张三</code>编码后的结果为<code>%E5%BC%A0%E4%B8%89</code></p>
<p>(4)后台服务器(Tomcat)接收到<code>%E5%BC%A0%E4%B8%89</code>后会默认按照<code>ISO-8859-1</code>进行URL<strong>解码</strong></p>
<p>(5)由于前后编码与解码采用的格式不一样，就会导致后台获取到的数据为乱码。</p>
<p>思考: 如果把<code>req.html</code>页面的<code>&lt;meta&gt;</code>标签的charset属性由<code>utf-8</code>改成<code>ISO-8859-1</code>,后台不做操作，能解决中文乱码问题么?</p>
<p>答案是否定的，因为<code>ISO-8859-1</code>本身是不支持中文展示的，所以改了<meta>标签的charset属性后，会导致页面上的中文内容都无法正常展示。</p>
<p>分析完上面的问题后，我们会发现，其中有两个我们不熟悉的内容就是<strong>URL编码</strong>和<strong>URL解码</strong>，什么是URL编码，什么又是URL解码呢?</p>
<p><strong>URL编码</strong></p>
<p>这块知识我们只需要了解下即可,具体编码过程分两步，分别是:</p>
<p>(1)将字符串按照编码方式转为二进制</p>
<p>(2)每个字节转为2个16进制数并在前边加上%</p>
<p><code>张三</code>按照UTF-8的方式转换成二进制的结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001</span><br></pre></td></tr></table></figure>
<p>这个结果是如何计算的?</p>
<p>使用<code>http://www.mytju.com/classcode/tools/encode_utf8.asp</code>，输入<code>张三</code></p>
<p><img src="1628833310474.png" alt="1628833310473" /></p>
<p>就可以获取张和三分别对应的编码10进制，然后在使用计算器，选择程序员模式，可以计算出对应的二进制数据</p>
<p>在计算的十六进制结果中，每两位前面加一个%,就可以获取到<code>%E5%BC%A0%E4%B8%89</code>。</p>
<p>当然你从上面所提供的网站中就已经能看到编码16进制的结果了。</p>
<p>但是对于上面的计算过程，如果没有工具，纯手工计算的话，相对来说还是比较复杂的，我们也不需要进行手动计算，在Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码:</p>
<p>编码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.net.URLEncoder.encode(<span class="string">&quot;需要被编码的内容&quot;</span>,<span class="string">&quot;字符集(UTF-8)&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>解码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.net.URLDecoder.decode(<span class="string">&quot;需要被解码的内容&quot;</span>,<span class="string">&quot;字符集(UTF-8)&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>接下来咱们对<code>张三</code>来进行编码和解码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class URLDemo &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) throws UnsupportedEncodingException &#123;</span><br><span class="line">        String username = &quot;张三&quot;;</span><br><span class="line">        //1. URL编码(模范浏览器编码)</span><br><span class="line">        String encode = URLEncoder.encode(username, &quot;utf-8&quot;);</span><br><span class="line">        System.out.println(encode); //打印:%E5%BC%A0%E4%B8%89</span><br><span class="line"></span><br><span class="line">       //2. URL解码(模仿服务器解码)</span><br><span class="line">       //String decode = URLDecoder.decode(encode, &quot;utf-8&quot;);//打印:张三</span><br><span class="line">       String decode = URLDecoder.decode(encode, &quot;ISO-8859-1&quot;);//打印:`å¼ ä¸ `</span><br><span class="line">       System.out.println(decode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这，我们就可以分析出GET请求中文参数出现乱码的原因了，</p>
<ul>
<li>浏览器把中文参数按照<code>UTF-8</code>进行URL编码</li>
<li>Tomcat对获取到的内容进行了<code>ISO-8859-1</code>的URL解码</li>
<li>在控制台就会出现类上<code>å¼ ä¸</code>的乱码，最后一位是个空格</li>
</ul>
<ol start="2">
<li>清楚了出现乱码的原因，接下来我们就需要想办法进行解决</li>
</ol>
<p><img src="1628846824194.png" alt="1628846824194" /></p>
<p>从上图可以看住，</p>
<ul>
<li>
<p><strong>在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的十六进制值<code>%E5%BC%A0%E4%B8%89</code>是一致的</strong></p>
</li>
<li>
<p><strong>那他们对应的二进制值也是一样的</strong>，为:</p>
<ul>
<li>
<pre class="highlight"><code class="">1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* **为所以我们可以考虑把`å¼ ä¸`转换成字节，在把字节转换成`张三`，在转换的过程中是它们的编码一致，就可以解决中文乱码问题。**</span><br><span class="line"></span><br><span class="line">具体的实现步骤为:</span><br><span class="line"></span><br><span class="line">&gt;1.按照ISO-8859-1编码获取乱码`å¼ ä¸`对应的字节数组</span><br><span class="line">&gt;</span><br><span class="line">&gt;2.按照UTF-8编码获取字节数组对应的字符串</span><br><span class="line"></span><br><span class="line">实现代码如下:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>public class URLDemo {</p>
<p>public static void main(String[] args) throws UnsupportedEncodingException {<br />
String username = “张三”;<br />
//1. URL编码<br />
String encode = URLEncoder.encode(username, “utf-8”);<br />
System.out.println(encode);<br />
//2. URL解码<br />
String decode = URLDecoder.decode(encode, “ISO-8859-1”);</p>
<pre><code>    System.out.println(decode); //此处打印的是对应的乱码数据 å¼ ä¸

    //3. 转换为字节数据,编码
    byte[] bytes = decode.getBytes(&quot;ISO-8859-1&quot;);
    for (byte b : bytes) &#123;
        System.out.print(b + &quot; &quot;);
    &#125;
	//此处打印的是:-27 -68 -96 -28 -72 -119
    //4. 将字节数组转为字符串，解码
    String s = new String(bytes, &quot;utf-8&quot;);
    System.out.println(s); //此处打印的是张三
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**说明**:在第18行中打印的数据是`-27 -68 -96 -28 -72 -119`和`张三`转换成的二进制数据`1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001`为什么不一样呢？因为一个汉字占三个字节，`张三`占据六个字节，正好对应。</span><br><span class="line"></span><br><span class="line">其实打印出来的是十进制数据，我们只需要使用计算机换算下就能得到他们的对应关系，二进制`1110 0101`对应的十进制就是`-27`以此类推。</span><br><span class="line"></span><br><span class="line">至此对于GET请求中文乱码的解决方案，我们就已经分析完了，最后在代码中去实现下:</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * 中文乱码问题解决方案</span><br><span class="line"> */</span><br><span class="line">@WebServlet(&quot;/req4&quot;)</span><br><span class="line">public class RequestDemo4 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //1. 解决乱码：POST，getReader()</span><br><span class="line">        //request.setCharacterEncoding(&quot;UTF-8&quot;);//设置字符输入流的编码</span><br><span class="line"></span><br><span class="line">        //2. 获取username</span><br><span class="line">        String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">        System.out.println(&quot;解决乱码前：&quot;+username);</span><br><span class="line"></span><br><span class="line">        //3. GET,获取参数的方式：getQueryString</span><br><span class="line">        // 乱码原因：tomcat进行URL解码，默认的字符集ISO-8859-1</span><br><span class="line">       /* //3.1 先对乱码数据进行编码：转为字节数组</span><br><span class="line">        byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1);</span><br><span class="line">        //3.2 字节数组解码</span><br><span class="line">        username = new String(bytes, StandardCharsets.UTF_8);*/</span><br><span class="line"></span><br><span class="line">        username  = new String(username.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;解决乱码后：&quot;+username);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        this.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>把<code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>代码注释掉后，会发现GET请求参数乱码解决方案同时也可也把POST请求参数乱码的问题也解决了</li>
<li>只不过对于POST请求参数一般都会比较多，采用这种方式解决乱码起来比较麻烦，所以对于POST请求还是建议使用设置编码的方式进行。</li>
</ul>
<p>另外需要说明一点的是<strong>Tomcat8.0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-8</strong></p>
<p><strong>小结</strong></p>
<ol>
<li>中文乱码解决方案</li>
</ol>
<ul>
<li>
<p>POST请求和GET请求的参数中如果有中文，后台接收数据就会出现中文乱码问题</p>
<p>GET请求在Tomcat8.0以后的版本就不会出现了</p>
</li>
<li>
<p>POST请求解决方案是:设置输入流的编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">注意:设置的字符集要和页面保持一致</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通用方式（GET/POST）：需要先解码，再编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>URL编码实现方式:</li>
</ol>
<ul>
<li>
<p>编码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URLEncoder.encode(str,&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URLDecoder.decode(s,&quot;ISO-8859-1&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="24-request请求转发"><a class="markdownIt-Anchor" href="#24-request请求转发"></a> 2.4 Request请求转发</h3>
<ol>
<li><strong>请求转发(forward):一种在服务器内部的资源跳转方式。</strong></li>
</ol>
<p>(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求</p>
<p>(2)资源A处理完请求后将请求发给资源B</p>
<p>(3)资源B处理完后将结果响应给浏览器</p>
<p>(4)请求从资源A到资源B的过程就叫<strong>请求转发</strong></p>
<ol start="2">
<li>请求转发的实现方式:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);</span><br></pre></td></tr></table></figure>
<p>具体如何来使用，我们先来看下需求:</p>
<p><img src="1628854783523.png" alt="1628854783523" /></p>
<p>针对上述需求，具体的实现步骤为:</p>
<blockquote>
<p>1.创建一个RequestDemo5类，接收/req5的请求，在doGet方法中打印<code>demo5</code></p>
<p>2.创建一个RequestDemo6类，接收/req6的请求，在doGet方法中打印<code>demo6</code></p>
<p>3.在RequestDemo5的方法中使用</p>
<p>​	req.getRequestDispatcher(&quot;/req6&quot;).forward(req,resp)进行请求转发</p>
<p>4.启动测试</p>
</blockquote>
<p>(1)创建RequestDemo5类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求转发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo5</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo5...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)创建RequestDemo6类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求转发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo6</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo6...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)在RequestDemo5的doGet方法中进行请求转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求转发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo5</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo5...&quot;</span>);</span><br><span class="line">        <span class="comment">//请求转发</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/req6&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)启动测试</p>
<p>访问<code>http://localhost:8080/request-demo/req5</code>,就可以在控制台看到如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo5...</span><br><span class="line">demo6...</span><br></pre></td></tr></table></figure>
<p>说明请求已经转发到了<code>/req6</code></p>
<ol start="3">
<li>请求转发资源间共享数据:使用Request对象</li>
</ol>
<p>此处主要解决的问题是把请求从<code>/req5</code>转发到<code>/req6</code>的时候，如何传递数据给<code>/req6</code>。</p>
<p>需要使用request对象提供的三个方法:</p>
<ul>
<li>存储数据到request域[范围,数据是存储在request对象]中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setAttribute(String name,Object o);</span><br></pre></td></tr></table></figure>
<ul>
<li>根据key获取值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object getAttribute(String name);</span><br></pre></td></tr></table></figure>
<ul>
<li>根据key删除该键值对</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void removeAttribute(String name);</span><br></pre></td></tr></table></figure>
<p>接着上个需求来: 在进行请求转发的过程中，如何发送传递一个msg=hello数据从/req5到/req6</p>
<blockquote>
<p>1.在RequestDemo5的doGet方法中转发请求之前，将msg=hello数据存入request域对象中</p>
<p>2.在RequestDemo6的doGet方法从request域对象中获取数据，并将数据打印到控制台</p>
<p>3.启动访问测试</p>
</blockquote>
<p>(1)修改RequestDemo5中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/req5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo5</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo5...&quot;</span>);</span><br><span class="line">        <span class="comment">//存储数据</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">//请求转发</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/req6&quot;</span>).forward(request,response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)修改RequestDemo6中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求转发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo6</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo6...&quot;</span>);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> request.getAttribute(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)启动测试</p>
<p>访问<code>http://localhost:8080/request-demo/req5</code>,就可以在控制台看到如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo5...</span><br><span class="line">demo6...</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>此时就可以实现在转发多个资源之间共享数据。</p>
<ol start="4">
<li>请求转发的特点</li>
</ol>
<ul>
<li>
<p>浏览器地址栏路径不发生变化</p>
<p>虽然后台从<code>/req5</code>转发到<code>/req6</code>,但是浏览器的地址一直是<code>/req5</code>,未发生变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost:8080/request-demo/req5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>只能转发到当前服务器的内部资源</p>
<p>不能从一个服务器通过转发访问另一台服务器</p>
</li>
<li>
<p>一次请求，可以在转发资源间使用request共享数据</p>
<p>虽然后台从<code>/req5</code>转发到<code>/req6</code>，但是这个<strong>只有一次请求</strong></p>
</li>
</ul>
<h2 id="3response对象"><a class="markdownIt-Anchor" href="#3response对象"></a> 3，Response对象</h2>
<p>上面说了</p>
<ul>
<li>Request:使用request对象来<strong>获取</strong>请求数据</li>
<li>Response:使用response对象来<strong>设置</strong>响应数据</li>
</ul>
<p>接下来对于Response我们需要学习如下内容:</p>
<ul>
<li>Response设置响应数据的功能介绍</li>
<li>Response完成重定向</li>
<li>Response响应字符数据</li>
<li>Response响应字节数据</li>
</ul>
<h3 id="31-response设置响应数据功能介绍"><a class="markdownIt-Anchor" href="#31-response设置响应数据功能介绍"></a> 3.1 Response设置响应数据功能介绍</h3>
<p>HTTP响应数据总共分为三部分内容，分别是<strong>响应行、响应头、响应体</strong>，对于这三部分内容的数据，respone对象都提供了哪些方法来进行设置?</p>
<ol>
<li>
<p>响应行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1        200          OK</span><br><span class="line">-----------------------</span><br><span class="line">HTTP协议及版本	响应状态码      状态码的描述</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于响应头，比较常用的就是<strong>设置响应状态码</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setStatus(int sc);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>响应头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type:text/html</span><br><span class="line">     键			值</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>设置响应头键值对：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setHeader(String name,String value);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>响应体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;head&gt;head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于响应体，是通过字符、字节输出流的方式往浏览器写，</p>
<p>获取字符输出流:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintWriter getWriter();</span><br></pre></td></tr></table></figure>
<p>获取字节输出流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServletOutputStream getOutputStream();</span><br></pre></td></tr></table></figure>
<p>介绍完这些方法后，后面我们会通过案例把这些方法都用一用，首先先来完成下重定向的功能开发。</p>
<h3 id="32-respones请求重定向"><a class="markdownIt-Anchor" href="#32-respones请求重定向"></a> 3.2 Respones请求重定向</h3>
<ol>
<li><strong>Response重定向(redirect):一种资源跳转方式。</strong></li>
</ol>
<p><img src="1628859860279.png" alt="1628859860279" /></p>
<p>(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求</p>
<p>(2)资源A现在无法处理该请求，就会给浏览器响应一个302的状态码+location的一个访问资源B的路径</p>
<p>(3)浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B</p>
<p>(4)资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫<strong>重定向</strong></p>
<ol start="2">
<li>重定向的实现方式:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resp.setStatus(302);</span><br><span class="line">resp.setHeader(&quot;location&quot;,&quot;资源B的访问路径&quot;);</span><br></pre></td></tr></table></figure>
<p>具体如何来使用，我们先来看下需求:</p>
<p><img src="1628861030429.png" alt="1628861030429" /></p>
<p>针对上述需求，具体的实现步骤为:</p>
<blockquote>
<p>1.创建一个ResponseDemo1类，接收/resp1的请求，在doGet方法中打印<code>resp1....</code></p>
<p>2.创建一个ResponseDemo2类，接收/resp2的请求，在doGet方法中打印<code>resp2....</code></p>
<p>3.在ResponseDemo1的方法中使用</p>
<p>​	response.setStatus(302);</p>
<p>​	response.setHeader(“Location”,&quot;/request-demo/resp2&quot;) 来给前端响应结果数据</p>
<p>4.启动测试</p>
</blockquote>
<p>(1)创建ResponseDemo1类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/resp1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resp1....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)创建ResponseDemo2类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/resp2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resp2....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)在ResponseDemo1的doGet方法中给前端响应数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/resp1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resp1....&quot;</span>);</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        <span class="comment">//1.设置响应状态码 302</span></span><br><span class="line">        response.setStatus(<span class="number">302</span>);</span><br><span class="line">        <span class="comment">//2. 设置响应头 Location</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;/request-demo/resp2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)启动测试</p>
<p>访问<code>http://localhost:8080/request-demo/resp1</code>,就可以在控制台看到如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resp1...</span><br><span class="line">resp2...</span><br></pre></td></tr></table></figure>
<p>说明<code>/resp1</code>和<code>/resp2</code>都被访问到了。到这重定向就已经完成了。</p>
<p>虽然功能已经实现，但是从设置重定向的两行代码来看，会发现除了重定向的地址不一样，其他的内容都是一模一样，所以request对象给我们提供了简化的编写方式为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resposne.sendRedirect(&quot;/request-demo/resp2&quot;)</span><br></pre></td></tr></table></figure>
<p>所以第3步中的代码就可以简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/resp1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resp1....&quot;</span>);</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        resposne.sendRedirect(<span class="string">&quot;/request-demo/resp2&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>重定向的特点</li>
</ol>
<ul>
<li>
<p>浏览器地址栏路径发送变化</p>
<p>当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost:8080/request-demo/resp1     ---&gt;&gt;&gt;     localhost:8080/request-demo/resp2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以重定向到任何位置的资源(服务内容、外部均可)</p>
<p>因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。</p>
</li>
<li>
<p>两次请求，不能在多个资源使用request共享数据</p>
<p>因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据</p>
</li>
</ul>
<p>介绍完<strong>请求重定向</strong>和<strong>请求转发</strong>以后，接下来需要把这两个放在一块对比下:</p>
<table>
<thead>
<tr>
<th></th>
<th>重定向特点</th>
<th>请求转发特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>浏览器地址栏路径</td>
<td>发生变化</td>
<td>不发生变化</td>
</tr>
<tr>
<td>可重定向位置</td>
<td>任意位置的资源（服务器内部、外部均可）</td>
<td>当前服务器的内部资源</td>
</tr>
<tr>
<td>请求次数</td>
<td>两次请求</td>
<td>一次请求</td>
</tr>
<tr>
<td>request数据共享</td>
<td>不能在多个资源间使用request共享数据</td>
<td>可以在转发的资源间使用request共享数据</td>
</tr>
</tbody>
</table>
<p>以后到底用哪个，还是需要根据具体的业务来决定。</p>
<h3 id="33-路径问题"><a class="markdownIt-Anchor" href="#33-路径问题"></a> 3.3 路径问题</h3>
<ol>
<li>
<p>问题1：转发的时候路径上没有加<code>/request-demo</code>而重定向加了，那么到底什么时候需要加，什么时候不需要加呢?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转发：request.getRequestDispatcher(&quot;/req6&quot;).forward(request,response);</span><br><span class="line"></span><br><span class="line">重定向：response.setHeader(&quot;Location&quot;,&quot;/request-demo/resp2&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其实判断的依据很简单，只需要记住下面的规则即可:</p>
<ul>
<li>浏览器使用:需要加虚拟目录(项目访问路径)</li>
<li>服务端使用:不需要加虚拟目录</li>
</ul>
<p>对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录</p>
<p>对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。</p>
<p>掌握了这个规则，接下来就通过一些练习来强化下知识的学习:</p>
<ul>
<li><code>&lt;a href='路劲'&gt;</code></li>
<li><code>&lt;form action='路径'&gt;</code></li>
<li>req.getRequestDispatcher(“路径”)</li>
<li>resp.sendRedirect(“路径”)</li>
</ul>
<p>答案:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.超链接，从浏览器发送，需要加</span><br><span class="line">2.表单，从浏览器发送，需要加</span><br><span class="line">3.转发，是从服务器内部跳转，不需要加</span><br><span class="line">4.重定向，是由浏览器进行跳转，需要加。</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>问题2：在重定向的代码中，<code>/request-demo</code>是固定编码的，如果后期通过Tomcat插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，该如何优化?</li>
</ol>
<p>答案也比较简单，我们可以在代码中动态去获取项目访问的虚拟目录，具体如何获取，我们可以借助前面咱们所学习的request对象中的getContextPath()方法，修改后的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/resp1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resp1....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简化方式完成重定向</span></span><br><span class="line">        <span class="comment">//动态获取虚拟目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line">        response.sendRedirect(contextPath+<span class="string">&quot;/resp2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新启动访问测试，功能依然能够实现，此时就可以动态获取项目访问的虚拟路径，从而降低代码的耦合度。</p>
<h3 id="34-response响应字符数据"><a class="markdownIt-Anchor" href="#34-response响应字符数据"></a> 3.4 Response响应字符数据</h3>
<p>要想将字符数据写回到浏览器，我们需要两个步骤:</p>
<ul>
<li>
<p>通过Response对象获取字符输出流： PrintWriter writer = resp.getWriter();</p>
</li>
<li>
<p>通过字符输出流写数据: writer.write(“aaa”);</p>
</li>
</ul>
<p>接下来，我们实现通过些案例把响应字符数据给实际应用下:</p>
<ol>
<li>返回一个简单的字符串<code>aaa</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应字符数据：设置字符数据的响应体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/resp3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo3</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 获取字符输出流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">		 writer.write(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL: </span><br><span class="line">	localhost:8080/request-demo/resp3</span><br><span class="line">--------------------------------------</span><br><span class="line">网页展示内容：</span><br><span class="line">	aaa</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>返回一串html字符串，并且能被浏览器解析</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintWriter writer = response.getWriter();</span><br><span class="line">//content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签</span><br><span class="line">response.setHeader(&quot;content-type&quot;,&quot;text/html&quot;);</span><br><span class="line">writer.write(&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL: </span><br><span class="line">	localhost:8080/request-demo/resp3</span><br><span class="line">--------------------------------------</span><br><span class="line">网页展示内容：</span><br><span class="line">	aaa(是被h1放大后的aaa)</span><br></pre></td></tr></table></figure>
<p>**注意:**一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。</p>
<ol start="3">
<li>返回一个中文的字符串<code>你好</code>，需要注意设置响应数据的编码为<code>utf-8</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置响应的数据格式及数据的编码</span><br><span class="line">response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">writer.write(&quot;你好&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL: </span><br><span class="line">	localhost:8080/request-demo/resp3</span><br><span class="line">--------------------------------------</span><br><span class="line">网页展示内容：</span><br><span class="line">	你好</span><br></pre></td></tr></table></figure>
<h3 id="33-response响应字节数据"><a class="markdownIt-Anchor" href="#33-response响应字节数据"></a> 3.3 Response响应字节数据</h3>
<p>要想将字节数据写回到浏览器，我们需要两个步骤:</p>
<ul>
<li>
<p>通过Response对象获取字节输出流：ServletOutputStream outputStream = resp.getOutputStream();</p>
</li>
<li>
<p>通过字节输出流写数据: outputStream.write(字节数据);</p>
</li>
</ul>
<p>接下来，我们实现通过些案例把响应字符数据给实际应用下:</p>
<ol>
<li>返回一个图片文件到浏览器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应字节数据：设置字节数据的响应体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/resp4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d://a.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 获取response字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//3. 完成流的copy</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buff))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，对于流的copy的代码还是比较复杂的，所以我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是:</p>
<p>(1)pom.xml添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(2)调用工具类方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//fis:输入流</span><br><span class="line">//os:输出流</span><br><span class="line">IOUtils.copy(fis,os);</span><br></pre></td></tr></table></figure>
<p>优化后的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应字节数据：设置字节数据的响应体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/resp4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d://a.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 获取response字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//3. 完成流的copy</span></span><br><span class="line">      	IOUtils.copy(fis,os);</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-sqlsessionfactory工具类抽取"><a class="markdownIt-Anchor" href="#4-sqlsessionfactory工具类抽取"></a> 4， SqlSessionFactory工具类抽取</h2>
<p>在写Servlet的时候，可能需要使用Mybatis来完成数据库的操作，所以对于Mybatis的基础操作就出现了些重复代码，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">	<span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure>
<p>有了这些重复代码就会造成一些问题:</p>
<ul>
<li>重复代码不利于后期的维护</li>
<li>SqlSessionFactory工厂类进行重复创建
<ul>
<li>就相当于每次买手机都需要重新创建一个手机生产工厂来给你制造一个手机一样，资源消耗非常大但性能却非常低。所以这么做是不允许的。</li>
</ul>
</li>
</ul>
<p>那如何来优化呢？</p>
<ul>
<li>代码重复可以抽取工具类</li>
<li>对指定代码只需要执行一次可以使用静态代码块</li>
</ul>
<p>有了这两个方向后，代码具体该如何编写?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//静态代码块会随着类的加载而自动执行，且只执行一次</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工具类抽取以后，以后在对Mybatis的SqlSession进行操作的时候，就可以直接使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span>SqlSessionFactoryUtils.getSqlSessionFactory();</span><br></pre></td></tr></table></figure>
<p>这样就可以很好的解决上面所说的代码重复和重复创建工厂导致性能低的问题了。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2023/11/26/Mybatis/</url>
    <content><![CDATA[<h1 id="1-mybatis概述"><a class="markdownIt-Anchor" href="#1-mybatis概述"></a> 1. Mybatis概述</h1>
<h2 id="11-mybatis概念"><a class="markdownIt-Anchor" href="#11-mybatis概念"></a> 1.1 Mybatis概念</h2>
<blockquote>
<p>MyBatis 是一款优秀的<big><strong>持久层框架，用于简化 JDBC 开发</strong></big></p>
</blockquote>
<p><big><strong>[MyBatis官网](<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">mybatis – MyBatis 3 | 入门</a>)</strong></big>，<strong>有教程、依赖安装和配置文件的编写。</strong></p>
<p><strong>持久层：</strong></p>
<blockquote>
<ul>
<li>
<p>负责将数据保存到数据库的那一层代码。</p>
<p>以后开发我们会将操作数据库的Java代码作为持久层。而Mybatis就是对jdbc代码进行了封装。</p>
</li>
<li>
<p>JavaEE三层架构：表现层（负责页面展示）、业务层（负责业务处理）、持久层（负责将数据到保存到数据库）</p>
</li>
</ul>
</blockquote>
<p><strong>框架：</strong></p>
<blockquote>
<ul>
<li>框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型，在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</li>
</ul>
</blockquote>
<h2 id="12-jdbc缺点"><a class="markdownIt-Anchor" href="#12-jdbc缺点"></a> 1.2 JDBC缺点</h2>
<p>下面是 JDBC 代码，我们通过该代码分析都存在什么缺点：</p>
<img src="/img/jdbc缺点.png" />
<ul>
<li>
<p>硬编码</p>
<ul>
<li>
<p>注册驱动、获取连接</p>
<p>上图标1的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。</p>
</li>
<li>
<p>SQL语句</p>
<p>上图标2的代码。如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。</p>
</li>
</ul>
</li>
<li>
<p>操作繁琐</p>
<ul>
<li>
<p>手动设置参数</p>
</li>
<li>
<p>手动封装结果集</p>
<p>上图标4的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。</p>
</li>
</ul>
</li>
</ul>
<h2 id="13-mybatis优点"><a class="markdownIt-Anchor" href="#13-mybatis优点"></a> 1.3 Mybatis优点</h2>
<ul>
<li>
<p>硬编码可以配置到<strong>配置文件</strong></p>
</li>
<li>
<p>操作繁琐的地方mybatis都<strong>自动完成</strong></p>
<p>如图所示：</p>
<img src="/img/mybatis优化.png" />
</li>
</ul>
<h1 id="2-mybatis快速入门"><a class="markdownIt-Anchor" href="#2-mybatis快速入门"></a> 2. MyBatis快速入门</h1>
<p>说实话是不想写了，写这种工具类的不知道有没有意义，只是为了回顾吗，算了，都写到这了。</p>
<p><big><strong><a href="%5B02-MyBatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1Qf4y1T7Hx?p=48&amp;vd_source=2e36878d9aabdc582c635ef654da6eaa)">MyBatis快速入门教学视频</a></strong></big>，这是b站上黑马程序员的视频，本来文档就抄的他的，视频内容大差不差，仅仅一些小内容有改变。</p>
<p><strong>Mybatis快速入门-查询user表中所有数据步骤</strong></p>
<blockquote>
<ol>
<li>
<p>创建user表，添加数据库数据</p>
</li>
<li>
<p>创建Maven模块，在pom.xml中导入MySQL、Mybatis等依赖的坐标</p>
</li>
<li>
<p>编写MyBatis核心配置文件<code>mybatis-config.xml</code>，替换数据库连接地址，用户名和密码等信息，解决硬编码问题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编写SQL映射文件，统一管理SQL语句，解决硬编码问题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id是此sql唯一标识，resultType是执行sql的返回结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编码</p>
<p>(1). 定义pojo类</p>
<p>(2). 加载核心配置文件，获取SqlSessionFactory对象</p>
<p>(3). 获取SqlSession对象，执行SQL语句</p>
<p>(4). 释放资源</p>
</li>
</ol>
</blockquote>
<p><strong>完成后的项目结构为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maven项目</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com.itheima</span><br><span class="line">    │   │       ├── MybatisDemo.java</span><br><span class="line">    |	|		└── pojo</span><br><span class="line">    │   │       	└── User.java</span><br><span class="line">    |	|</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── mybatis-config.xml</span><br><span class="line">    │       └── UserMapper.xml</span><br><span class="line">    │           </span><br><span class="line">    └── test</span><br><span class="line">        ├── java</span><br><span class="line">  		|</span><br><span class="line">        └── resources</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>创建user表，添加数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database mybatis;</span><br><span class="line">use mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	password <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">	addr <span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;234&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;西安&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建模块，导入坐标</p>
<p>在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mysql 驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编写 MyBatis 核心配置文件 – &gt; 替换数据库连接信息，例如数据库连接，用户名和密码等，解决硬编码问题</p>
<p>在模块下的 resources 目录下创建mybatis的配置文件 <code>mybatis-config.xml</code>，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--加载sql映射文件，是resource文件夹下的路径--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编写 SQL 映射文件 --&gt; 统一管理sql语句，解决硬编码问题</p>
<p>在模块的 <code>resources</code> 目录下创建映射配置文件 <code>UserMapper.xml</code>（管理user表就命名为UserMapper.xml，管理order表就命名为OrderMapper.xml），内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	namespace ：名称空间现在不能随意起名字，网上说采用路径+类名可以</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id是此sql唯一标识，resultType是执行sql的返回结果 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编码</p>
<ul>
<li>
<p>在 <code>com.itheima.pojo</code> 包下创建 User类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String addr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略了 setter 和 getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 <code>com.itheima</code> 包下编写 MybatisDemo 测试类并执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;test.selectAll&quot;</span>); <span class="comment">//参数是一个字符串，该字符串必须是映射配置文件的namespace.id</span></span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">//4. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="3-mapper代理开发"><a class="markdownIt-Anchor" href="#3-mapper代理开发"></a> 3. Mapper代理开发</h1>
<p>这一部分写的我很烦，以后不这样写这类工具的使用了，具体的使用教程直接放视频链接或者网址，只写一些大概步骤和要注意的细节问题。</p>
<h2 id="31-mapper代理开发概述"><a class="markdownIt-Anchor" href="#31-mapper代理开发概述"></a> 3.1 Mapper代理开发概述</h2>
<p>之前我们写的代码是基本使用方式，它也存在硬编码的问题，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. 执行sql</span></span><br><span class="line">List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;com.itheima.pojo.User.selectAll&quot;</span>); <span class="comment">//参数是一个字符串，该字符串必须是映射配置文件的namespace.id</span></span><br><span class="line">System.out.println(users);</span><br></pre></td></tr></table></figure>
<p>这里调用 <code>selectList()</code> 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式（如下图）则不存在硬编码问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. 执行sql</span></span><br><span class="line"><span class="comment">//3.1 获取UserMapper接口的代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="comment">//3.2 执行方法,其实就是执行sql语句</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line">System.out.println(users);</span><br></pre></td></tr></table></figure>
<p>通过上面的描述可以看出 Mapper 代理方式的目的：</p>
<ul>
<li>解决原生方式中的硬编码</li>
<li>简化后期执行SQL</li>
</ul>
<h2 id="32-使用mapper代理要求"><a class="markdownIt-Anchor" href="#32-使用mapper代理要求"></a> 3.2 使用Mapper代理要求</h2>
<p><big><strong><a href="%5B04-Mapper%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1Qf4y1T7Hx?p=50&amp;vd_source=2e36878d9aabdc582c635ef654da6eaa)">具体教程视频，强烈推荐</a></strong></big></p>
<p>使用Mapper代理方式，必须满足以下要求：</p>
<ul>
<li>
<ol>
<li><strong>定义与SQL映射文件同名（类似UserMapper.xml）的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下</strong>，通常是改变SQL映射文件（像UserMapper.xml）的路径，通常是在resource文件夹下创建与Mapper接口同级的目录。这里要特别注意是如何在resource文件夹下创建与Mapper接口同级的目录，不同于包名<code>com.itheima</code>这种创建文件夹的形式，这里是<code>com/itheima</code>这种形式来创建文件夹。具体可以看教程视频。</li>
</ol>
</li>
<li>
<ol start="2">
<li>
<p><strong>设置SQL映射文件的namespace属性为Mapper接口全限定名(即接口的路径名)</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<ol start="3">
<li>
<p><strong>在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致，这里要注意返回值，这里是返回很多个数据，所以是List<User>,如果是单个数据返回值就是User</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserMapper.xml内容 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id是此sql唯一标识，resultType是执行sql的返回结果 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于Mapper接口内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.itheima.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.pojo.User;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>; <span class="comment">//这里要注意返回值，这里是返回很多个数据，所以是List&lt;User&gt;,如果是单个数据返回值就是User</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<ul>
<li>
<ol start="4">
<li>
<p><strong>编码</strong></p>
<p>（1）通过SqlSession的getMapper方法获取Mapper接口的代理对象</p>
<p>（2）通过对应方法完成sql执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//3. 执行sql</span></span><br><span class="line"><span class="comment">//3.1 获取UserMapper接口的代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="comment">//3.2 执行方法,其实就是执行sql语句</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line">System.out.println(users);</span><br><span class="line"><span class="comment">//4. 释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p><strong>细节：如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简<br />
化SQL映射文件的加载</strong>，只需将原mybatis-config.xml中加载sql映射文件的部分修改即可。因为首先是写这样的包名很麻烦，二是如果映射文件很多的话也是很麻烦。</p>
<p>修改前：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加载sql的映射文件--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/itheima/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        加载sql的映射文件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="33-案例代码实现"><a class="markdownIt-Anchor" href="#33-案例代码实现"></a> 3.3 案例代码实现</h2>
<ul>
<li>
<p>在 <code>com.itheima.mapper</code> 包下创建 UserMapper接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 <code>resources</code> 下创建 <code>com/itheima/mapper</code> 目录，并在该目录下创建 UserMapper.xml 映射配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    namespace:名称空间。必须是对应接口的全限定名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 <code>com.itheima</code> 包下创建 MybatisDemo2 测试类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mybatis 代理开发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        <span class="comment">//3.1 获取UserMapper接口的代理对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line"></span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">//4. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意：</strong></p>
<p>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用<big><strong>包扫描</strong></big>的方式简化SQL映射文件的加载。也就是将核心配置文件的加载映射配置文件的配置修改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载sql映射文件--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Mapper代理方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="4-mybatis核心配置文件"><a class="markdownIt-Anchor" href="#4-mybatis核心配置文件"></a> 4. MyBatis核心配置文件</h1>
<p>MyBatis核心配置文件 <code>mybatis-config.xml</code>中现有的配置之前已经给大家进行了解释，而核心配置文件中还可以配置很多内容。我们可以通过查询官网看可以配置的内容,<strong>特别注意：configuration中各个属性像typeAliases和mappers他们的相对顺序是固定的，谁在前和谁在后的位置不可以颠倒，颠倒就会报错。</strong></p>
<img src="/img/mybatis核心配置文件.png" style="zoom:80%;" />
<p>接下来我们先对里面的一些配置进行讲解。</p>
<h2 id="41-多环境配置"><a class="markdownIt-Anchor" href="#41-多环境配置"></a> 4.1 多环境配置</h2>
<p>在核心配置文件的 <code>environments</code> 标签中其实是可以配置多个 <code>environment</code> （<strong>类似可以连接不同的数据库</strong>），使用 <code>id</code> 给每段环境起名，在 <code>environments</code> 中使用 <code>default='环境id'</code> 来指定使用哪儿段配置。我们一般就配置一个 <code>environment</code> 即可，开发时<code>default=&quot;development&quot;</code>，测试时改为<code>default=&quot;test&quot;</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span>=</span><br></pre></td></tr></table></figure>
<h2 id="42-类型别名"><a class="markdownIt-Anchor" href="#42-类型别名"></a> 4.2 类型别名</h2>
<p>在映射配置文件（像UserMapper.xml）中的 <code>resultType</code> 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 <code>类型别名</code>(typeAliases) 可以简化这部分的书写。</p>
<p>首先需要现在核心配置文件中配置类型别名，也就意味着<strong>给pojo包下所有的类起了别名（别名就是类名）</strong>，<strong>不区分大小写，类似包扫描</strong>。内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--name属性的值是实体类所在包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.pojo&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过上述的配置，我们就可以简化映射配置文件中 <code>resultType</code> 属性值的编写</p>
<p><strong>没有别名:</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>有别名：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中IOC和DI概念、配置与使用</title>
    <url>/2023/12/11/Spring%E4%B8%ADIOC%E5%92%8CDI%E6%A6%82%E5%BF%B5%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-优势"><a class="markdownIt-Anchor" href="#1-优势"></a> 1. 优势</h2>
<p>Spring框架主要的优势是在<code>简化开发</code>和<code>框架整合</code>上，Spring框架的主要内容:</p>
<ul>
<li>
<p>简化开发: Spring框架中提供了两个大的核心技术，分别是:</p>
<ul>
<li><mark>IOC</mark></li>
<li><mark>AOP</mark>
<ul>
<li><mark>事务处理</mark></li>
</ul>
</li>
</ul>
<p>1.Spring的简化操作都是基于这两块内容,所以这也是Spring学习中最为重要的两个知识点。</p>
<p>2.事务处理属于Spring中AOP的具体应用，可以简化项目中的事务管理，也是Spring技术中的一大亮点。</p>
</li>
<li>
<p>框架整合: Spring在框架整合这块已经做到了极致，它可以整合市面上几乎所有主流框架，比如:</p>
<ul>
<li><mark>MyBatis</mark></li>
<li>MyBatis-plus</li>
<li>Struts</li>
<li>Struts2</li>
<li>Hibernate</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="2-spring相关概念"><a class="markdownIt-Anchor" href="#2-spring相关概念"></a> 2. Spring相关概念</h2>
<h3 id="21-初识spring"><a class="markdownIt-Anchor" href="#21-初识spring"></a> 2.1 初识Spring</h3>
<ul>
<li>
<p>官网：<a href="https://spring.io">https://spring.io</a>，从官网可以大概了解到：</p>
<ul>
<li>Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。</li>
<li>Spring并不是单一的一个技术，而是一个族，可以从官网的<code>Projects</code>中查看其包含的所有技术。</li>
</ul>
</li>
<li>
<p>Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。</p>
<ul>
<li>
<p>Spring已形成了完整的生态圈，也就是说可以完全使用Spring技术完成整个项目的构建、设计与开发。</p>
</li>
<li>
<p>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫<mark>全家桶</mark></p>
<p><strong>说明:</strong></p>
<p>可以进入<code>https://spring.io/projects</code>网站进行查看。</p>
<p>全家桶这些技术并不是所有的都需要学习，额外需要重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code>:</p>
<ul>
<li>Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li>
<li>SpringBoot:Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li>
<li>SpringCloud:这个是用来做分布式之微服务架构的相关开发。</li>
</ul>
<p>本文学习的Spring其实指的是<mark>Spring Framework</mark>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="22-spring系统架构"><a class="markdownIt-Anchor" href="#22-spring系统架构"></a> 2.2 Spring系统架构</h3>
<p>前面说spring指的是Spring Framework,那么它其中都包含哪些内容?</p>
<p>针对这些问题，将从<code>系统架构图</code>来进行说明:</p>
<h4 id="221-系统架构图"><a class="markdownIt-Anchor" href="#221-系统架构图"></a> 2.2.1 系统架构图</h4>
<ul>
<li>
<p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p>
</li>
<li>
<p>Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整</p>
</li>
<li>
<p>Spring Framework的的版本4架构图包括如下部分：</p>
<p>(1)核心层</p>
<ul>
<li>Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li>
</ul>
<p>(2)AOP层</p>
<ul>
<li>AOP:面向切面编程，它依赖核心层容器，目的是<mark>在不改变原有代码的前提下对其进行功能增强</mark></li>
<li>Aspects:AOP是思想,Aspects是对AOP思想的具体实现</li>
</ul>
<p>(3)数据层</p>
<ul>
<li>Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术</li>
<li>Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li>
<li>Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li>
</ul>
<p>(4)Web层</p>
<ul>
<li>这一层的内容将在SpringMVC框架具体学习</li>
</ul>
<p>(5)Test层</p>
<ul>
<li>Spring主要整合了Junit来完成单元测试和集成测试</li>
</ul>
</li>
</ul>
<h3 id="23-spring核心概念"><a class="markdownIt-Anchor" href="#23-spring核心概念"></a> 2.3 Spring核心概念</h3>
<p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code></p>
<h4 id="231-目前项目中的问题"><a class="markdownIt-Anchor" href="#231-目前项目中的问题"></a> 2.3.1 目前项目中的问题</h4>
<p>先分析下目前咱们代码在编写过程中遇到的问题:</p>
<p><img src="1629724206002.png" alt="1629724206002" /></p>
<p>(1)业务层需要调用数据层的方法，就需要在业务层new数据层的对象</p>
<p>(2)如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署</p>
<p>(3)所以，现在代码在编写的过程中存在的问题是：<mark>耦合度偏高</mark></p>
<p>针对这个问题，该如何解决呢?</p>
<p>就想，如果能把框中的内容给去掉，不就可以降低依赖了么，但是又会引入新的问题，去掉以后程序能运行么?</p>
<p>答案肯定是不行，因为bookDao没有赋值为Null，强行运行就会出空指针异常。</p>
<p>所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢?</p>
<p>针对这个问题，Spring就提出了一个解决方案:</p>
<ul>
<li>使用对象时，在程序中不要主动使用new产生对象，转换为由<mark>外部</mark>提供对象</li>
</ul>
<p>这种实现思就是Spring的一个核心概念</p>
<h4 id="232-ioc-ioc容器-bean-di"><a class="markdownIt-Anchor" href="#232-ioc-ioc容器-bean-di"></a> 2.3.2 IOC、IOC容器、Bean、DI</h4>
<ol>
<li><mark>IOC（Inversion of Control）控制反转</mark></li>
</ol>
<p>(1)什么是控制反转呢？</p>
<ul>
<li>使用对象时，由主动new产生对象转换为由<mark>外部</mark>提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。
<ul>
<li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li>
<li>现在自己不new了，交给<code>别人[外部]</code>来创建对象</li>
<li><code>别人[外部]</code>就反转控制了数据层对象的创建权</li>
<li>这种思想就是控制反转</li>
<li>别人[外部]指定是什么呢?继续往下学</li>
</ul>
</li>
</ul>
<p>(2)Spring和IOC之间的关系是什么呢?</p>
<ul>
<li>Spring技术对IOC思想进行了实现</li>
<li>Spring提供了一个容器，称为<mark>IOC容器</mark>，用来充当IOC思想中的&quot;外部&quot;</li>
<li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li>
</ul>
<p>(3)IOC容器的作用以及内部存放的是什么?</p>
<ul>
<li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li>
<li>被创建或被管理的对象在IOC容器中统称为<mark>Bean</mark></li>
<li>IOC容器中放的就是一个个的Bean对象</li>
</ul>
<p>(4)当IOC容器中创建好service和dao对象后，程序能正确执行么?</p>
<ul>
<li>不行，因为service运行需要依赖dao对象</li>
<li>IOC容器中虽然有service和dao对象</li>
<li>但是service对象和dao对象没有任何关系</li>
<li>需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系</li>
</ul>
<p>像这种在容器中建立对象与对象之间的绑定关系就要用到DI:</p>
<ol start="2">
<li><mark>DI（Dependency Injection）依赖注入</mark></li>
</ol>
<p><img src="1629735078619.png" alt="1629735078619" /></p>
<p>(1)什么是依赖注入呢?</p>
<ul>
<li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入
<ul>
<li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li>
<li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li>
<li>这种思想就是依赖注入</li>
</ul>
</li>
</ul>
<p>(2)IOC容器中哪些bean之间要建立依赖关系呢?</p>
<ul>
<li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li>
</ul>
<p>介绍完Spring的IOC和DI的概念后，会发现这两个概念的最终目标就是:<mark>充分解耦</mark>，具体实现靠:</p>
<ul>
<li>使用IOC容器管理bean（IOC)</li>
<li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li>
<li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li>
</ul>
<h4 id="233-核心概念小结"><a class="markdownIt-Anchor" href="#233-核心概念小结"></a> 2.3.3 核心概念小结</h4>
<p>这节比较重要，重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p>
<p>(1)什么IOC/DI思想?</p>
<ul>
<li>IOC:控制反转，控制反转的是对象的创建权</li>
<li>DI:依赖注入，绑定对象与对象之间的依赖关系</li>
</ul>
<p>(2)什么是IOC容器?</p>
<p>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</p>
<p>(3)什么是Bean?</p>
<p>容器中所存放的一个个对象就叫Bean或Bean对象</p>
<h2 id="3-入门案例"><a class="markdownIt-Anchor" href="#3-入门案例"></a> 3. 入门案例</h2>
<p>介绍完Spring的核心概念后，接下来得思考一个问题就是，Spring到底是如何来实现IOC和DI的，那接下来就通过一些简单的入门案例，来演示下具体实现过程:</p>
<h3 id="31-ioc入门案例"><a class="markdownIt-Anchor" href="#31-ioc入门案例"></a> 3.1 IOC入门案例</h3>
<p>对于入门案例，得先<code>分析思路</code>然后再<code>代码实现</code>，</p>
<h4 id="311-入门案例思路分析"><a class="markdownIt-Anchor" href="#311-入门案例思路分析"></a> 3.1.1 入门案例思路分析</h4>
<p>(1)Spring是使用容器来管理bean对象的，那么管什么?</p>
<ul>
<li>主要管理项目中所使用到的类对象，比如(Service和Dao)</li>
</ul>
<p>(2)如何将被管理的对象告知IOC容器?</p>
<ul>
<li>使用配置文件</li>
</ul>
<p>(3)被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?</p>
<ul>
<li>Spring框架提供相应的接口</li>
</ul>
<p>(4)IOC容器得到后，如何从容器中获取bean?</p>
<ul>
<li>调用Spring框架提供对应接口中的方法</li>
</ul>
<p>(5)使用Spring导入哪些坐标?</p>
<ul>
<li>用别人的东西，就需要在pom.xml添加对应的依赖</li>
</ul>
<h4 id="312-入门案例代码实现"><a class="markdownIt-Anchor" href="#312-入门案例代码实现"></a> 3.1.2 入门案例代码实现</h4>
<blockquote>
<p>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</p>
<p>1.创建Maven的java项目</p>
<p>2.pom.xml添加Spring的依赖jar包</p>
<p>3.创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p>
<p>4.resources下添加spring配置文件，并完成bean的配置</p>
<p>5.使用Spring提供的接口完成IOC容器的创建</p>
<p>6.从容器中获取对象进行方法调用</p>
</blockquote>
<h5 id="步骤1创建maven项目"><a class="markdownIt-Anchor" href="#步骤1创建maven项目"></a> 步骤1:创建Maven项目</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-maven-project</span><br><span class="line">    ├── src</span><br><span class="line">    │   ├── main</span><br><span class="line">    │   │   ├── java</span><br><span class="line">    │   │   │   └── ...</span><br><span class="line">    │   │   │       </span><br><span class="line">    │   │   └── resources</span><br><span class="line">    │   │       └── ...</span><br><span class="line">    │   └── test</span><br><span class="line">    │       ├── java</span><br><span class="line">    │       │   └── ...</span><br><span class="line">    ├── pom.xml</span><br></pre></td></tr></table></figure>
<h5 id="步骤2添加spring的依赖jar包"><a class="markdownIt-Anchor" href="#步骤2添加spring的依赖jar包"></a> 步骤2:添加Spring的依赖jar包</h5>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="步骤3添加案例中需要的类"><a class="markdownIt-Anchor" href="#步骤3添加案例中需要的类"></a> 步骤3:添加案例中需要的类</h5>
<p>创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤4添加spring配置文件"><a class="markdownIt-Anchor" href="#步骤4添加spring配置文件"></a> 步骤4:添加spring配置文件</h5>
<p>resources下添加spring的xml配置文件applicationContext.xml，并完成bean的配置</p>
<h5 id="步骤5在配置文件中完成bean的配置"><a class="markdownIt-Anchor" href="#步骤5在配置文件中完成bean的配置"></a> 步骤5:在配置文件中完成bean的配置</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">      id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">      class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><mark>注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复</mark></strong></p>
<h5 id="步骤6获取ioc容器"><a class="markdownIt-Anchor" href="#步骤6获取ioc容器"></a> 步骤6:获取IOC容器</h5>
<p>使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">    	<span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> 	<span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤7从容器中获取对象进行方法调用"><a class="markdownIt-Anchor" href="#步骤7从容器中获取对象进行方法调用"></a> 步骤7:从容器中获取对象进行方法调用</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line"><span class="comment">//        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span></span><br><span class="line"><span class="comment">//        bookDao.save();</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤8运行程序"><a class="markdownIt-Anchor" href="#步骤8运行程序"></a> 步骤8:运行程序</h5>
<p>测试结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book service save ...</span><br><span class="line">boook dao save ...</span><br></pre></td></tr></table></figure>
<p>Spring的IOC入门案例已经完成，但是在<code>BookServiceImpl</code>的类中依然存在<code>BookDaoImpl</code>对象的new操作，它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的<code>DI:依赖注入</code>。</p>
<h3 id="32-di入门案例"><a class="markdownIt-Anchor" href="#32-di入门案例"></a> 3.2 DI入门案例</h3>
<p>对于DI的入门案例，依然先<code>分析思路</code>然后再<code>代码实现</code>，</p>
<h4 id="321-入门案例思路分析"><a class="markdownIt-Anchor" href="#321-入门案例思路分析"></a> 3.2.1 入门案例思路分析</h4>
<p>(1)要想实现依赖注入，必须要基于IOC管理Bean</p>
<ul>
<li>DI的入门案例要依赖于前面IOC的入门案例</li>
</ul>
<p>(2)Service中使用new形式创建的Dao对象是否保留?</p>
<ul>
<li>需要删除掉，最终要使用IOC容器中的bean对象</li>
</ul>
<p>(3)Service中需要的Dao对象如何进入到Service中?</p>
<ul>
<li>在Service中提供方法，让Spring的IOC容器可以通过该方法传入bean对象</li>
</ul>
<p>(4)Service与Dao间的关系如何描述?</p>
<ul>
<li>使用配置文件</li>
</ul>
<h4 id="322-入门案例代码实现"><a class="markdownIt-Anchor" href="#322-入门案例代码实现"></a> 3.2.2 入门案例代码实现</h4>
<blockquote>
<p>需求:基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p>
<p>1.删除业务层中使用new的方式创建的dao对象</p>
<p>2.在业务层提供BookDao的setter方法</p>
<p>3.在配置文件中添加依赖注入的配置</p>
<p>4.运行程序调用方法</p>
</blockquote>
<h5 id="步骤1-去除代码中的new"><a class="markdownIt-Anchor" href="#步骤1-去除代码中的new"></a> 步骤1: 去除代码中的new</h5>
<p>在BookServiceImpl类中，删除业务层中使用new的方式创建的dao对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2为属性提供setter方法"><a class="markdownIt-Anchor" href="#步骤2为属性提供setter方法"></a> 步骤2:为属性提供setter方法</h5>
<p>在BookServiceImpl类中,为BookDao提供setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="步骤3修改配置完成注入"><a class="markdownIt-Anchor" href="#步骤3修改配置完成注入"></a> 步骤3:修改配置完成注入</h5>
<p>在配置文件中添加依赖注入的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">      id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">      class属性表示给bean定义类型  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">            name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">            ref属性表示参照哪一个bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><mark>注意:配置中的两个bookDao的含义是不一样的</mark></p>
<ul>
<li>name=&quot;bookDao&quot;中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li>
<li>ref=&quot;bookDao&quot;中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li>
<li>综上所述，对应关系如下:</li>
</ul>
<p><img src="1629736314989.png" alt="1629736314989" /></p>
<h5 id="步骤4运行程序"><a class="markdownIt-Anchor" href="#步骤4运行程序"></a> 步骤4:运行程序</h5>
<p>运行，测试结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book service save ...</span><br><span class="line">boook dao save ...</span><br></pre></td></tr></table></figure>
<h2 id="4-ioc相关内容"><a class="markdownIt-Anchor" href="#4-ioc相关内容"></a> 4. IOC相关内容</h2>
<p>通过前面两个案例，已经学习了<code>bean如何定义配置</code>，<code>DI如何定义配置</code>以及<code>容器对象如何获取</code>的内容，接下来主要是把这三块内容展开进行详细的讲解，深入的学习下这三部分的内容，首先是bean基础配置。</p>
<h3 id="41-bean基础配置"><a class="markdownIt-Anchor" href="#41-bean基础配置"></a> 4.1 bean基础配置</h3>
<p>对于bean的配置中，主要会讲解<code>bean基础配置</code>,<code>bean的别名配置</code>,<code>bean的作用范围配置</code><mark>(重点)</mark>,这三部分内容：</p>
<h4 id="411-bean基础配置id与class"><a class="markdownIt-Anchor" href="#411-bean基础配置id与class"></a> 4.1.1 bean基础配置(id与class)</h4>
<p>对于bean的基础配置，在前面的案例中已经使用过:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean/&gt;</span><br><span class="line">    &lt;bean&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>其中，bean标签的功能、使用方式以及id和class属性的作用，通过一张图来描述下</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>名称</td>
<td><code>bean</code></td>
</tr>
<tr>
<td>类型</td>
<td>标签</td>
</tr>
<tr>
<td>所属</td>
<td>beans标签</td>
</tr>
<tr>
<td>功能</td>
<td>定义spring核心容器管理的对象</td>
</tr>
<tr>
<td>属性列表</td>
<td>id: bean的id,使用容器可以通过id值获取对应的bean,在一个容器中id值唯一<br/>class: bean的类型，即配置的bean的全路径类名</td>
</tr>
<tr>
<td>范例</td>
<td><code>&lt;bean id=&quot;bookDao&quot;class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;</code><br/><code>&lt;bean id=&quot;bookService&quot;class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;&lt;/bean&gt;</code></td>
</tr>
</tbody>
</table>
<p>这其中需要重点掌握的是:<mark>bean标签的id和class属性的使用</mark>。</p>
<p><strong>思考：</strong></p>
<ul>
<li>class属性能不能写接口如<code>BookDao</code>的类全名呢?</li>
</ul>
<p>答案肯定是不行，因为接口是没办法创建对象的。</p>
<ul>
<li>前面提过为bean设置id时，id必须唯一，但是如果由于命名习惯而产生了分歧后，该如何解决?</li>
</ul>
<p>在解决这个问题之前，需要准备下开发环境，对于开发环境可以有两种解决方案:</p>
<ul>
<li>
<p>使用前面IOC和DI的案例</p>
</li>
<li>
<p>重新搭建一个新的案例环境,目的是方便查阅代码</p>
<ul>
<li>搭建的内容和前面的案例是一样的</li>
</ul>
</li>
</ul>
<h4 id="412-bean的name属性"><a class="markdownIt-Anchor" href="#412-bean的name属性"></a> 4.1.2 bean的name属性</h4>
<p>环境准备好后，接下来就可以在这个环境的基础上来学习下bean的别名配置，</p>
<p>首先来看下别名的配置说明:</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>名称</td>
<td><code>name</code></td>
</tr>
<tr>
<td>类型</td>
<td>属性</td>
</tr>
<tr>
<td>所属</td>
<td>bean标签</td>
</tr>
<tr>
<td>功能</td>
<td>定义bean的别名，可定义多个，使用逗号，分号，空格进行分隔</td>
</tr>
<tr>
<td>范例</td>
<td><code>&lt;bean id=&quot;bookDao&quot; name=&quot;dao bookDaoImpl&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;</code><br/><code>&lt;bean id=&quot;bookService&quot; name=&quot;service,bookServiceImpl&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;&lt;/bean&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="步骤1配置别名"><a class="markdownIt-Anchor" href="#步骤1配置别名"></a> 步骤1：配置别名</h5>
<p>打开spring的配置文件applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service service4 bookEbi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>说明:Ebi全称Enterprise Business Interface，翻译为企业业务接口</strong></p>
<h5 id="步骤2根据名称容器中获取bean对象"><a class="markdownIt-Anchor" href="#步骤2根据名称容器中获取bean对象"></a> 步骤2:根据名称容器中获取bean对象</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForName</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//此处根据bean标签的id属性和name属性的任意一个值来获取bean对象</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;service4&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤3运行程序"><a class="markdownIt-Anchor" href="#步骤3运行程序"></a> 步骤3:运行程序</h5>
<p>测试结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book service save ...</span><br><span class="line">boook dao save ...</span><br></pre></td></tr></table></figure>
<p><mark>注意事项:</mark></p>
<ul>
<li>
<p>bean依赖注入的ref属性指定bean，必须在容器中存在</p>
</li>
<li>
<p>如果不存在,则会报错，这个错误需要特别关注下:</p>
<p><strong>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常<mark>NoSuchBeanDefinitionException</mark></strong></p>
</li>
</ul>
<h4 id="413-bean作用范围scope配置"><a class="markdownIt-Anchor" href="#413-bean作用范围scope配置"></a> 4.1.3 bean作用范围scope配置</h4>
<p>关于bean的作用范围是bean属性配置的一个<mark>重点</mark>内容。</p>
<p>看到这个作用范围，就得思考bean的作用范围是来控制bean哪块内容的?</p>
<p>先来看下<code>bean作用范围的配置属性</code>:</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>名称</td>
<td><code>scope</code></td>
</tr>
<tr>
<td>类型</td>
<td>属性</td>
</tr>
<tr>
<td>所属</td>
<td>bean标签</td>
</tr>
<tr>
<td>功能</td>
<td>定义bean的作用范围，可选范围如下：<br />1. singleton: 单例（默认）<br />2. prototype: 非单例</td>
</tr>
<tr>
<td>范例</td>
<td><code>&lt;bean id=&quot;bookDao&quot;class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="4131-验证ioc容器中对象是否为单例"><a class="markdownIt-Anchor" href="#4131-验证ioc容器中对象是否为单例"></a> 4.1.3.1 验证IOC容器中对象是否为单例</h5>
<h6 id="验证思路"><a class="markdownIt-Anchor" href="#验证思路"></a> 验证思路</h6>
<p>同一个bean获取两次，将对象打印到控制台，看打印出的地址值是否一致。</p>
<h6 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现"></a> 具体实现</h6>
<ul>
<li>
<p>创建一个AppForScope的类，在其main方法中来验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>打印，观察控制台的打印结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.dao.impl.BookDaoImpl@5025a98f</span><br><span class="line">com.itheima.dao.impl.BookDaoImpl@5025a98f</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结论:默认情况下，Spring创建的bean对象都是单例的</p>
</li>
</ul>
<p>获取到结论后，问题就来了，那如果我想创建出来非单例的bean对象，该如何实现呢?</p>
<h5 id="4132-配置bean为非单例"><a class="markdownIt-Anchor" href="#4132-配置bean为非单例"></a> 4.1.3.2 配置bean为非单例</h5>
<p>在Spring配置文件中，配置scope属性来实现bean的非单例创建</p>
<ul>
<li>
<p>在Spring的配置文件中，修改<code>&lt;bean&gt;</code>的scope属性，将scope设置为<code>singleton</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行AppForScope，打印看结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.dao.impl.BookDaoImpl@5025a98f</span><br><span class="line">com.itheima.dao.impl.BookDaoImpl@5025a98f</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将scope设置为<code>prototype</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>运行AppForScope，打印看结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.dao.impl.BookDaoImpl@5025a98f</span><br><span class="line">com.itheima.dao.impl.BookDaoImpl@49993335</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结论，使用bean的<code>scope</code>属性可以控制bean的创建是否为单例：</p>
<ul>
<li><code>singleton</code>默认为单例</li>
<li><code>prototype</code>为非单例</li>
</ul>
</li>
</ul>
<h5 id="4133-scope使用后续思考"><a class="markdownIt-Anchor" href="#4133-scope使用后续思考"></a> 4.1.3.3 scope使用后续思考</h5>
<p>介绍完<code>scope</code>属性以后，来思考几个问题:</p>
<ul>
<li>为什么bean默认为单例?
<ul>
<li>bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象</li>
<li>bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高</li>
</ul>
</li>
<li>bean在容器中是单例的，会不会产生线程安全问题?
<ul>
<li>如果对象是有状态对象，即该对象有成员变量可以用来存储数据的，</li>
<li>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</li>
<li>如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的，</li>
<li>因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。</li>
</ul>
</li>
<li>哪些bean对象适合交给容器进行管理?
<ul>
<li>表现层对象</li>
<li>业务层对象</li>
<li>数据层对象</li>
<li>工具对象</li>
</ul>
</li>
<li>哪些bean对象不适合交给容器进行管理?
<ul>
<li>封装实例的域对象，因为会引发线程安全问题，所以不适合。</li>
</ul>
</li>
</ul>
<h4 id="414-bean基础配置小结"><a class="markdownIt-Anchor" href="#414-bean基础配置小结"></a> 4.14 bean基础配置小结</h4>
<p>关于bean的基础配置中，需要掌握以下属性:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;bean的唯一标识&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;bean的类全名&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scope</span>=<span class="string">&quot;bean的作用范围，有singleton(默认)和prototype&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;为bean取的别名&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="42-bean实例化"><a class="markdownIt-Anchor" href="#42-bean实例化"></a> 4.2 bean实例化</h3>
<p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p>
<p>就需要研究下<code>bean的实例化过程</code>，在这块内容中主要解决两部分内容，分别是</p>
<ul>
<li>bean是如何创建的</li>
<li>实例化bean的三种方式，<code>构造方法</code>,<code>静态工厂</code>和<code>实例工厂</code></li>
</ul>
<p>在讲解这三种创建方式之前，需要先确认一件事:</p>
<p><mark>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的</mark>。</p>
<p>基于这个知识点出发，来验证spring中bean的三种创建方式，</p>
<h4 id="421-环境准备"><a class="markdownIt-Anchor" href="#421-环境准备"></a> 4.2.1 环境准备</h4>
<p>为了方便阅读代码，重新准备个开发环境，</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，可以快速的拷贝即可:</p>
<h4 id="422-构造方法实例化"><a class="markdownIt-Anchor" href="#422-构造方法实例化"></a> 4.2.2 构造方法实例化</h4>
<p>在上述的环境下，来研究下Spring中的第一种bean的创建方式<code>构造方法实例化</code>:</p>
<h5 id="步骤1准备需要被创建的类"><a class="markdownIt-Anchor" href="#步骤1准备需要被创建的类"></a> 步骤1:准备需要被创建的类</h5>
<p>准备一个BookDao和BookDaoImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2将类配置到spring容器"><a class="markdownIt-Anchor" href="#步骤2将类配置到spring容器"></a> 步骤2:将类配置到Spring容器</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="步骤3编写运行程序"><a class="markdownIt-Anchor" href="#步骤3编写运行程序"></a> 步骤3:编写运行程序</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤4类中提供构造函数测试"><a class="markdownIt-Anchor" href="#步骤4类中提供构造函数测试"></a> 步骤4:类中提供构造函数测试</h5>
<p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book dao constructor is running ....</span><br><span class="line">book dao save ...</span><br></pre></td></tr></table></figure>
<h5 id="步骤5将构造函数改成private测试"><a class="markdownIt-Anchor" href="#步骤5将构造函数改成private测试"></a> 步骤5:将构造函数改成private测试</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，能执行成功,说明内部走的依然是构造函数,能访问到类中的私有构造方法,显而易见Spring底层用的是反射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book dao constructor is running ....</span><br><span class="line">book dao save ...</span><br></pre></td></tr></table></figure>
<h5 id="步骤6构造函数中添加一个参数测试"><a class="markdownIt-Anchor" href="#步骤6构造函数中添加一个参数测试"></a> 步骤6:构造函数中添加一个参数测试</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，</p>
<p>程序会报错，说明Spring底层使用的是类的无参构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.&lt;init&gt;()</span><br><span class="line"></span><br><span class="line">Caused by: java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.&lt;init&gt;()</span><br></pre></td></tr></table></figure>
<h4 id="423-分析spring的错误信息"><a class="markdownIt-Anchor" href="#423-分析spring的错误信息"></a> 4.2.3 分析Spring的错误信息</h4>
<p>接下来，主要研究下Spring的报错信息来学一学如阅读。</p>
<ul>
<li>错误信息从下往上依次查看，因为<mark>上面的错误大都是对下面错误的一个包装，最核心错误是在最下面</mark></li>
<li>Caused by: java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()
<ul>
<li>Caused by 翻译为<code>引起</code>，即出现错误的原因</li>
<li>java.lang.NoSuchMethodException:抛出的异常为<code>没有这样的方法异常</code></li>
<li>com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>():哪个类的哪个方法没有被找到导致的异常，<code>&lt;init&gt;</code>()指定是类的构造方法，即该类的无参构造方法</li>
</ul>
</li>
</ul>
<p>如果最后一行错误获取不到错误信息，接下来查看第二层:</p>
<p>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()</p>
<ul>
<li>nested:嵌套的意思，后面的异常内容和最底层的异常是一致的</li>
<li>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found;
<ul>
<li>Caused by: <code>引发</code></li>
<li>BeanInstantiationException:翻译为<code>bean实例化异常</code></li>
<li>No default constructor found:没有一个默认的构造函数被发现</li>
</ul>
</li>
</ul>
<p>至此，关于Spring的构造方法实例化就已经学习完了，因为每一个类默认都会提供一个无参构造函数，所以其实真正在使用这种方式的时候，什么也不需要做。这也是以后比较常用的一种方式。</p>
<h4 id="424-静态工厂实例化了解即可这里省略"><a class="markdownIt-Anchor" href="#424-静态工厂实例化了解即可这里省略"></a> 4.2.4 静态工厂实例化(了解即可，这里省略)</h4>
<h4 id="425-实例工厂与factorybean了解即可这里省略"><a class="markdownIt-Anchor" href="#425-实例工厂与factorybean了解即可这里省略"></a> 4.2.5 实例工厂与FactoryBean(了解即可，这里省略)</h4>
<h4 id="426-bean实例化小结"><a class="markdownIt-Anchor" href="#426-bean实例化小结"></a> 4.2.6 bean实例化小结</h4>
<p>通过这一节的学习，需要掌握:</p>
<p>(1)bean是如何创建的呢?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造方法</span><br></pre></td></tr></table></figure>
<p>(2)Spring的IOC实例化对象的三种方式分别是:</p>
<ul>
<li>构造方法(常用)</li>
<li>静态工厂(了解)</li>
<li>实例工厂(了解)</li>
</ul>
<p>这些方式中，重点掌握<code>构造方法</code>即可。</p>
<p>需要注意的一点是，构造方法在类中默认会提供，但是如果重写了构造方法，默认的就会消失，在使用的过程中需要注意，如果需要重写构造方法，最好把默认的构造方法也重写下。</p>
<h3 id="43-bean的生命周期"><a class="markdownIt-Anchor" href="#43-bean的生命周期"></a> 4.3 bean的生命周期</h3>
<p>关于bean的相关知识还有最后一个是<code>bean的生命周期</code>,对于生命周期，主要围绕着<code>bean生命周期控制</code>来讲解:</p>
<ul>
<li>首先理解下什么是生命周期?
<ul>
<li>从创建到消亡的完整过程,例如人从出生到死亡的整个过程就是一个生命周期。</li>
</ul>
</li>
<li>bean生命周期是什么?
<ul>
<li>bean对象从创建到销毁的整体过程。</li>
</ul>
</li>
<li>bean生命周期控制是什么?
<ul>
<li>在bean创建后到销毁前做一些事情。</li>
</ul>
</li>
</ul>
<p>现在面临的问题是如何在bean的创建之后和销毁之前把需要添加的内容添加进去。</p>
<h4 id="431-环境准备"><a class="markdownIt-Anchor" href="#431-环境准备"></a> 4.3.1 环境准备</h4>
<p>还是老规矩，为了方便后期代码的阅读，重新搭建下环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，可以快速的拷贝即可:</p>
<p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(3)编写AppForLifeCycle运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForLifeCycle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">          <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="432-生命周期设置"><a class="markdownIt-Anchor" href="#432-生命周期设置"></a> 4.3.2 生命周期设置</h4>
<p>接下来，在上面这个环境中来为BookDao添加生命周期的控制方法，具体的控制有两个阶段:</p>
<ul>
<li>bean创建之后，想要添加内容，比如用来初始化需要用到资源</li>
<li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li>
</ul>
<h5 id="步骤1添加初始化和销毁方法"><a class="markdownIt-Anchor" href="#步骤1添加初始化和销毁方法"></a> 步骤1:添加初始化和销毁方法</h5>
<p>针对这两个阶段，在BooDaoImpl类中分别添加两个方法，<mark>方法名任意</mark></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean初始化对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean销毁前对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2配置生命周期"><a class="markdownIt-Anchor" href="#步骤2配置生命周期"></a> 步骤2:配置生命周期</h5>
<p>在配置文件添加配置，如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="步骤3运行程序-2"><a class="markdownIt-Anchor" href="#步骤3运行程序-2"></a> 步骤3:运行程序</h5>
<p>运行AppForLifeCycle打印结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init...</span><br><span class="line">book dao save ...</span><br></pre></td></tr></table></figure>
<p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p>
<ul>
<li>Spring的IOC容器是运行在JVM中</li>
<li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li>
<li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li>
<li>所以没有调用对应的destroy方法</li>
</ul>
<p>知道了出现问题的原因，具体该如何解决呢?</p>
<h4 id="433-close关闭容器"><a class="markdownIt-Anchor" href="#433-close关闭容器"></a> 4.3.3 close关闭容器</h4>
<ul>
<li>
<p>ApplicationContext中没有close方法</p>
</li>
<li>
<p>需要将ApplicationContext更换成ClassPathXmlApplicationContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">    <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调用ctx的close()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctx.close();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行程序，就能执行destroy方法的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init...</span><br><span class="line">book dao save ...</span><br><span class="line">destory...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="434-注册钩子关闭容器"><a class="markdownIt-Anchor" href="#434-注册钩子关闭容器"></a> 4.3.4 注册钩子关闭容器</h4>
<ul>
<li>
<p>除了显式地调用<code>close()</code>方法外，还可以注册关闭钩子，让JVM在退出之前自动关闭Spring容器。这可以通过调用<code>registerShutdownHook()</code>方法来实现。</p>
</li>
<li>
<p>调用ctx的registerShutdownHook()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctx.registerShutdownHook(); //当JVM关闭时，会自动调用容器的close()方法以执行清理操作。</span><br></pre></td></tr></table></figure>
<p>**注意:**registerShutdownHook在ApplicationContext中也没有</p>
</li>
<li>
<p>运行后，查询打印结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init...</span><br><span class="line">book dao save ...</span><br><span class="line">destory...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两种方式介绍完后，<code>close</code>和<code>registerShutdownHook</code>选哪个?</p>
<p>相同点:这两种都能用来关闭容器</p>
<p>不同点:<code>close()</code>是在调用的时候关闭，<code>registerShutdownHook()</code>是在JVM退出前调用关闭。</p>
<p>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</p>
<p>Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></p>
<p>接下来在BookServiceImpl完成这两个接口的使用:</p>
<p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新运行AppForLifeCycle类，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init...</span><br><span class="line">service init</span><br><span class="line">book dao save ...</span><br><span class="line">service destroy</span><br><span class="line">destory...</span><br></pre></td></tr></table></figure>
<p>那第二种方式的实现，也介绍完了。</p>
<p><strong>小细节</strong></p>
<ul>
<li>
<p>对于<code>InitializingBean</code>接口中的<code>afterPropertiesSet</code>方法，翻译过来为<code>属性设置之后</code>。</p>
</li>
<li>
<p>对于<code>BookServiceImpl</code>来说，<code>bookDao</code>是它的一个属性</p>
</li>
<li>
<p>setBookDao方法是Spring的IOC容器为其注入属性的方法</p>
</li>
<li>
<p>思考:afterPropertiesSet和setBookDao谁先执行?</p>
<ul>
<li>
<p>从方法名分析，猜想应该是setBookDao方法先执行</p>
</li>
<li>
<p>验证思路，在setBookDao方法中添加一句话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;set .....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重新运行AppForLifeCycle，打印结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init...</span><br><span class="line">set .....</span><br><span class="line">service init</span><br><span class="line">book dao save ...</span><br><span class="line">service destroy</span><br><span class="line">destory...</span><br></pre></td></tr></table></figure>
<p>验证的结果和猜想的结果是一致的，所以初始化方法会在类中属性设置之后执行。</p>
</li>
</ul>
</li>
</ul>
<h4 id="435-bean生命周期小结"><a class="markdownIt-Anchor" href="#435-bean生命周期小结"></a> 4.3.5 bean生命周期小结</h4>
<p>(1)关于Spring中对bean生命周期控制提供了两种方式:</p>
<ul>
<li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li>
<li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口，这种方式<mark>了解下即可</mark>。</li>
</ul>
<p>(2)对于bean的生命周期控制在bean的整个生命周期中所处的位置如下:</p>
<ul>
<li>初始化容器
<ul>
<li>1.创建对象(内存分配)</li>
<li>2.执行构造方法</li>
<li>3.执行属性注入(set操作)</li>
<li><mark>4.执行bean初始化方法</mark></li>
</ul>
</li>
<li>使用bean
<ul>
<li>1.执行业务操作</li>
</ul>
</li>
<li>关闭/销毁容器
<ul>
<li><mark>1.执行bean销毁方法</mark></li>
</ul>
</li>
</ul>
<p>(3)关闭容器的两种方式:</p>
<ul>
<li>
<p>手工关闭容器：</p>
<p><code>ConfigurableApplicationContext</code>接口<code>close()</code>方法</p>
</li>
</ul>
<ul>
<li>
<p>注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机:</p>
<p><code>ConfigurableApplicationContext</code>接口<code>registerShutdownHook()</code>方法</p>
</li>
</ul>
<h2 id="5-di相关内容"><a class="markdownIt-Anchor" href="#5-di相关内容"></a> 5. DI相关内容</h2>
<p>前面已经完成了bean相关操作的讲解，接下来就进入第二个大的模块<code>DI依赖注入</code>，首先来介绍下Spring中有哪些注入方式?</p>
<p>先来思考</p>
<ul>
<li>向一个类中传递数据的方式有几种?
<ul>
<li>普通方法(set方法)</li>
<li>构造方法</li>
</ul>
</li>
<li>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?
<ul>
<li>引用类型</li>
<li>简单类型(基本数据类型与String)</li>
</ul>
</li>
</ul>
<p>Spring就是基于上面这些知识点，为提供了两种注入方式，分别是:</p>
<ul>
<li>setter注入
<ul>
<li>简单类型</li>
<li><mark>引用类型</mark></li>
</ul>
</li>
<li>构造器注入
<ul>
<li>简单类型</li>
<li>引用类型</li>
</ul>
</li>
</ul>
<p>依赖注入的方式已经介绍完，接下来挨个学习下:</p>
<h3 id="51-setter注入"><a class="markdownIt-Anchor" href="#51-setter注入"></a> 5.1 setter注入</h3>
<ol>
<li>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</li>
</ol>
<ul>
<li>在bean中定义引用类型属性，并提供可访问的<mark>set</mark>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置中使用<mark>property</mark>标签<mark>ref</mark>属性注入引用类型对象</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.imipl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="511-环境准备"><a class="markdownIt-Anchor" href="#511-环境准备"></a> 5.1.1 环境准备</h4>
<p>为了更好的学习下面内容，依旧准备一个新环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，可以快速的拷贝即可:</p>
<p>(1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(3)编写AppForDISet运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDISet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在上面这个环境中来完成setter注入的学习:</p>
<h4 id="512-注入引用数据类型"><a class="markdownIt-Anchor" href="#512-注入引用数据类型"></a> 5.1.2 注入引用数据类型</h4>
<blockquote>
<p>需求:在bookServiceImpl对象中注入userDao</p>
<p>1.在BookServiceImpl中声明userDao属性</p>
<p>2.为userDao属性提供setter方法</p>
<p>3.在配置文件中使用property标签注入</p>
</blockquote>
<h5 id="步骤1声明属性并提供setter方法"><a class="markdownIt-Anchor" href="#步骤1声明属性并提供setter方法"></a> 步骤1:声明属性并提供setter方法</h5>
<p>在BookServiceImpl中声明userDao属性，并提供setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2配置文件中进行注入配置"><a class="markdownIt-Anchor" href="#步骤2配置文件中进行注入配置"></a> 步骤2:配置文件中进行注入配置</h5>
<p>在applicationContext.xml配置文件中使用property标签注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="步骤3运行程序-3"><a class="markdownIt-Anchor" href="#步骤3运行程序-3"></a> 步骤3:运行程序</h5>
<p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book service save ...</span><br><span class="line">book dao save ...</span><br><span class="line">user dao save ...</span><br></pre></td></tr></table></figure>
<h4 id="513-注入简单数据类型"><a class="markdownIt-Anchor" href="#513-注入简单数据类型"></a> 5.1.3 注入简单数据类型</h4>
<blockquote>
<p>需求：给BookDaoImpl注入一些简单数据类型的数据</p>
<p>参考引用数据类型的注入，可以推出具体的步骤为:</p>
<p>1.在BookDaoImpl类中声明对应的简单数据类型的属性</p>
<p>2.为这些属性提供对应的setter方法</p>
<p>3.在applicationContext.xml中配置</p>
</blockquote>
<p><strong>思考:</strong></p>
<p>引用类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>,简单数据类型还是使用ref么?</p>
<p>ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置?</p>
<h5 id="步骤1声明属性并提供setter方法-2"><a class="markdownIt-Anchor" href="#步骤1声明属性并提供setter方法-2"></a> 步骤1:声明属性并提供setter方法</h5>
<p>在BookDaoImpl类中声明对应的简单数据类型的属性,并提供对应的setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionNum</span><span class="params">(<span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDatabaseName</span><span class="params">(String databaseName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2配置文件中进行注入配置-2"><a class="markdownIt-Anchor" href="#步骤2配置文件中进行注入配置-2"></a> 步骤2:配置文件中进行注入配置</h5>
<p>在applicationContext.xml配置文件中使用property标签注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>value:后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写成</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样的话，spring在将<code>abc</code>转换成int类型的时候就会报错。</p>
<h5 id="步骤3运行程序-4"><a class="markdownIt-Anchor" href="#步骤3运行程序-4"></a> 步骤3:运行程序</h5>
<p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book service save ...</span><br><span class="line">book dao save ...mysql,10</span><br><span class="line">user dao save ...</span><br></pre></td></tr></table></figure>
<p>**注意:**两个property注入标签的顺序可以任意。</p>
<p>对于setter注入方式的基本使用就已经介绍完了，</p>
<ul>
<li>对于引用数据类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code></li>
<li>对于简单数据类型使用的是<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li>
</ul>
<h3 id="52-构造器注入"><a class="markdownIt-Anchor" href="#52-构造器注入"></a> 5.2 构造器注入</h3>
<h4 id="521-环境准备"><a class="markdownIt-Anchor" href="#521-环境准备"></a> 5.2.1 环境准备</h4>
<p>构造器注入也就是构造方法注入，学习之前，还是先准备下环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，可以快速的拷贝即可:</p>
<p>(1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(3)编写AppForDIConstructor运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDIConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="522-构造器注入引用数据类型"><a class="markdownIt-Anchor" href="#522-构造器注入引用数据类型"></a> 5.2.2 构造器注入引用数据类型</h4>
<p>接下来，在上面这个环境中来完成构造器注入的学习:</p>
<blockquote>
<p>需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p>
<p>1.将bookDao的setter方法删除掉</p>
<p>2.添加带有bookDao参数的构造方法</p>
<p>3.在applicationContext.xml中配置</p>
</blockquote>
<h5 id="步骤1删除setter方法并提供构造方法"><a class="markdownIt-Anchor" href="#步骤1删除setter方法并提供构造方法"></a> 步骤1:删除setter方法并提供构造方法</h5>
<p>在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2配置文件中进行配置构造方式注入"><a class="markdownIt-Anchor" href="#步骤2配置文件中进行配置构造方式注入"></a> 步骤2:配置文件中进行配置构造方式注入</h5>
<p>在applicationContext.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>标签<constructor-arg>中</p>
<ul>
<li>
<p>name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。</p>
</li>
<li>
<p>ref属性指向的是spring的IOC容器中其他bean对象。</p>
</li>
</ul>
<h5 id="步骤3运行程序-5"><a class="markdownIt-Anchor" href="#步骤3运行程序-5"></a> 步骤3：运行程序</h5>
<p>运行AppForDIConstructor类，查看结果，说明bookDao已经成功注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book service save ...</span><br><span class="line">book dao save ...</span><br></pre></td></tr></table></figure>
<h4 id="523-构造器注入多个引用数据类型"><a class="markdownIt-Anchor" href="#523-构造器注入多个引用数据类型"></a> 5.2.3 构造器注入多个引用数据类型</h4>
<blockquote>
<p>需求:在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p>
<p>1.声明userDao属性</p>
<p>2.生成一个带有bookDao和userDao参数的构造函数</p>
<p>3.在applicationContext.xml中配置注入</p>
</blockquote>
<h5 id="步骤1提供多个属性的构造函数"><a class="markdownIt-Anchor" href="#步骤1提供多个属性的构造函数"></a> 步骤1:提供多个属性的构造函数</h5>
<p>在BookServiceImpl声明userDao并提供多个参数的构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao,UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤2:配置文件中配置多参数注入</p>
<p>在applicationContext.xml中配置注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p>
<h5 id="步骤3运行程序-6"><a class="markdownIt-Anchor" href="#步骤3运行程序-6"></a> 步骤3:运行程序</h5>
<p>运行AppForDIConstructor类，查看结果，说明userDao已经成功注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book service save ...</span><br><span class="line">book dao save ...</span><br><span class="line">user dao save ...</span><br></pre></td></tr></table></figure>
<h4 id="524-构造器注入多个简单数据类型"><a class="markdownIt-Anchor" href="#524-构造器注入多个简单数据类型"></a> 5.2.4 构造器注入多个简单数据类型</h4>
<blockquote>
<p>需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。</p>
<p>参考引用数据类型的注入，可以推出具体的步骤为:</p>
<p>1.提供一个包含这两个参数的构造方法</p>
<p>2.在applicationContext.xml中进行注入配置</p>
</blockquote>
<h5 id="步骤1添加多个简单属性并提供构造方法"><a class="markdownIt-Anchor" href="#步骤1添加多个简单属性并提供构造方法"></a> 步骤1:添加多个简单属性并提供构造方法</h5>
<p>修改BookDaoImpl类，添加构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">(String databaseName, <span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2配置完成多个属性构造器注入"><a class="markdownIt-Anchor" href="#步骤2配置完成多个属性构造器注入"></a> 步骤2:配置完成多个属性构造器注入</h5>
<p>在applicationContext.xml中进行注入配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p>
<h5 id="步骤3运行程序-7"><a class="markdownIt-Anchor" href="#步骤3运行程序-7"></a> 步骤3:运行程序</h5>
<p>运行AppForDIConstructor类，查看结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book service save ...</span><br><span class="line">book dao save ...mysql,666</span><br><span class="line">user dao save ...</span><br></pre></td></tr></table></figure>
<p>上面已经完成了构造函数注入的基本使用，但是会存在一些问题:</p>
<ul>
<li>当构造函数中方法的形参的参数名发生变化后，配置文件中的name属性也需要跟着变</li>
<li>这两块存在紧耦合，具体该如何解决?</li>
</ul>
<p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，<mark>下面介绍的，都以了解为主</mark>。</p>
<p>方式一:删除name属性，添加type属性，按照类型注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这种方式可以解决构造函数形参名发生变化带来的耦合问题</li>
<li>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</li>
</ul>
<p>方式二:删除type属性，添加index属性，按照索引下标注入，下标从0开始</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这种方式可以解决参数类型重复问题</li>
<li>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</li>
</ul>
<p>介绍完两种参数的注入方式，具体该如何选择呢?</p>
<ol>
<li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现
<ul>
<li>强制依赖指对象在创建的过程中必须要注入指定的参数</li>
</ul>
</li>
<li>可选依赖使用setter注入进行，灵活性强
<ul>
<li>可选依赖指对象在创建过程中注入的参数可有可无</li>
</ul>
</li>
<li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li>
<li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li>
<li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li>
<li><strong><mark>自己开发的模块推荐使用setter注入</mark></strong></li>
</ol>
<p>这节中主要讲解的是Spring的依赖注入的实现方式:</p>
<ul>
<li>
<p>setter注入</p>
<ul>
<li>
<p>简单数据类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引用数据类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>构造器注入</p>
<ul>
<li>
<p>简单数据类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引用数据类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>依赖注入的方式选择上</p>
<ul>
<li>建议使用setter注入</li>
<li>第三方技术根据情况选择</li>
</ul>
</li>
</ul>
<h3 id="53-自动配置"><a class="markdownIt-Anchor" href="#53-自动配置"></a> 5.3 自动配置</h3>
<p>前面花了大量的时间把Spring的注入去学习了下，总结起来就一个字<mark>麻烦</mark>。</p>
<p>问:麻烦在哪?</p>
<p>答:配置文件的编写配置上。</p>
<p>问:有更简单方式么?</p>
<p>答:有，自动配置</p>
<p>什么是自动配置以及如何实现自动配置，就是接下来要学习的内容：</p>
<h4 id="531-什么是依赖自动装配"><a class="markdownIt-Anchor" href="#531-什么是依赖自动装配"></a> 5.3.1 什么是依赖自动装配?</h4>
<ul>
<li>IOC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配</li>
</ul>
<h4 id="532-自动装配方式有哪些"><a class="markdownIt-Anchor" href="#532-自动装配方式有哪些"></a> 5.3.2 自动装配方式有哪些?</h4>
<ul>
<li><mark>按类型（常用）</mark></li>
<li>按名称</li>
<li>按构造方法</li>
<li>不启用自动装配</li>
</ul>
<h4 id="533-准备下案例环境"><a class="markdownIt-Anchor" href="#533-准备下案例环境"></a> 5.3.3 准备下案例环境</h4>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，可以快速的拷贝即可:</p>
<p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(3)编写AppForAutoware运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAutoware</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="534-完成自动装配的配置"><a class="markdownIt-Anchor" href="#534-完成自动装配的配置"></a> 5.3.4 完成自动装配的配置</h4>
<p>接下来，在上面这个环境中来完成<code>自动装配</code>的学习:</p>
<p>自动装配只需要修改applicationContext.xml配置文件即可:</p>
<p>(1)将<code>&lt;property&gt;</code>标签删除</p>
<p>(2)在<code>&lt;bean&gt;</code>标签中添加autowire属性</p>
<p>首先来实现按照类型注入的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><mark>注意事项:</mark></p>
<ul>
<li>需要注入属性的类中对应属性的setter方法不能省略</li>
<li>被注入的对象必须要被Spring的IOC容器管理</li>
<li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li>
</ul>
<p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式为:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><mark>注意事项:</mark></p>
<ul>
<li>
<p>按照名称注入中的名称指的是什么?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>bookDao是private修饰的，外部类无法直接方法</li>
<li>外部类只能通过属性的set方法进行访问</li>
<li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名
<ul>
<li>为什么是去掉set首字母小写?</li>
<li>这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名</li>
</ul>
</li>
<li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li>
</ul>
</li>
<li>
<p>如果按照名称去找对应的bean对象，找不到则注入Null</p>
</li>
<li>
<p>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</p>
</li>
</ul>
<p>两种方式介绍完后，以后用的更多的是<mark>按照类型</mark>注入。</p>
<p>最后对于依赖注入，需要注意一些其他的配置特征:</p>
<ol>
<li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li>
<li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li>
<li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li>
<li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li>
</ol>
<h3 id="54-集合注入"><a class="markdownIt-Anchor" href="#54-集合注入"></a> 5.4 集合注入</h3>
<p>前面已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型<mark>集合</mark>，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p>
<p>先来回顾下，常见的集合类型有哪些?</p>
<ul>
<li>数组</li>
<li>List</li>
<li>Set</li>
<li>Map</li>
<li>Properties</li>
</ul>
<p>针对不同的集合类型，该如何实现注入呢?</p>
<h4 id="541-环境准备"><a class="markdownIt-Anchor" href="#541-环境准备"></a> 5.4.1 环境准备</h4>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，可以快速的拷贝即可:</p>
<p>(1)项目中添加添加BookDao、BookDaoImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历数组:&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历List&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Set&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Map&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Properties&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//setter....方法省略，自己使用工具生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)resources下提供spring的配置文件，applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(3)编写AppForDICollection运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDICollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在上面这个环境中来完成<code>集合注入</code>的学习:</p>
<p>下面的所以配置方式，都是在bookDao的bean标签中使用<property>进行注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="542-注入数组类型数据"><a class="markdownIt-Anchor" href="#542-注入数组类型数据"></a> 5.4.2 注入数组类型数据</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="543-注入list类型数据"><a class="markdownIt-Anchor" href="#543-注入list类型数据"></a> 5.4.3 注入List类型数据</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>chuanzhihui<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="544-注入set类型数据"><a class="markdownIt-Anchor" href="#544-注入set类型数据"></a> 5.4.4 注入Set类型数据</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="545-注入map类型数据"><a class="markdownIt-Anchor" href="#545-注入map类型数据"></a> 5.4.5 注入Map类型数据</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span> <span class="attr">value</span>=<span class="string">&quot;henan&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kaifeng&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="546-注入properties类型数据"><a class="markdownIt-Anchor" href="#546-注入properties类型数据"></a> 5.4.6 注入Properties类型数据</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span>&gt;</span>henan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>kaifeng<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置完成后，运行下看结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">book dao save ...</span><br><span class="line">遍历数组:[100,200,300]</span><br><span class="line">遍历List:[itcast,itheima,boxuegu]</span><br><span class="line">遍历Set:[itcast,itheima,boxuegu]</span><br><span class="line">遍历Map:&#123;country=china,province=henan,city=kaifeng&#125;</span><br><span class="line">遍历Properties:&#123;province=henan,city=kaifeng,country=china&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li>
<li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li>
<li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet介绍与使用</title>
    <url>/2023/11/24/Servlet%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>MavenWeb项目创建以及插件的使用参考下面的链接：</p>
<p><big><strong><a href="%5B07-Tomcat-Web%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1Qf4y1T7Hx?p=90&amp;vd_source=2e36878d9aabdc582c635ef654da6eaa)">参考链接</a></strong></big></p>
<h1 id="maven-web项目结构"><a class="markdownIt-Anchor" href="#maven-web项目结构"></a> Maven Web项目结构</h1>
<ul>
<li>
<p>开发中的项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project-name //项目名称</span><br><span class="line">├── src //主目录</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── java代码</span><br><span class="line">│   │   ├── resources</span><br><span class="line">│   │   │   └── 配置文件等资源文件</span><br><span class="line">│   │   └── webapp //web项目特有目录</span><br><span class="line">|	|		├── html //html文件目录（可自定义）</span><br><span class="line">│   │       ├── WEB-INF //web项目核心目录（必须叫这个名称）</span><br><span class="line">│   │       │   ├── web.xml //web项目配置文件</span><br><span class="line">│   │       │   └── 其他配置文件</span><br><span class="line">│   │       └── 其他 Web 资源（HTML、JSP、CSS、JS 等）</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       │   └── 测试源代码文件</span><br><span class="line">│       ├── resources</span><br><span class="line">│       │   └── 测试配置文件等资源文件</span><br><span class="line">│       └── webapp</span><br><span class="line">│           └── 测试使用的 Web 资源</span><br><span class="line">└── pom.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开发完成部署的Web项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webapps</span><br><span class="line">└── project-name //项目访问路径（虚拟目录）</span><br><span class="line">    ├── html // html文件目录（课自定义）</span><br><span class="line">    ├── WEB-INF //web项目核心目录（必须叫这个名称）</span><br><span class="line">    │   ├── classes //java字节码文件夹</span><br><span class="line">    │   ├── lib</span><br><span class="line">    │   │   └── 依赖库 Jar 包</span><br><span class="line">    │   ├── web.xml //web项目配置文件</span><br><span class="line">    │   └── 其他配置文件</span><br><span class="line">    └── 其他 Web 资源（HTML、JSP、CSS、JS 等）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="1-servlet简介"><a class="markdownIt-Anchor" href="#1-servlet简介"></a> 1. Servlet简介</h1>
<ul>
<li>
<p>Servlet是JavaWeb最核心的内容之一，是Java EE中一种用于处理Web请求和响应的服务器端组件，可以理解为<strong>在服务器上运行的Java程序</strong>。<strong>由Servlet容器（如Tomcat）进行管理和调用</strong>。</p>
</li>
<li>
<p>当客户端（通常是Web浏览器）发送HTTP请求到Servlet容器（如Tomcat）时，Servlet容器会根据请求的URL找到对应的Servlet，并将请求转发给该Servlet。Servlet可以从请求中读取参数、头信息等数据，执行业务逻辑（如访问数据库或其他资源），生成响应并将其发送回客户端。</p>
</li>
<li>
<p>使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容。</p>
</li>
<li>
<p><big><strong>Servlet是一个接口，需要定义Servlet类实现Servlet接口</strong></big>，并由web服务器运行Servlet。</p>
</li>
</ul>
<h1 id="2-快速入门"><a class="markdownIt-Anchor" href="#2-快速入门"></a> 2. 快速入门</h1>
<ul>
<li>
<p>​	创建Web项目<code>web-demo</code>，导入Servlet依赖坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      此处为什么需要添加该标签?</span></span><br><span class="line"><span class="comment">      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入</span></span><br><span class="line"><span class="comment">       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<ol>
<li>
<p>定义一个类，实现Servlet接口，并重写接口中的所有方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello world~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<ol start="2">
<li>
<p>配置：在类上使用@WebServlet注解，配置该Servlet访问路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<ol start="3">
<li>
<p>启动：启动Tomcat，浏览器中输入以下URL地址访问该Servlet，URL中的web-demo是本web项目名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/web-demo/demo1</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<ol start="4">
<li>访问后，会在控制台会打印<code>servlet hello world~</code> 说明servlet程序已经成功运行。</li>
</ol>
</li>
</ul>
<p>至此，本Servlet入门案例已成功。</p>
<h1 id="3-执行流程"><a class="markdownIt-Anchor" href="#3-执行流程"></a> 3. 执行流程</h1>
<p>Servlet程序已经能正常运行，但是我们需要思考个问题: 我们并没有创建ServletDemo1类的对象，也没有调用对象中的service方法，为什么在控制台就打印了<code>servlet hello world~</code>这句话呢?</p>
<p>为解决上面的问题，需要了解Servlet的执行流程：</p>
<img src="/img/servlet执行流程.png" />
<ul>
<li>
<p>浏览器发出<code>http://localhost:8080/web-demo/demo1</code>请求，从请求中可以解析出三部分内容，分别是<code>localhost:8080</code>、<code>web-demo</code>、<code>demo1</code></p>
<ul>
<li>根据<code>localhost:8080</code>可以找到要访问的Tomcat Web服务器</li>
<li>根据<code>web-demo</code>可以找到部署在Tomcat服务器上的web-demo项目</li>
<li>根据<code>demo1</code>可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配</li>
</ul>
</li>
<li>
<p>找到ServletDemo1这个类后，<big><strong>Tomcat Web服务器就会自动为ServletDemo1这个类创建一个对象，然后自动调用对象中的service方法</strong></big></p>
<ul>
<li>ServletDemo1实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用</li>
<li>service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据。</li>
</ul>
</li>
</ul>
<p><strong>小结</strong></p>
<p>问题一：Servlet对象由谁创建？Servlet方法由谁调用？</p>
<blockquote>
<p>Servlet由web服务器创建，Servlet方法由web服务器调用</p>
</blockquote>
<p>问题二： 服务器怎么知道Servlet中一定有service方法?</p>
<blockquote>
<p>因为我们自定义的Servlet,必须实现Servlet接口并复写其方法，而Servlet接口中有service方法</p>
</blockquote>
<h1 id="4-生命周期"><a class="markdownIt-Anchor" href="#4-生命周期"></a> 4. 生命周期</h1>
<p>由上面可知，Servlet对象由Tomcat Web服务器帮我们创建。</p>
<p>再来思考一个问题:  Tomcat什么时候创建的Servlet对象?</p>
<p>要想回答上述问题，需要了解Servlet的生命周期。</p>
<ul>
<li>
<p>生命周期: 对象的生命周期指一个对象从被创建到被销毁的整个过程。</p>
</li>
<li>
<p>Servlet运行在Servlet容器(web服务器，即Tomcat)中，其生命周期由容器来管理，分为4个阶段：</p>
<ol>
<li>
<p><strong>加载和实例化</strong>：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">默认情况，Servlet对象会在第一次访问时被Servlet容器（即Tomcat）创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?</span><br><span class="line"></span><br><span class="line">@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)</span><br><span class="line">loadOnstartup的取值有两类情况</span><br><span class="line">	（1）负整数:第一次访问时创建Servlet对象</span><br><span class="line">	（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>初始化</strong>：在Servlet实例化（即创建对象）之后，Servlet容器（即Tomcat）将调用Servlet的<strong>init()<strong>方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只</strong>调用一次</strong></p>
</li>
<li>
<p><strong>请求处理</strong>：<strong>每次</strong>请求Servlet时，Servlet容器都会调用Servlet的**service()**方法对请求进行处理</p>
</li>
<li>
<p><strong>服务终止</strong>：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的**destroy()**方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</p>
</li>
</ol>
</li>
<li>
<p>通过以下案例演示上述的生命周期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet生命周期方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo2&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * 1.调用时机：默认情况下，Servlet被第一次访问时，调用</span></span><br><span class="line"><span class="comment">     * * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供服务</span></span><br><span class="line"><span class="comment">     * 1.调用时机:每一次Servlet被访问时，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 多次</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello world~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法</span></span><br><span class="line"><span class="comment">     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>小结</strong></p>
<p>1、Servlet对象在什么时候被创建？</p>
<blockquote>
<p>默认是第一次访问的时候被创建的，可以使用@WebServlet(urlPatterns = “/demo2”, loadOnStartup = 1)的<strong>loadOnStartup</strong>修改成在服务器启动时创建。</p>
</blockquote>
<p>2、 Servlet生命周期中涉及到的三个方法，这三个方法是什么?什么时候被调用?调用几次?</p>
<blockquote>
<p>涉及到三个方法，分别是init()、service()、destroy()</p>
<p>init方法在Servlet对象被创建的时候执行，只执行1次</p>
<p>service方法在Servlet被访问的时候调用，每访问1次就调用1次</p>
<p>destroy方法在Servlet对象被销毁的时候调用，只执行1次</p>
</blockquote>
<h1 id="5-方法介绍"><a class="markdownIt-Anchor" href="#5-方法介绍"></a> 5. 方法介绍</h1>
<p>Servlet中总共有5个方法，我们已经介绍过其中的三个，剩下的两个方法作用分别是什么？</p>
<p>我们先来回顾下前面讲的三个方法，分别是:</p>
<ul>
<li>
<p>初始化方法，在Servlet创建时创建，只执行一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提供服务方法， 每次Servlet被访问，都会调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">servive</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>剩下的两个方法是：getServletInfo() 和 getServletConfig()</p>
<p><big><strong>getServletInfo()和getServletConfig()这两个方法使用的不是很多，了解即可</strong></big></p>
<ul>
<li>
<p>获取Servlet信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getServletInfo</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取ServletConfig对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>ServletConfig对象，在init方法的参数中有，而Tomcat Web服务器在创建Servlet对象的时候会调用init方法，必定会传入一个ServletConfig对象，我们只需要将服务器传过来的ServletConfig进行返回即可。具体如何操作?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet中ServletConfig获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo3&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServletConfig servletconfig;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * 1.调用时机：默认情况下，Servlet被第一次访问时，调用</span></span><br><span class="line"><span class="comment">     * * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.servletconfig = config;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> servletconfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...其余方法不变，省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="6-体系结构"><a class="markdownIt-Anchor" href="#6-体系结构"></a> 6. 体系结构</h1>
<p>通过上面的学习，我们知道要想编写一个Servlet就必须要实现Servlet接口，重写接口中的5个方法，虽然已经能完成要求，但是编写起来还是比较麻烦的，因为我们更关注的其实只有service方法，那有没有更简单方式来创建Servlet呢?</p>
<p>要想解决上面的问题，我们需要先对Servlet的体系结构进行下了解:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Servlet 		------&gt; Servlet体系根接口</span><br><span class="line">	↑</span><br><span class="line">	|</span><br><span class="line">GenericServlet  ------&gt; Servlet抽象实现类</span><br><span class="line">	↑</span><br><span class="line">	|</span><br><span class="line">HttpServlet 	------&gt; 对HTTP协议封装的Servlet实现类</span><br></pre></td></tr></table></figure>
<p>因为我们将来开发B/S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet,会通过继承<strong>HttpServlet</strong></p>
<p>具体的编写格式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//TODO GET 请求方式处理逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//TODO Post 请求方式处理逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>要想发送一个GET请求，请求该Servlet，只需要通过浏览器发送<code>http://localhost:8080/web-demo/demo4</code>,就能看到doGet方法被执行了</li>
<li>要想发送一个POST请求，请求该Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个form表单来发送请求，在webapp下创建一个<code>a.html</code>页面，内容如下:</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/web-demo/demo4&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动测试，在网页中输入URL<code>http://localhost:8080/tomcat-demo/a.html</code>打开网页，输入信息点击提交。即可看到doPost方法被执行了。</p>
<p>Servlet的简化编写就介绍完了，接着需要思考两个问题:</p>
<ol>
<li>HttpServlet中为什么要根据请求方式的不同，调用不同的方法?</li>
<li>如何调用?</li>
</ol>
<p>针对问题一，我们需要回顾之前的知识点<strong>前端发送GET和POST请求的时候，参数的位置不一致，GET请求参数在请求行中，POST请求参数在请求体中</strong>，为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理，这样能实现，但是每个Servlet类中都将有相似的代码，针对这个问题，有什么可以优化的策略么?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo5</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//如何调用?</span></span><br><span class="line">        <span class="comment">//获取请求方式，根据不同的请求方式进行不同的业务处理</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest)req;</span><br><span class="line">       <span class="comment">//1. 获取请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">        <span class="comment">//2. 判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line">            <span class="comment">// get方式的处理逻辑</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line">            <span class="comment">// post方式的处理逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要解决上述问题，我们可以对Servlet接口进行继承封装，来简化代码开发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHttpServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest)req;</span><br><span class="line">        <span class="comment">//1. 获取请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">        <span class="comment">//2. 判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line">            <span class="comment">// get方式的处理逻辑</span></span><br><span class="line">            doGet(req,res);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line">            <span class="comment">// post方式的处理逻辑</span></span><br><span class="line">            doPost(req,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有了MyHttpServlet这个类，以后我们再编写Servlet类的时候，只需要继承MyHttpServlet，重写父类中的doGet和doPost方法，就可以用来处理GET和POST请求的业务逻辑。接下来，可以把ServletDemo5代码进行改造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo5</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将来页面发送的是GET请求，则会进入到doGet方法中进行执行，如果是POST请求，则进入到doPost方法。这样代码在编写的时候就相对来说更加简单快捷。</p>
<p>类似MyHttpServlet这样的类Servlet中已经为我们提供好了，就是HttpServlet,翻开源码，大家可以搜索<code>service()</code>方法，你会发现HttpServlet做的事更多，不仅可以处理GET和POST还可以处理其他五种请求方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified ** -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">                <span class="comment">// to go through further expensive logic</span></span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                    <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                    maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doHead(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">            doPost(req, resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">            doPut(req, resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">            doDelete(req, resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">            doOptions(req,resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">            doTrace(req,resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">            <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">            errArgs[<span class="number">0</span>] = method;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            </span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>既然如此，直接继承HttpServlet不就行吗，为什么还要实现MyHttpServlet ？</strong></p>
<blockquote>
<p>当然可以直接继承<code>HttpServlet</code>类来编写Servlet，这是常见的做法。<code>HttpServlet</code>类已经实现了<code>Servlet</code>接口，并提供了一些针对HTTP请求的便捷方法，比如<code>doGet()</code>、<code>doPost()</code>等。直接继承<code>HttpServlet</code>可以简化代码编写，不再需要重写<code>service()</code>方法来判断请求类型，而是直接重写<code>doGet()</code>和<code>doPost()</code>方法来处理相应的请求。直接继承<code>HttpServlet</code>的优点是简单明了，代码结构清晰，适用于简单的Servlet开发。</p>
<p>但是如果有一些通用的业务逻辑需要在多个Servlet中复用，或者想要遵循某种模板方法的设计模式，那么封装<code>Servlet</code>接口的方式可能更合适。根据具体的需求和项目情况，选择合适的方式来编写Servlet。</p>
</blockquote>
<p><strong>小结</strong></p>
<p>通过这一节的学习，要掌握:</p>
<ol>
<li>HttpServlet的使用步骤</li>
</ol>
<blockquote>
<p>继承HttpServlet</p>
<p>重写doGet和doPost方法</p>
</blockquote>
<ol start="2">
<li>HttpServlet原理</li>
</ol>
<blockquote>
<p>获取请求方式，并根据不同的请求方式，调用不同的doXxx方法</p>
</blockquote>
<h1 id="7-urlpattern配置"><a class="markdownIt-Anchor" href="#7-urlpattern配置"></a> 7 urlPattern配置</h1>
<p>Servlet类编写好后，要想被访问到，就需要配置其访问路径（<strong>urlPattern</strong>）</p>
<ul>
<li>
<p>一个Servlet,可以配置多个urlPattern</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &#123;&quot;/demo1&quot;,&quot;/demo2&quot;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* urlPattern: 一个Servlet可以配置多个访问路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/demo7&quot;,&quot;/demo8&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo7</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;demo7 get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器上输入<code>http://localhost:8080/web-demo/demo7</code>,<code>http://localhost:8080/web-demo/demo8</code>这两个地址都能访问到ServletDemo7的doGet方法。</p>
</li>
<li>
<p><strong>urlPattern配置规则</strong></p>
<ul>
<li>
<p>精确匹配</p>
<ul>
<li>配置路径：@WebServlet(urlPatterns = “/user/select”)</li>
<li>访问路径： localhost:8080/web-demo/user/select</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UrlPattern:</span></span><br><span class="line"><span class="comment"> * * 精确匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/user/select&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo8</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo8 get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问路径<code>http://localhost:8080/web-demo/user/select</code></p>
</li>
<li>
<p>目录匹配</p>
<ul>
<li>配置路径：@WebServlet(urlPatterns = “/user/*”)</li>
<li>访问路径： localhost:8080/web-demo/user/aaa   localhost:8080/web-demo/user/bbb</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UrlPattern:</span></span><br><span class="line"><span class="comment"> * * 目录匹配: /user/*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/user/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo9</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo9 get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问路径<code>http://localhost:8080/web-demo/user/任意</code></p>
<p><strong>思考:</strong></p>
<ol>
<li>访问路径<code>http://localhost:8080/web-demo/user</code>是否能访问到demo9的doGet方法?</li>
<li>访问路径<code>http://localhost:8080/web-demo/user/a/b</code>是否能访问到demo9的doGet方法?</li>
<li>访问路径<code>http://localhost:8080/web-demo/user/select</code>是否能访问到demo9还是demo8的doGet方法?</li>
</ol>
<p>答案是: 能、能、demo8，进而我们可以得到的结论是<code>/user/*</code>中的<code>/*</code>代表的是零或多个层级访问目录同时精确匹配优先级要高于目录匹配。</p>
</li>
<li>
<p>扩展名匹配</p>
<ul>
<li>配置路径：@WebServlet(&quot;*.do&quot;)</li>
<li>访问路径： localhost:8080/web-demo/aaa.do   localhost:8080/web-demo/bbb.do</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UrlPattern:</span></span><br><span class="line"><span class="comment"> * * 扩展名匹配: *.do</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo10</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo10 get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问路径<code>http://localhost:8080/web-demo/任意.do</code></p>
<p><strong>注意</strong>:</p>
<ol>
<li>
<p><strong>如果路径配置的不是扩展名，那么在路径的前面就必须要加<code>/</code>否则会报错</strong></p>
</li>
<li>
<p><em><em>如果路径配置的是<code>*.do</code>,那么在</em>.do的前面不能加<code>/</code>,否则会报错</em>*</p>
</li>
</ol>
</li>
<li>
<p>任意匹配</p>
<ul>
<li>配置路径：@WebServlet( “/”)    @WebServlet( “/*”)</li>
<li>访问路径： localhost:8080/web-demo/hehe   localhost:8080/web-demo/haha</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">package</span> com.itheima.web;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line">  <span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line">  <span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * UrlPattern:</span></span><br><span class="line"><span class="comment">   * * 任意匹配： /</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo11</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">  </span><br><span class="line">          System.out.println(<span class="string">&quot;demo11 get...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">访问路径`http:<span class="comment">//localhost:8080/demo-web/任意`</span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UrlPattern:</span></span><br><span class="line"><span class="comment"> * * 任意匹配： /*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo12</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo12 get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>访问路径<code>http://localhost:8080/demo-web/</code>任意</p>
<p><strong>注意:</strong><code>/</code>和<code>/*</code>的区别?</p>
<blockquote>
<ol>
<li>
<p>当Servlet配置了<code>/</code>时，它将成为默认的Servlet。这意味着当其他的URL匹配不上时，请求会被路由到这个Servlet上。这样做的好处是可以在默认Servlet中处理一些全局逻辑或错误处理。但需要注意的是，如果配置了<code>/</code>，那么默认的静态资源处理器（如Tomcat的DefaultServlet）将被覆盖，导致静态资源无法正常访问。</p>
</li>
<li>
<p>当Servlet配置了<code>/*</code>时，它将匹配任意访问路径，包括静态资源请求。这样做可以实现对所有请求的拦截和处理。但需要注意的是，在配置了<code>/*</code>的情况下，静态资源的处理可能需要自行实现，或者通过其他方式（例如配置额外的Servlet或使用特定框架）来处理静态资源请求。</p>
</li>
</ol>
<p>选择使用哪种URL模式取决于具体需求和项目结构。如果需要处理全局逻辑或错误处理，并且不涉及静态资源的特殊处理，可以选择使用<code>/</code>作为URL模式。如果需要对所有请求进行拦截和处理，包括静态资源请求，可以选择使用<code>/*</code>作为URL模式。在使用<code>/*</code>时，需要额外考虑静态资源的处理方式，以确保正常访问静态资源。</p>
</blockquote>
</li>
</ul>
<p><strong>小结</strong></p>
<ol>
<li>
<p>urlPattern总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配</p>
</li>
<li>
<p>五种配置的优先级为 精确匹配 &gt; 目录匹配&gt; 扩展名匹配 &gt; /* &gt; / ,无需记，以最终运行结果为准。</p>
</li>
</ol>
<h1 id="8-xml配置"><a class="markdownIt-Anchor" href="#8-xml配置"></a> 8 XML配置</h1>
<p>前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。</p>
<p>对于XML的配置步骤有两步:</p>
<ul>
<li>编写Servlet类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo13</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo13 get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在web.xml中配置该Servlet</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        Servlet 全类名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet的名称，名字任意--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo13<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet的类全名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.web.ServletDemo13<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        Servlet 访问路径</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet的名称，要和上面的名称一致--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo13<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet的访问路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo13<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种配置方式和注解比起来，确认麻烦很多，所以建议大家使用注解来开发。但是大家要认识上面这种配置方式，因为并不是所有的项目都是基于注解开发的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo图片问题</title>
    <url>/2023/11/23/hexo%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>hexo博客在添加图片时遇到了问题，下面说三个解决方案：<big><strong>强烈推荐方案三</strong></big></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">图片多用方案一，图片少用方案二，（最新方案）方案三</span><br></pre></td></tr></table></figure>
<h1 id="解决方案一"><a class="markdownIt-Anchor" href="#解决方案一"></a> 解决方案一：</h1>
<blockquote>
<p><a href="https://blog.51cto.com/u_15477117/4919656">参考链接</a></p>
<p>本方法通过<code>&#123;%%&#125;</code>插入本地图片，首先要修改博客配置文件<code>_config.yml</code>,把配置文件里的<code>post_asset_folder</code>设置为<code>true</code>，这时用<code>hexo new &quot;文章标题&quot;</code>创建文章时会自动创建一个同名的文件夹，用于存放资源文件。</p>
<p>使用<code>&#123;%%&#125;</code>方法必须将图片放在新建文件时生成的同名文件夹目录下，然后使用以下命令格式即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图片文件名 图片加载失败的描述 %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>缺点</strong></p>
<p>新建文章时会新建同名目录用于存放图片，图片不多的话就看着很烦，更重要的是图片无法在Typora中展示，只能在博客中看，这让我很不爽。</p>
</li>
</ul>
</blockquote>
<h1 id="解决方法二"><a class="markdownIt-Anchor" href="#解决方法二"></a> 解决方法二：</h1>
<blockquote>
<p><a href="https://i007it.com/2022/04/30/Hexo%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5%E6%96%B9%E5%BC%8F%EF%BC%88%E5%85%BC%E5%AE%B9Typora%EF%BC%89/">参考链接</a></p>
<p>本方法通过<code>&lt;img src=&quot;/img/xxx.jpg&quot;/&gt;</code>方式插入图片，详细步骤在链接中，原文章中有一个点说的不太准确，就是在Typora中设置图片根目录时选择的目录是<strong>hexo目录下的source目录</strong>，不是source/img目录。其余跟原文章一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;/img/xxx.jpg&quot;</span> style=<span class="string">&quot;zoom:80%&quot;</span> /&gt; <span class="comment">//80%是缩放比例</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>缺点</strong></p>
<p>图片多的话会比较麻烦，但是在Typora和博客中图片均会显示。</p>
</li>
</ul>
</blockquote>
<h1 id="解决方案三最新方案强烈推荐"><a class="markdownIt-Anchor" href="#解决方案三最新方案强烈推荐"></a> 解决方案三（最新方案，强烈推荐）：</h1>
<blockquote>
<p>[参考链接](<a href="https://hexo.io/zh-cn/docs/asset-folders.html">资源文件夹 | Hexo</a>)</p>
<ul>
<li>
<p><strong>优点</strong></p>
<p>在Typora中可以直接用<code>![]()</code>标签显示同名文件夹中的图片，还可成功布置到博客上。</p>
</li>
</ul>
<p>这个方法参考了一部分的官方文档。前两个方法都不好，第一个写法<code>&#123;% %&#125;</code>有点反人类，而且无法在Typora显示，第二个方法适用于图片较少的情况，我现在用到的图片比较多，现在也不太行了。</p>
<p>我的方法跟第一个方案类似，首先要修改博客配置文件<code>_config.yml</code>,把配置文件里的<code>post_asset_folder</code>设置为<code>true</code>，并在配置文件里添加以下的<code>marked</code>部分，官方文档说<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a> 3.1.0 引入了一个新的选项，其允许你无需使用 <code>&#123;% %&#125;</code>就可以在 markdown 中嵌入图片，而是使用<code>![]()</code>标签即可，我就是参考的这个，<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a> 3.1.0插件无需下载，在新版的hexo中已经集成了，如果不确定有没有可以使用<code>npm list hexo-renderer-marked</code>命令查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br><span class="line">---------------------------------添加以下内容----------------</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure>
<p>设置完后用<code>hexo new &quot;文章标题&quot;</code>创建文章时会自动创建一个同名的文件夹，用于存放资源文件，一定要用这个方法创建文章。使用<code>![]()</code>方法必须将图片放在新建文件时生成的同名文件夹目录下，然后在Typora中使用以下命令格式即可添加图片：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![图片描述](image.png) <span class="comment">// 这里的图片路径直接填图片名即可，不需要在添加其它目录</span></span><br></pre></td></tr></table></figure>
<p>此时会发现一个bug，无法在Typora中显示图片，但是可以在博客中显示，<strong>解决方法</strong>是在Typora中设置图片根目录时选择放置图片的目录，详细步骤是在Typora中选择：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式（O） -&gt; 图像 -&gt; 设置图片根目录 -&gt; 选择文章同名文件夹（即放置图片的文件夹）</span><br></pre></td></tr></table></figure>
<p>设置完后就可以在Typora中显示图片了。</p>
<ul>
<li>
<p><strong>细节</strong></p>
<p>经过多次测试，一定要把<code>post_asset_folder</code>设置为<code>true</code>，再使用<code>hexo new &quot;文章标题&quot;</code>创建文章才可以，只用在这种情况下在自动创建的同名文件夹中的图片才管用，才没有问题，自己手动创建文件夹放置图片会导致在Typora中不显示图片，设置为<code>false</code>的话会导致图片仅在Typora中显示而不在博客中显示。</p>
</li>
<li>
<p><strong>缺点</strong></p>
<p>没有找到一个好的方法删除文章的同时删除对应的文件夹。</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo小问题总结</title>
    <url>/2023/12/01/hexo%E5%B0%8F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-标签加粗字体失败"><a class="markdownIt-Anchor" href="#1-标签加粗字体失败"></a> 1. ** 标签加粗字体失败</h2>
<p>这个问题只在hexo博客中出现，Typora中显示一切正常</p>
<p>[参考链接1]([如何用Hexo优雅的书写文章_hexo写文章不方便-CSDN博客](<a href="https://blog.csdn.net/howareyou2104/article/details/106312703#:~:text=%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">https://blog.csdn.net/howareyou2104/article/details/106312703#:~:text=解决办法</a> 不要把符号包括进去加粗， 注意,：这是一个加粗演示 后面空开一格（基本能解决大多数冲突）， 注意： 这是一个加粗演示))  <a href="https://ld246.com/article/1597581380183">参考链接2</a></p>
<p>参考了上面的链接，但是链接的方法没有起作用。</p>
<p>问题1和解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**标题:**   //这种情况就不会加粗，因为 : 是英文的，把它换成中文的：就可以了。</span><br></pre></td></tr></table></figure>
<p>问题2和解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**内容(内容)**  //解决办法是将英文的左右括号(和)换成中文的左右括号（和）</span><br></pre></td></tr></table></figure>
<p>问题3和解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**`内容`**  //解决办法是在前面的**前面加空格，在后面的**后面加空格，挺麻烦的，以后不推荐这种格式了，直接`内容`，不加粗了。不推荐在****中间加符号，写纯的汉字或字母就够了。</span><br></pre></td></tr></table></figure>
<h2 id="2-高亮显示"><a class="markdownIt-Anchor" href="#2-高亮显示"></a> 2. ==高亮显示</h2>
<p>[参考链接](<a href="https://blog.csdn.net/qq_36667170/article/details/105846999">hexo 更换 markdown渲染器 @upupming/hexo-renderer-markdown-it-plus_markdown-it-katex-CSDN博客</a>)</p>
<ul>
<li>
<p>首先卸载掉hexo自带的markdown渲染器<code>hexo-renderer-marked</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后下载新的markdown渲染器<code>@upupming/hexo-renderer-markdown-it-plus</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i @upupming/hexo-renderer-markdown-it-plus --save</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>完成，其余什么也不用配置</p>
</li>
<li>
<p>渲染结果如下：</p>
<p><mark>我是渲染结果</mark></p>
</li>
</ul>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>常用软件快捷键</title>
    <url>/2023/11/23/windows%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h1>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ALT + ESC</td>
<td>隐藏当前窗口</td>
</tr>
<tr>
<td style="text-align:left">WIN + 向上方向键</td>
<td>当前窗口最大化</td>
</tr>
<tr>
<td style="text-align:left">WIN + 其它方向键</td>
<td>当前窗口在屏幕中的位置</td>
</tr>
<tr>
<td style="text-align:left">先win + R输入cmd，然后ctrl + shift + 回车</td>
<td>以管理员身份打开命令行窗口</td>
</tr>
</tbody>
</table>
<h1 id="typoar"><a class="markdownIt-Anchor" href="#typoar"></a> Typoar</h1>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ctrl + shift + 数字1</td>
<td>打开/关闭侧边栏</td>
</tr>
<tr>
<td>ctrl + /</td>
<td>启用/关闭源代码模式</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>会话技术(Cookie和Session)</title>
    <url>/2023/12/01/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF-Cookie%E5%92%8CSession/</url>
    <content><![CDATA[<h2 id="会话技术"><a class="markdownIt-Anchor" href="#会话技术"></a> 会话技术</h2>
<p><strong>今日目标</strong></p>
<blockquote>
<ul>
<li>
<p>理解什么是会话跟踪技术</p>
</li>
<li>
<p>掌握Cookie的使用</p>
</li>
<li>
<p>掌握Session的使用</p>
</li>
<li>
<p>完善用户登录注册案例的功能</p>
</li>
</ul>
</blockquote>
<h2 id="1-会话跟踪技术的概述"><a class="markdownIt-Anchor" href="#1-会话跟踪技术的概述"></a> 1. 会话跟踪技术的概述</h2>
<p>对于<code>会话跟踪</code>这四个词，我们需要拆开来进行解释，首先要理解什么是<code>会话</code>，然后再去理解什么是<code>会话跟踪</code>:</p>
<ul>
<li>
<p>会话:用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含<strong>多次</strong>请求和响应。</p>
<ul>
<li>从浏览器发出请求到服务端响应数据给前端之后，一次会话(在浏览器和服务器之间)就被建立了</li>
<li>会话被建立后，如果浏览器或服务端都没有被关闭，则会话就会持续建立着</li>
<li>浏览器和服务器就可以继续使用该会话进行请求发送和响应，上述的整个过程就被称之为<strong>会话</strong>。</li>
</ul>
<p>用实际场景来理解下会话，比如在我们访问京东的时候，当打开浏览器进入京东首页后，浏览器和京东的服务器之间就建立了一次会话，后面的搜索商品,查看商品的详情,加入购物车等都是在这一次会话中完成。</p>
</li>
<li>
<p>会话跟踪:一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间<strong>共享数据</strong>。</p>
<ul>
<li>服务器会收到多个请求，这多个请求可能来自多个浏览器，如上图中的6个请求来自3个浏览器</li>
<li>服务器需要用来识别请求是否来自同一个浏览器</li>
<li>服务器用来识别浏览器的过程，这个过程就是<strong>会话跟踪</strong></li>
<li>服务器识别浏览器后就可以在同一个会话中多次请求之间来共享数据</li>
</ul>
<p>那么我们又有一个问题需要思考，一个会话中的多次请求为什么要共享数据呢?有了这个数据共享功能后能实现哪些功能呢?</p>
<ul>
<li>
<p>购物车: <code>加入购物车</code>和<code>去购物车结算</code>是两次请求，但是后面这次请求要想展示前一次请求所添加的商品，就需要用到数据共享。</p>
</li>
<li>
<p>页面展示用户登录信息:很多网站，登录后访问多个功能发送多次请求后，浏览器上都会有当前登录用户的信息[用户名]，比如百度、京东、码云等。</p>
</li>
<li>
<p>网站登录页面的<code>记住我</code>功能:当用户登录成功后，勾选<code>记住我</code>按钮后下次再登录的时候，网站就会自动填充用户名和密码，简化用户的登录操作，多次登录就会有多次请求，他们之间也涉及到共享数据</p>
</li>
<li>
<p>登录页面的验证码功能:生成验证码和输入验证码点击注册这也是两次请求，这两次请求的数据之间要进行对比，相同则允许注册，不同则拒绝注册，该功能的实现也需要在同一次会话中共享数据。</p>
</li>
</ul>
</li>
</ul>
<p>通过这几个例子的讲解，相信大家对<code>会话追踪</code>技术已经有了一定的理解，该技术在实际开发中也非常重要。那么接下来我们就需要去学习下<code>会话跟踪</code>技术，在学习这些技术之前，我们需要思考:为什么现在浏览器和服务器不支持数据共享呢?</p>
<ul>
<li>浏览器和服务器之间使用的是HTTP请求来进行数据传输</li>
<li>HTTP协议是<strong>无状态</strong>的，每次浏览器向服务器请求时，服务器都会将该请求视为<strong>新的</strong>请求</li>
<li>HTTP协议设计成无状态的目的是让每次请求之间相互独立，互不影响</li>
<li>请求与请求之间独立后，就无法实现多次请求之间的数据共享</li>
</ul>
<p>分析完具体的原因后，那么该如何实现会话跟踪技术呢? 具体的实现方式有:</p>
<p>(1)客户端会话跟踪技术：<strong>Cookie</strong></p>
<p>(2)服务端会话跟踪技术：<strong>Session</strong></p>
<p>这两个技术都可以实现会话跟踪，它们之间最大的区别:<strong>Cookie是存储在浏览器端而Session是存储在服务器端</strong></p>
<p>具体的学习思路为:</p>
<ul>
<li>CooKie的基本使用、原理、使用细节</li>
<li>Session的基本使用、原理、使用细节</li>
<li>Cookie和Session的综合案例</li>
</ul>
<p><strong>小结</strong></p>
<p>在这节中，我们主要介绍了下什么是会话和会话跟踪技术，需要注意的是:</p>
<ul>
<li>HTTP协议是无状态的，靠HTTP协议是无法实现会话跟踪</li>
<li>想要实现会话跟踪，就需要用到Cookie和Session</li>
</ul>
<p>这个Cookie和Session具体该如何使用，接下来就先从Cookie来学起。</p>
<h2 id="2-cookie"><a class="markdownIt-Anchor" href="#2-cookie"></a> 2. Cookie</h2>
<p>学习Cookie，我们主要解决下面几个问题:</p>
<ul>
<li>什么是Cookie?</li>
<li>Cookie如何来使用?</li>
<li>Cookie是如何实现的?</li>
<li>Cookie的使用注意事项有哪些?</li>
</ul>
<h3 id="21-cookie的基本使用"><a class="markdownIt-Anchor" href="#21-cookie的基本使用"></a> 2.1 Cookie的基本使用</h3>
<p><strong>1.概念</strong></p>
<p><strong>Cookie</strong>：客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问。</p>
<p><strong>2.Cookie的工作流程</strong></p>
<ul>
<li>服务端提供了两个Servlet，分别是ServletA和ServletB</li>
<li>浏览器发送HTTP请求1给服务端，服务端ServletA接收请求并进行业务处理</li>
<li>服务端ServletA在处理的过程中可以创建一个Cookie对象并将<code>name=zs</code>的数据存入Cookie</li>
<li>服务端ServletA在响应数据的时候，会把Cookie对象响应给浏览器</li>
<li>浏览器接收到响应数据，会把Cookie对象中的数据存储在浏览器内存中，此时浏览器和服务端就<strong>建立了一次会话</strong></li>
<li><strong>在同一次会话</strong>中浏览器再次发送HTTP请求2给服务端ServletB，浏览器会携带Cookie对象中的所有数据</li>
<li>ServletB接收到请求和数据后，就可以获取到存储在Cookie对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享</li>
</ul>
<p><strong>3.Cookie的基本使用</strong></p>
<p>对于Cookie的使用，我们更关注的应该是后台代码如何操作Cookie，对于Cookie的操作主要分两大类，本别是<strong>发送Cookie</strong>和<strong>获取Cookie</strong>,对于上面这两块内容，分别该如何实现呢?</p>
<p>3.1 发送Cookie</p>
<ul>
<li>创建Cookie对象，并设置数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>发送Cookie到客户端：使用<strong>response</strong>对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<p>介绍完发送Cookie对应的步骤后，接下面通过一个案例来完成Cookie的发送，具体实现步骤为:</p>
<blockquote>
<p>需求:在Servlet中生成Cookie对象并存入数据，然后将数据发送给浏览器</p>
<p>1.创建Maven项目,项目名称为cookie-demo，并在pom.xml添加依赖</p>
<p>2.编写Servlet类，名称为AServlet</p>
<p>3.在AServlet中创建Cookie对象，存入数据，发送给前端</p>
<p>4.启动测试，在浏览器查看Cookie对象中的值</p>
</blockquote>
<p>(1)创建Maven项目cookie-demo，并在pom.xml添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jsp--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jstl--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(2)编写Servlet类，名称为AServle，在Servlet中创建Cookie对象，存入数据，发送给前端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/aServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//发送Cookie</span></span><br><span class="line">        <span class="comment">//1. 创建Cookie对象</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 发送Cookie，response</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）启动测试，在浏览器查看Cookie对象中的值</p>
<p>访问<code>http://localhost:8080/cookie-demo/aServlet</code></p>
<p>edge浏览器查看Cookie的值：</p>
<p>选中打开开发者工具或者使用快捷键F12，选择Application，再选择cookie就可以看到了。</p>
<p>3.2 获取Cookie</p>
<ul>
<li>获取客户端携带的所有Cookie，使用<strong>request</strong>对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历数组，获取每一个Cookie对象：for</li>
<li>使用Cookie对象方法获取数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookie.getName();</span><br><span class="line">cookie.getValue();</span><br></pre></td></tr></table></figure>
<p>介绍完获取Cookie对应的步骤后，接下面再通过一个案例来完成Cookie的获取，具体实现步骤为:</p>
<blockquote>
<p>需求:在Servlet中获取前一个案例存入在Cookie对象中的数据</p>
<p>1.编写一个新Servlet类，名称为BServlet</p>
<p>2.在BServlet中使用request对象获取Cookie数组，遍历数组，从数据中获取指定名称对应的值</p>
<p>3.启动测试，在控制台打印出获取的值</p>
</blockquote>
<p>（1）编写一个新Servlet类，名称为BServlet，在BServlet中使用request对象获取Cookie数组，遍历数组，从数据中获取指定名称对应的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/bServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取Cookie</span></span><br><span class="line">        <span class="comment">//1. 获取Cookie数组</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="comment">//2. 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="comment">//3. 获取数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;username&quot;</span>.equals(name))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">                System.out.println(name+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）启动测试，在控制台打印出获取的值</p>
<p>访问<code>http://localhost:8080/cookie-demo/bServlet</code></p>
<p>在IDEA控制台就能看到输出的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username:zs</span><br></pre></td></tr></table></figure>
<p>**思考：**测试的时候</p>
<ul>
<li>在访问AServlet和BServlet的中间把关闭浏览器,重启浏览器后访问BServlet能否获取到Cookie中的数据?</li>
</ul>
<p>这个问题，我们会在Cookie的使用细节中讲，大家可以动手先试下。</p>
<p><strong>小结</strong></p>
<p>在这节中，我们主要讲解了Cookie的基本使用,包含两部分内容</p>
<ul>
<li>发送Cookie:
<ul>
<li>创建Cookie对象，并设置值:Cookie cookie = new Cookie(“key”,“value”);</li>
<li>发送Cookie到客户端使用的是Reponse对象:response.addCookie(cookie);</li>
</ul>
</li>
<li>获取Cookie:
<ul>
<li>使用Request对象获取Cookie数组:Cookie[] cookies = request.getCookies();</li>
<li>遍历数组</li>
<li>获取数组中每个Cookie对象的值:cookie.getName()和cookie.getValue()</li>
</ul>
</li>
</ul>
<p>介绍完Cookie的基本使用之后，那么Cookie的底层到底是如何实现一次会话两次请求之间的数据共享呢?</p>
<h3 id="22-cookie的原理分析"><a class="markdownIt-Anchor" href="#22-cookie的原理分析"></a> 2.2 Cookie的原理分析</h3>
<p>对于Cookie的实现原理是基于HTTP协议的,其中设计到HTTP协议中的两个请求头信息:</p>
<ul>
<li>响应头:set-cookie</li>
<li>请求头: cookie</li>
</ul>
<p><img src="1629393289338.png" alt="1629393289338" /></p>
<ul>
<li>前面的案例中已经能够实现，AServlet给前端发送Cookie,BServlet从request中获取Cookie的功能</li>
<li>对于AServlet响应数据的时候，Tomcat服务器都是基于HTTP协议来响应数据</li>
<li>当Tomcat发现后端要返回的是一个Cookie对象之后，Tomcat就会在响应头中添加一行数据 <strong><code>Set-Cookie:username=zs</code></strong></li>
<li>浏览器获取到响应结果后，从响应头中就可以获取到<code>Set-Cookie</code>对应值<code>username=zs</code>,并将数据存储在浏览器的内存中</li>
<li>浏览器再次发送请求给BServlet的时候，浏览器会自动在请求头中添加 <strong><code>Cookie: username=zs</code></strong> 发送给服务端BServlet</li>
<li>Request对象会把请求头中cookie对应的值封装成一个个Cookie对象，最终形成一个数组</li>
<li>BServlet通过Request对象获取到Cookie[]后，就可以从中获取自己需要的数据</li>
</ul>
<p>接下来，使用刚才的案例，把上述结论验证下:</p>
<p>(1)访问AServlet对应的地址<code>http://localhost:8080/cookie-demo/aServlet</code></p>
<p>使用edge浏览器打开开发者工具(F12或Crtl+Shift+I)进行查看<strong>响应头</strong>中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Response Headers</span><br><span class="line">----------------</span><br><span class="line">	Set-Cookie: username=zs</span><br></pre></td></tr></table></figure>
<p>（2）访问BServlet对应的地址<code>http://localhost:8080/cookie-demo/bServlet</code></p>
<p>使用edge浏览器打开开发者工具(F12或Crtl+Shift+I)进行查看<strong>请求头</strong>中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request Headers</span><br><span class="line">----------------</span><br><span class="line">	Cookie: username=zs</span><br></pre></td></tr></table></figure>
<h3 id="23-cookie的使用细节"><a class="markdownIt-Anchor" href="#23-cookie的使用细节"></a> 2.3 Cookie的使用细节</h3>
<p>在这节我们主要讲解两个知识，第一个是Cookie的存活时间，第二个是Cookie如何存储中文，首先来学习下Cookie的存活时间。</p>
<h4 id="231-cookie的存活时间"><a class="markdownIt-Anchor" href="#231-cookie的存活时间"></a> 2.3.1 Cookie的存活时间</h4>
<p>前面让大家思考过一个问题:</p>
<p>(1)浏览器发送请求给AServlet,AServlet会响应一个存有<code>usernanme=zs</code>的Cookie对象给浏览器</p>
<p>(2)浏览器接收到响应数据将cookie存入到浏览器内存中</p>
<p>(3)当浏览器再次发送请求给BServlet,BServlet就可以使用Request对象获取到Cookie数据</p>
<p>(4)在发送请求到BServlet之前，如果把浏览器关闭再打开进行访问，BServlet能否获取到Cookie数据?</p>
<p><strong>注意：浏览器关闭再打开不是指打开一个新的选显卡，而且必须是先关闭再打开，顺序不能变。</strong></p>
<p>针对上面这个问题，通过演示，会发现，BServlet中无法再获取到Cookie数据，这是为什么呢?</p>
<ul>
<li>默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁</li>
</ul>
<p>这个结论就印证了上面的演示效果，但是如果使用这种默认情况下的Cookie,有些需求就无法实现，比如:</p>
<p>网站的登录页面上有一个<code>记住我</code>的功能，这个功能大家都比较熟悉</p>
<ul>
<li>第一次输入用户名和密码并勾选<code>记住我</code>然后进行登录</li>
<li>下次再登陆的时候，用户名和密码就会被自动填充，不需要再重新输入登录</li>
<li>比如<code>记住我</code>这个功能需要记住用户名和密码一个星期，那么使用默认情况下的Cookie就会出现问题</li>
<li>因为默认情况，浏览器一关，Cookie就会从浏览器内存中删除，对于<code>记住我</code>功能就无法实现</li>
</ul>
<p>所以我们现在就遇到一个难题是如何将Cookie持久化存储?</p>
<p>Cookie其实已经为我们提供好了对应的API来完成这件事，这个API就是<strong>setMaxAge</strong>,</p>
<ul>
<li>设置Cookie存活时间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setMaxAge(int seconds)</span><br></pre></td></tr></table></figure>
<p>参数值为:</p>
<p>1.正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除</p>
<p>2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁</p>
<p>3.零：删除对应Cookie</p>
<p>接下来，咱们就在AServlet中去设置Cookie的存活时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/aServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//发送Cookie</span></span><br><span class="line">        <span class="comment">//1. 创建Cookie对象</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        <span class="comment">//设置存活时间   ，1周 7天</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>); <span class="comment">//易阅读，需程序计算</span></span><br><span class="line">    <span class="comment">//cookie.setMaxAge(604800); //不易阅读(可以使用注解弥补)，程序少进行一次计算</span></span><br><span class="line">        <span class="comment">//2. 发送Cookie，response</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完代码后，启动测试，访问<code>http://localhost:8080/cookie-demo/aServlet</code></p>
<ul>
<li>访问一个AServlet后，把浏览器关闭重启后，再去访问<code>http://localhost:8080/cookie-demo/bServet</code>,能在控制台打印出<code>username:zs</code>,说明Cookie没有随着浏览器关闭而被销毁</li>
<li>通过浏览器查看Cookie的内容，会发现Cookie的相关信息</li>
</ul>
<h4 id="232-cookie存储中文"><a class="markdownIt-Anchor" href="#232-cookie存储中文"></a> 2.3.2 Cookie存储中文</h4>
<p>首先，先来演示一个效果，将之前<code>username=zs</code>的值改成<code>username=张三</code>，把汉字<code>张三</code>存入到Cookie中，看是什么效果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/aServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//发送Cookie</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;username&quot;</span>,value);</span><br><span class="line">        <span class="comment">//设置存活时间   ，1周 7天</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//2. 发送Cookie，response</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动访问测试，访问<code>http://localhost:8080/cookie-demo/aServlet</code>会发现浏览器会提示错误信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP Status 500 -Control character in cookie value or attribute.</span><br></pre></td></tr></table></figure>
<p>通过上面的案例演示，我们得到一个结论:</p>
<ul>
<li>Cookie不能直接存储中文</li>
</ul>
<p>Cookie不能存储中文，但是如果有这方面的需求，这个时候该如何解决呢?</p>
<p>这个时候，我们可以使用之前学过的一个知识点叫<code>URL编码</code>，所以如果需要存储中文，就需要进行转码，具体的实现思路为:</p>
<blockquote>
<p>1.在AServlet中对中文进行URL编码，采用URLEncoder.encode()，将编码后的值存入Cookie中</p>
<p>2.在BServlet中获取Cookie中的值,获取的值为URL编码后的值</p>
<p>3.将获取的值在进行URL解码,采用URLDecoder.decode()，就可以获取到对应的中文值</p>
</blockquote>
<p>(1)在AServlet中对中文进行URL编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/aServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//发送Cookie</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="comment">//对中文进行URL编码</span></span><br><span class="line">        value = URLEncoder.encode(value, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;存储数据：&quot;</span>+value);</span><br><span class="line">        <span class="comment">//将编码后的值存入Cookie中</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;username&quot;</span>,value);</span><br><span class="line">        <span class="comment">//设置存活时间   ，1周 7天</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//2. 发送Cookie，response</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)在BServlet中获取值，并对值进行解码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/bServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取Cookie</span></span><br><span class="line">        <span class="comment">//1. 获取Cookie数组</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="comment">//2. 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="comment">//3. 获取数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;username&quot;</span>.equals(name))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();<span class="comment">//获取的是URL编码后的值 %E5%BC%A0%E4%B8%89</span></span><br><span class="line">                <span class="comment">//URL解码</span></span><br><span class="line">                value = URLDecoder.decode(value,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(name+<span class="string">&quot;:&quot;</span>+value);<span class="comment">//value解码后为 张三</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们就可以将中文存入Cookie中进行使用。</p>
<p><strong>小结</strong></p>
<p>Cookie的使用细节中，我们讲了Cookie的<code>存活时间</code>和<code>存储中文</code>:</p>
<ul>
<li>
<p>存活时间，需要掌握setMaxAage()API的使用</p>
</li>
<li>
<p>存储中文，需要掌握URL编码和解码的使用</p>
</li>
</ul>
<h2 id="3-session"><a class="markdownIt-Anchor" href="#3-session"></a> 3. Session</h2>
<p>Cookie已经能完成一次会话多次请求之间的数据共享，之前我们还提到过Session也可以实现，那么:</p>
<ul>
<li>什么是Session?</li>
<li>Session如何来使用?</li>
<li>Session是如何实现的?</li>
<li>Session的使用注意事项有哪些?</li>
</ul>
<h3 id="31-session的基本使用"><a class="markdownIt-Anchor" href="#31-session的基本使用"></a> 3.1 Session的基本使用</h3>
<p><strong>1.概念</strong></p>
<p><strong>Session</strong>：服务端会话跟踪技术：将数据保存到服务端。</p>
<ul>
<li>Session是存储在服务端而Cookie是存储在客户端</li>
<li>存储在客户端的数据容易被窃取和截获，存在很多不安全的因素</li>
<li>存储在服务端的数据相比于客户端来说就更安全</li>
</ul>
<p><strong>2.Session的工作流程</strong></p>
<p><img src="1629427173389.png" alt="1629427173389" /></p>
<ul>
<li>在服务端的AServlet获取一个Session对象，把数据存入其中</li>
<li>在服务端的BServlet获取到相同的Session对象，从中取出数据</li>
<li>就可以实现一次会话中多次请求之间的数据共享了</li>
<li>现在最大的问题是如何保证AServlet和BServlet使用的是同一个Session对象(在原理分析会讲解)?</li>
</ul>
<p><strong>3.Session的基本使用</strong></p>
<p>在JavaEE中提供了HttpSession接口，来实现一次会话的多次请求之间数据共享功能。</p>
<p>具体的使用步骤为:</p>
<ul>
<li>获取Session对象,使用的是request对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Session对象提供的功能:</p>
<ul>
<li>
<p>存储数据到 session 域中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setAttribute(String name, Object o)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据 key，获取值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object getAttribute(String name)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据 key，删除该键值对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void removeAttribute(String name)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>介绍完Session相关的API后，接下来通过一个案例来完成对Session的使用，具体实现步骤为:</p>
<blockquote>
<p>需求:在一个Servlet中往Session中存入数据，在另一个Servlet中获取Session中存入的数据</p>
<p>1.创建名为SessionDemo1的Servlet类</p>
<p>2.创建名为SessionDemo2的Servlet类</p>
<p>3.在SessionDemo1的方法中:获取Session对象、存储数据</p>
<p>4.在SessionDemo2的方法中:获取Session对象、获取数据</p>
<p>5.启动测试</p>
</blockquote>
<p>(1)创建名为SessionDemo1的Servlet类，然后 获取Session对象、存储数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      <span class="comment">//存储到Session中</span></span><br><span class="line">        <span class="comment">//1. 获取Session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2. 存储数据</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)创建名为SessionDemo2的Servlet类，然后 获取Session对象、获取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取数据，从session中</span></span><br><span class="line">        <span class="comment">//1. 获取Session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2. 获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)启动测试，</p>
<ul>
<li>先访问<code>http://localhost:8080/cookie-demo/demo1</code>,将数据存入Session</li>
<li>在访问<code>http://localhost:8080/cookie-demo/demo2</code>,从Session中获取数据</li>
<li>查看控制台：输出<code>zs</code></li>
</ul>
<p>通过案例的效果，能看到Session是能够在一次会话中两次请求之间共享数据。</p>
<p><strong>小结</strong></p>
<p>至此Session的基本使用就已经完成了，重点要掌握的是:</p>
<ul>
<li>
<p>Session的获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Session常用方法的使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setAttribute(String name, Object o)</span><br><span class="line">Object getAttribute(String name)</span><br></pre></td></tr></table></figure>
<p>**注意：**Session中可以存储的是一个Object类型的数据，也就是说Session中可以存储任意数据类型。</p>
</li>
</ul>
<p>介绍完Session的基本使用之后，那么Session的底层到底是如何实现一次会话两次请求之间的数据共享呢?</p>
<h3 id="32-session的原理分析"><a class="markdownIt-Anchor" href="#32-session的原理分析"></a> 3.2 Session的原理分析</h3>
<ul>
<li>Session是基于Cookie实现的</li>
</ul>
<p>这句话其实不太能详细的说明Session的底层实现，接下来，咱们一步步来分析下Session的具体实现原理:</p>
<p>(1)前提条件</p>
<p><img src="1629429063101.png" alt="1629429063101" /></p>
<p>Session要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取Session的对象是同一个。</p>
<p>那么它们是一个对象么？要验证这个结论也很简单，只需要在上面案例中的两个Servlet中分别打印下Session对象</p>
<p>SessionDemo1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      <span class="comment">//存储到Session中</span></span><br><span class="line">        <span class="comment">//1. 获取Session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        System.out.println(session);</span><br><span class="line">        <span class="comment">//2. 存储数据</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SessionDemo2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取数据，从session中</span></span><br><span class="line">        <span class="comment">//1. 获取Session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        System.out.println(session);</span><br><span class="line">        <span class="comment">//2. 获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动测试，分别访问</p>
<p><code>http://localhost:8080/cookie-demo/demo1</code></p>
<p><code>http://localhost:8080/cookie-demo/demo2</code></p>
<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.apache.catalina.session.StandardsessionFacaded4a3cf497</span><br><span class="line">org.apache.catalina.session.standardsessionFacaded4a3cf497</span><br></pre></td></tr></table></figure>
<p>通过打印可以得到如下结论:</p>
<ul>
<li>两个Servlet类中获取的Session对象是同一个</li>
<li>把demo1和demo2请求刷新多次，控制台最终打印的结果都是同一个</li>
</ul>
<p>那么问题又来了，如果新开一个浏览器，访问demo1或者demo2,打印在控制台的Session还是同一个对象么?</p>
<p><strong>注意:在一台电脑上演示的时候，如果是相同的浏览器必须要把浏览器全部关掉重新打开，才算新开的一个浏览器。</strong></p>
<p>当然也可以使用不同的浏览器进行测试，就不需要把之前的浏览器全部关闭。</p>
<p>测试的结果：如果是不同浏览器或者重新打开浏览器后，打印的Session就不一样了。</p>
<p>所以Session实现的也是一次会话中的多次请求之间的数据共享。</p>
<p>那么最主要的问题就来了，Session是如何保证在一次会话中获取的Session对象是同一个呢?</p>
<p><img src="1629430754825.png" alt="1629430754825" /></p>
<p>(1)demo1在第一次获取session对象的时候，session对象会有一个唯一的标识，假如是<code>id:10</code></p>
<p>(2)demo1在session中存入其他数据并处理完成所有业务后，需要通过Tomcat服务器响应结果给浏览器</p>
<p>(3)Tomcat服务器发现业务处理中使用了session对象，就会把session的唯一标识<code>id:10</code>当做一个cookie，添加<code>Set-Cookie:JESSIONID=10</code>到响应头中，并响应给浏览器</p>
<p>(4)浏览器接收到响应结果后，会把响应头中的coookie数据存储到浏览器的内存中</p>
<p>(5)浏览器在同一会话中访问demo2的时候，会把cookie中的数据按照<code>cookie: JESSIONID=10</code>的格式添加到请求头中并发送给服务器Tomcat</p>
<p>(6)demo2获取到请求后，从请求头中就读取cookie中的JSESSIONID值为10，然后就会到服务器内存中寻找<code>id:10</code>的session对象，如果找到了，就直接返回该对象，如果没有则新创建一个session对象</p>
<p>(7)关闭打开浏览器后，因为浏览器的cookie已被销毁，所以就没有JESSIONID的数据，服务端获取到的session就是一个全新的session对象</p>
<p>至此，<code>Session是基于Cookie来实现的</code>这就话，我们就解释完了，接下来通过实例来演示下:</p>
<p>(1)使用edgee浏览器访问<code>http://localhost:8080/cookie-demo/demo1</code>,打开开发者模式(F12或Ctrl+Shift+I),查看**响应头（Response Headers）**数据:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Response Headers</span><br><span class="line">----------------</span><br><span class="line">	Set-Cookie: JSESSIONID=5B8C524F0BD885BF277CD281724E7DC5</span><br></pre></td></tr></table></figure>
<p>(2)使用edgee浏览器再次访问<code>http://localhost:8080/cookie-demo/demo2</code>，查看**请求头（Request Headers）**数据:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request Headers</span><br><span class="line">----------------</span><br><span class="line">	Cookie: JSESSIONID=5B8C524F0BD885BF277CD281724E7DC5</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<p>介绍完Session的原理，我们只需要记住</p>
<ul>
<li>Session是基于Cookie来实现的</li>
</ul>
<h3 id="33-session的使用细节"><a class="markdownIt-Anchor" href="#33-session的使用细节"></a> 3.3 Session的使用细节</h3>
<p>这节我们会主要讲解两个知识，第一个是Session的钝化和活化，第二个是Session的销毁，首先来学习什么是Session的钝化和活化？</p>
<h4 id="331-session钝化与活化"><a class="markdownIt-Anchor" href="#331-session钝化与活化"></a> 3.3.1 Session钝化与活化</h4>
<p>首先需要大家思考的问题是:</p>
<ul>
<li>服务器重启后，Session中的数据是否还在?</li>
</ul>
<p>要想回答这个问题，我们可以先看下下面这幅图，</p>
<p><img src="1629427173389.png" alt="1629427173389" /></p>
<p>(1)服务器端AServlet和BServlet共用的session对象应该是存储在服务器的内存中</p>
<p>(2)服务器重新启动后，内存中的数据应该是已经被释放，对象也应该都销毁了</p>
<p>所以session数据应该也已经不存在了。但是如果session不存在会引发什么问题呢?</p>
<p>举个例子说明下，</p>
<p>(1)用户把需要购买的商品添加到购物车，因为要实现同一个会话多次请求数据共享，所以假设把数据存入Session对象中</p>
<p>(2)用户正要付钱的时候接到一个电话，付钱的动作就搁浅了</p>
<p>(3)正在用户打电话的时候，购物网站因为某些原因需要重启</p>
<p>(4)重启后session数据被销毁，购物车中的商品信息也就会随之而消失</p>
<p>(5)用户想再次发起支付，就会出为问题</p>
<p>所以说对于session的数据，我们应该做到就算服务器重启了，也应该能把数据保存下来才对。</p>
<p>分析了这么多，那么Tomcat服务器在重启的时候，session数据到底会不会保存以及是如何保存的，我们可以通过实际案例来演示下:</p>
<p><strong>注意:这里所说的关闭和启动应该要确保是正常的关闭和启动。</strong></p>
<p>那如何才是正常关闭Tomcat服务器呢?</p>
<p>需要使用命令行的方式来启动和停止Tomcat服务器:</p>
<p><strong>启动</strong>:进入到项目pom.xml所在目录，然后再命令行中执行<code>tomcat7:run</code></p>
<p><strong>停止</strong>:在启动的命令行界面，输入<code>ctrl+c</code></p>
<p>有了上述两个正常启动和关闭的方式后，接下来的测试流程是:</p>
<p>(1)先启动Tomcat服务器</p>
<p>(2)访问<code>http://localhost:8080/cookie-demo/demo1</code>将数据存入session中</p>
<p>(3)正确停止Tomcat服务器</p>
<p>(4)再次重新启动Tomcat服务器</p>
<p>(5)访问<code>http://localhost:8080/cookie-demo/demo2</code> 查看是否能获取到session中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制台输出：</span><br><span class="line">---------</span><br><span class="line">	zs</span><br></pre></td></tr></table></figure>
<p>经过测试，会发现只要服务器是正常关闭和启动，session中的数据是可以被保存下来的。</p>
<p>那么Tomcat服务器到底是如何做到的呢?</p>
<p>具体的原因就是:Session的钝化和活化:</p>
<ul>
<li>
<p>钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中</p>
<ul>
<li>钝化的数据路径为:<code>项目目录\target\tomcat\work\Tomcat\localhost\项目名称\SESSIONS.ser</code></li>
</ul>
</li>
<li>
<p>活化：再次启动服务器后，从文件中加载数据到Session中</p>
<ul>
<li>数据加载到Session中后，路径中的<code>SESSIONS.ser</code>文件会被删除掉</li>
</ul>
</li>
</ul>
<p>对于上述的整个过程，大家只需要了解下即可。因为所有的过程都是Tomcat自己完成的，不需要我们参与。</p>
<p><strong>小结</strong></p>
<p>Session的钝化和活化介绍完后，需要我们注意的是:</p>
<ul>
<li>
<p>session数据存储在服务端，服务器重启后，session数据会被保存</p>
</li>
<li>
<p>浏览器被关闭启动后，重新建立的连接就已经是一个全新的会话，获取的session数据也是一个新的对象</p>
</li>
<li>
<p>session的数据要想共享，浏览器不能关闭，所以session数据不能长期保存数据</p>
</li>
<li>
<p>cookie是存储在客户端，是可以长期保存</p>
</li>
</ul>
<h4 id="332-session销毁"><a class="markdownIt-Anchor" href="#332-session销毁"></a> 3.3.2 Session销毁</h4>
<p>session的销毁会有两种方式:</p>
<ul>
<li>
<p>默认情况下，无操作，30分钟自动销毁</p>
<ul>
<li>
<p>对于这个失效时间，是可以通过配置进行修改的</p>
<ul>
<li>
<p>在项目的web.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>100<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果没有配置，默认是30分钟，默认值是在Tomcat的web.xml配置文件中写死的</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>调用Session对象的invalidate()进行销毁</p>
<ul>
<li>
<p>在SessionDemo2类中添加session销毁的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取数据，从session中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 获取Session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        System.out.println(session);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁</span></span><br><span class="line">        session.invalidate();</span><br><span class="line">        <span class="comment">//2. 获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动访问测试，先访问demo1将数据存入到session，再次访问demo2从session中获取数据，此时网页报告错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP Status 500-getAttribute:Session already invalidated</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>该销毁方法一般会在用户退出的时候，需要将session销毁掉。</p>
</li>
</ul>
</li>
</ul>
<p><strong>Cookie和Session小结</strong></p>
<ul>
<li>Cookie 和 Session 都是来完成一次会话内多次请求间<strong>数据共享</strong>的。</li>
</ul>
<p>所需两个对象放在一块，就需要思考:</p>
<p>Cookie和Session的区别是什么?</p>
<p>Cookie和Session的应用场景分别是什么?</p>
<ul>
<li>区别:
<ul>
<li>存储位置：Cookie将数据存储在客户端的浏览器中，而Session将数据存储在服务器端的内存或数据库中。</li>
<li>安全性：由于Cookie存储在客户端，因此相对不安全，容易受到跨站脚本攻击等威胁；而Session存储在服务器端，相对安全性更高。</li>
<li>数据大小：Cookie通常有4KB的存储限制，而Session的大小受到服务器端配置的影响，一般没有固定的限制。</li>
<li>存储时间：Cookie可以通过设置过期时间setMaxAge()实现长期存储，而Session的默认存储时间一般较短，需要通过配置来调整。</li>
<li>服务器性能：由于Session数据存储在服务器端，因此会占用服务器的资源，而Cookie则不会占用服务器资源。</li>
</ul>
</li>
<li>应用场景:
<ul>
<li>购物车:使用Cookie来存储</li>
<li>以登录用户的名称展示:使用Session来存储</li>
<li>记住我功能:使用Cookie来存储</li>
<li>验证码:使用session来存储</li>
</ul>
</li>
<li>结论
<ul>
<li>Cookie主要用于在用户未登录的情况下进行身份识别。当用户首次访问网站时，服务器会生成一个唯一的标识符，并将其存储在客户端的Cookie中。以后用户每次请求该网站时，浏览器都会自动发送这个Cookie到服务器，从而实现身份的识别。通过使用Cookie，网站可以记住用户的登录状态，比如保持用户的登录凭证、记录用户的偏好设置等。</li>
<li>Session则是用来保存用户登录后的数据。用户在登录成功后，服务器会为该用户创建一个对应的Session对象，并将相关数据存储在该Session对象中。这样，在用户的不同请求之间，服务器可以通过Session来共享和持久化用户的数据。Session通常以键值对的形式存储数据，比如用户ID、用户名、权限信息等。通过Session，网站可以为每个用户维护独立的状态和数据，提供个性化的服务。</li>
</ul>
</li>
</ul>
<p>介绍完Cookie和Session以后，具体用哪个还是需要根据具体的业务进行具体分析。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>实用方法链接与方法</title>
    <url>/2023/11/28/%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p><code>&lt;big&gt;****&lt;/big&gt;</code></p>
<h2 id="1-idea如何删除项目"><a class="markdownIt-Anchor" href="#1-idea如何删除项目"></a> 1. IDEA如何删除项目</h2>
<p><a href="%5BIDEA%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E9%A1%B9%E7%9B%AE_idea%E5%88%A0%E9%99%A4%E9%A1%B9%E7%9B%AE-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/qq_25844803/article/details/107107952)">IDEA如何删除项目</a></p>
<h2 id="2-idea中如何快速创建servlet"><a class="markdownIt-Anchor" href="#2-idea中如何快速创建servlet"></a> 2. IDEA中如何快速创建Servlet</h2>
<p>[IDEA中如何快速创建Servlet](<a href="https://blog.csdn.net/onebumps/article/details/130661359">使用IDEA2023创建Servlet模板，使其右键显示Servlet选项_idea servlet模板_小事一撞的博客-CSDN博客</a>)，新建后会出现以下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javaee type: //选填</span><br><span class="line">entity name: //选填</span><br><span class="line">class name:  //**必填</span><br></pre></td></tr></table></figure>
<p>前两个可以不用填，只填<code>class name</code>即可完成创建。</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>在github pages的第一篇博客</title>
    <url>/2023/11/17/%E5%9C%A8github-pages%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="hexo部署相关命令"><a class="markdownIt-Anchor" href="#hexo部署相关命令"></a> Hexo部署相关命令</h1>
<ol>
<li>新建文章:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章名&quot;</span> <span class="comment">//相关文章会在博客目录source\_posts中显示，打开后直接编辑即可，已配好表头</span></span><br></pre></td></tr></table></figure>
<p>​	2.清除缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean || hexo cl        # 清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line"></span><br><span class="line">在使用 Hexo 进行博客开发时，可以在以下情况下使用 hexo clean 命令：</span><br><span class="line">清除缓存：当你对 Hexo 博客的配置或插件进行了修改后，可以使用 hexo clean 命令清除缓存，以便让 Hexo 重新生成静态文件，并确保新的配置和插件生效。</span><br><span class="line">重建站点：在某些情况下，你可能需要完全重建你的站点，这时可以先运行 hexo clean 清除之前生成的静态文件和缓存，然后再运行 hexo generate 重新生成静态文件。</span><br></pre></td></tr></table></figure>
<p>​	3.生成静态文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo generate || hexo g        # 生成静态文件</span><br></pre></td></tr></table></figure>
<p>​	4.启动服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server || hexo s          # 启动本地服务器</span><br></pre></td></tr></table></figure>
<p>​	5.部署网站：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy || hexo d          # 部署网站，上传到githubpages</span><br></pre></td></tr></table></figure>
<h1 id="感悟"><a class="markdownIt-Anchor" href="#感悟"></a> 感悟</h1>
<p>这是我在github pages上的第一篇博客，中间光搭建就花了我很长时间，原本图省事想在原生hexo写博客来，但是看到next很漂亮就搞了这个主题，搭建完成后我也很开心，虽然都是在网上到处找的答案。对我来说最大的困难不是技术，因为相关的像git、nodejs等环境早在很久之前就已经配好了，我是在主题挑选上犹豫不决浪费了太多的时间，大概又90%的时间是浪费的，怪自己太垃圾了，刚开始是跟着哔哩哔哩的视频部署了一个jekyll博客，嫌弃太丑，而且如果想在本地运行的话要配置ruby环境，我一是没学过，二是听说windows对ruby不友好，然后我就删了仓库，第二天又重新建了一个，一上来也是直接搞得next主题，没搞明白就删了换成了原生hexo，晚上就又换成了next，虽然我没有掌握很多的知识，但我知道了一旦配置好像hexo这样的博客框架，再去换主题的时候就很快，换next就很快，而且写文章的方法是通用的，只不过在不同的主题上的显示方式不同。我算是一个喜欢记录的人，我平常写日记，我希望把写博客坚持下去，虽然比别人晚了好多年。</p>
]]></content>
      <categories>
        <category>人生之路</category>
      </categories>
  </entry>
  <entry>
    <title>反射、注解</title>
    <url>/2023/12/10/%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-反射"><a class="markdownIt-Anchor" href="#1-反射"></a> 1. 反射</h2>
<p>介绍的反射、动态代理、注解等知识点，在以后开发中极少用到，这些技术都是以后学习框架、或者做框架的底层源码。</p>
<p>接下来，我们就需要带着同学们认识一下什么是反射。其实API文档中对反射有详细的说明，我们去了解一下。在java.lang.reflect包中对反射的解释如下图所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Package java.lang.reflect</span><br><span class="line">-------------------------</span><br><span class="line">提供用于获取有关类和对象的反射信息的类和接口。 Reflection允许以编程方式访问有关已加载类的字段，方法和构造函数的信息，以及使用反射字段，方法和构造函数在封装和安全限制内对其底层对应项进行操作。 </span><br></pre></td></tr></table></figure>
<p>翻译成人话就是：<strong>反射技术，指的是加载类的字节码到内存，并以编程的方法解刨出类中的各个成分（成员变量、方法、构造器等）。</strong></p>
<p>反射有啥用呢？其实反射是用来写框架用的。为了方便理解，举一个见过的例子：平时我们用IDEA开发程序时，用对象调用方法，IDEA会有代码提示，idea会将这个对象能调用的方法都给你列举出来，供你选择，如果下图所示</p>
<p><img src="1702175913311.png" alt="1702175913311" /></p>
<p>问题是IDEA怎么知道这个对象有这些方法可以调用呢? 原因是对象能调用的方法全都来自于类，IDEA通过反射技术就可以获取到类中有哪些方法，并且把方法的名称以提示框的形式显示出来，所以你能看到这些提示了。</p>
<p>那记事本写代码为什么没有提示呢? 因为技术本软件没有利用反射技术开发这种代码提示的功能！</p>
<p>认识了反射是什么之后，介绍一下反射具体学什么？</p>
<p>因为反射获取的是类的信息，那么反射的第一步首先获取到类才行。由于Java的设计原则是万物皆对象，获取到的类其实也是以对象的形式体现的，<strong>叫字节码对象</strong>，用<mark>Class类</mark>来表示。获取到字节码对象之后，再通过字节码对象就可以获取到类的组成成分了，这些组成成分其实也是对象，其中<strong>每一个成员变量用Field类的对象来表示</strong>、<strong>每一个成员方法用Method类的对象来表示</strong>，<strong>每一个构造器用Constructor类的对象来表示</strong>。</p>
<p>如下图所示：</p>
<blockquote>
<p>反射学什么？</p>
<p>学习获取类的信息、操作它们</p>
<ol>
<li>反射第一步：加载类，获取类的字节码：Class对象</li>
<li>获取类的构造器：Constructor对象</li>
<li>获取类的成员变量：Field对象</li>
<li>获取类的成员方法：Method对象</li>
</ol>
</blockquote>
<h3 id="11-获取类的字节码"><a class="markdownIt-Anchor" href="#11-获取类的字节码"></a> 1.1 获取类的字节码</h3>
<p>反射的第一步：是将字节码加载到内存，我们需要获取到字节码对象。</p>
<pre><code class="highlight mermaid">graph LR;
1.反射第一步:加载类,获取类的字节码:Class对象

A[Student.java] --&gt; B[Student.class]
B --字节码文件加载到内存中--&gt; C[内存中的Student.class]</code></pre>
<p>比如有一个Student类，获取Student类的字节码代码有三种写法。不管用哪一种方式，获取到的字节码对象其实是同一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1Class</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">//获取全类名 com.itheima.Student</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">//获取简单类名 Student</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.Student&quot;</span>);</span><br><span class="line">        System.out.println(c1 == c2); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">        System.out.println(c2 == c3); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-获取类的构造器"><a class="markdownIt-Anchor" href="#12-获取类的构造器"></a> 1.2 获取类的构造器</h3>
<p>学习一下通过字节码对象获取构造器，并使用构造器创建对象。</p>
<p>获取构造器，需要用到Class类提供的几个方法，如下图所示：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Constructor&lt;?&gt;[] getConstructors()</code></td>
<td>获取全部构造器（只能获取public修饰的）</td>
</tr>
<tr>
<td><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code></td>
<td>获取全部构造器（只要存在就能拿到）</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取某个构造器（只能获取public修饰的）</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取某个构造器（只要存在就能拿到）</td>
</tr>
</tbody>
</table>
<p>这些方法的命名规律:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">get:获取</span><br><span class="line">Declared: 有这个单词表示可以获取任意一个，没有这个单词表示只能获取一个<span class="keyword">public</span>修饰的</span><br><span class="line">Constructor: 构造方法的意思</span><br><span class="line">后缀s: 表示可以获取多个，没有后缀s只能获取一个</span><br></pre></td></tr></table></figure>
<p>话不多少，上代码。假设现在有一个Cat类，里面有几个构造方法，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<ol>
<li>接下来，我们写一个测试方法，来测试获取类中所有的构造器</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2Constructor</span>()&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：必须先得到这个类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类的全部构造器</span></span><br><span class="line">        Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">//3、遍历数组中的每一个构造器对象。</span></span><br><span class="line">        <span class="keyword">for</span>(Constructor constructor: constructors)&#123;</span><br><span class="line">            System.out.println(constructor.getName()+<span class="string">&quot;---&gt; 参数个数：&quot;</span>+constructor.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试方法打印结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.reflect.Cat---&gt; 参数个数：0</span><br><span class="line">com.itheima.reflect.Cat---&gt; 参数个数：2</span><br></pre></td></tr></table></figure>
<ul>
<li>
<ol start="2">
<li>刚才演示的是获取Cat类中所有的构造器，接下来，我们演示单个构造器试一试</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2Constructor</span>()&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetConstructor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：必须先得到这个类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类public修饰的空参数构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> c.getConstructor();</span><br><span class="line">        System.out.println(constructor1.getName()+<span class="string">&quot;---&gt; 参数个数：&quot;</span>+constructor1.getParameterCount());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、获取private修饰的有两个参数的构造器，第一个参数String类型，第二个参数int类型</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> </span><br><span class="line">            c.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        </span><br><span class="line">        System.out.println(constructor2.getName()+<span class="string">&quot;---&gt; 参数个数：&quot;</span>+constructor2.getParameterCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.reflect.Cat---&gt; 参数个数：0</span><br><span class="line">com.itheima.reflect.Cat---&gt; 参数个数：2</span><br></pre></td></tr></table></figure>
<h3 id="13-反射获取构造器的作用"><a class="markdownIt-Anchor" href="#13-反射获取构造器的作用"></a> 1.3 反射获取构造器的作用</h3>
<p>其实构造器的作用：<strong>初始化对象并返回</strong>。</p>
<p>这里我们需要用到如下的两个方法，注意：这两个方法时属于Constructor的，需要用Constructor对象来调用。</p>
<table>
<thead>
<tr>
<th>Constructor提供的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T newInstance(Object... initargs)</code></td>
<td>创建并返回此构造器对象表示的类的新实例，传入参数用于完成对象的初始化</td>
</tr>
<tr>
<td><code>public void setAccessible(boolean flag)</code></td>
<td>设置为true，表示禁止检查访问控制（使用暴力反射），也就是允许访问那些通常被限制访问的字段、方法或构造函数。</td>
</tr>
</tbody>
</table>
<p>constructor1和constructor2分别表示Cat类中的两个构造器。现在我要把这两个构造器执行起来</p>
<p>由于构造器是private修饰的，先需要调用<code>setAccessible(true)</code> 表示禁止检查访问控制，然后再调用<code>newInstance(实参列表)</code> 就可以执行构造器，完成对象的初始化了。</p>
<blockquote>
<p>实际上，调用<code>setAccessible(true)</code>方法表示取消对访问控制权限的检查，也就是允许访问那些通常被限制访问的字段、方法或构造函数。</p>
<p>具体来说，在Java中，当一个成员（字段、方法或构造函数）被声明为private、protected或默认访问修饰符时，通常只能在同一类内部进行访问。但是，通过使用反射并调用<code>setAccessible(true)</code>方法，可以绕过这些访问限制，从而在其他类中访问私有成员。</p>
<p>请注意，这种绕过访问控制的行为可能会违反面向对象编程的封装原则，并且可能导致代码的可维护性和可读性下降。因此，在正常情况下，应该避免滥用<code>setAccessible(true)</code>方法，只在必要的情况下使用。</p>
</blockquote>
<p>代码如下：为了看到构造器真的执行， 故意在两个构造器中分别加了两个打印语句</p>
<p><img src="1668579315586.png" alt="1668579315586" /></p>
<p>代码的执行结果如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.reflect.Cat---&gt; 参数个数：0</span><br><span class="line">无参数构造器执行了~~</span><br><span class="line">Cat&#123;name=&#x27;null&#x27;, age=0&#125;</span><br><span class="line">com.itheima.reflect.Cat---&gt; 参数个数：2</span><br><span class="line">有参数构造器执行了~~</span><br><span class="line">Cat&#123;name=&#x27;叮当猫&#x27;, age=3&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-反射获取成员变量使用"><a class="markdownIt-Anchor" href="#14-反射获取成员变量使用"></a> 1.4 反射获取成员变量&amp;使用</h3>
<p>其实套路是一样的，在Class类中提供了获取成员变量的方法，如下图所示。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public Field[] getFields()</code></td>
<td>获取类的全部成员变量（只能获取public修饰的）</td>
</tr>
<tr>
<td><code>public Field[] getDeclaredFields()</code></td>
<td>获取类的全部成员变量（只要存在就能拿到，无论访问修饰符如何）</td>
</tr>
<tr>
<td><code>public Field getField(String name)</code></td>
<td>获取类的某个成员变量（只能获取public修饰的）</td>
</tr>
<tr>
<td><code>public Field getDeclaredField(String name)</code></td>
<td>获取类的某个成员变量（只要存在就能拿到，无论访问修饰符如何）</td>
</tr>
</tbody>
</table>
<p>这些方法的记忆规则，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">get:获取</span><br><span class="line">Declared: 有这个单词表示可以获取任意一个，没有这个单词表示只能获取一个<span class="keyword">public</span>修饰的</span><br><span class="line">Field: 成员变量的意思</span><br><span class="line">后缀s: 表示可以获取多个，没有后缀s只能获取一个</span><br></pre></td></tr></table></figure>
<ul>
<li>假设有一个Cat类它有若干个成员变量，用Class类提供 的方法将成员变量的对象获取出来。</li>
</ul>
<p><img src="1668579681294.png" alt="1668579681294" /></p>
<p>执行完上面的代码之后，我们可以看到控制台上打印输出了，每一个成员变量的名称和它的类型。</p>
<p><img src="1702183690733.png" alt="1668579804732" /></p>
<ul>
<li>获取到成员变量的对象之后该如何使用呢？</li>
</ul>
<p>在Filed类中提供给给成员变量赋值和获取值的方法，如下图所示。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void set(Object obj, Object value)</code></td>
<td><code>obj</code>: 要设置属性值的对象实例。<code>value</code>: 要设置的属性值</td>
<td>设置对象的属性值</td>
</tr>
<tr>
<td><code>Object get(Object obj)</code></td>
<td><code>obj</code>: 要获取属性值的对象实例</td>
<td>获取对象的属性值</td>
</tr>
<tr>
<td><code>public void setAccessible(boolean flag)</code></td>
<td><code>flag</code>: 是否取消访问控制检查</td>
<td>设置访问权限（通过暴力反射取消访问控制），若设置为 <code>true</code>，则取消检查，允许使用暴力反射修改对象的私有属性或调用私有方法。</td>
</tr>
</tbody>
</table>
<p><mark>再次强调一下设置值、获取值的方法时Filed类的需要用Filed类的对象来调用，而且不管是设置值、还是获取值，都需要依赖于该变量所属的对象</mark>。代码如下</p>
<p><img src="1668580288930.png" alt="1668580288930" /></p>
<p>执行代码，控制台会有如下的打印</p>
<p><img src="1668580517173.png" alt="1668580517173" /></p>
<h3 id="15-反射获取成员方法"><a class="markdownIt-Anchor" href="#15-反射获取成员方法"></a> 1.5 反射获取成员方法</h3>
<p>在Java中反射包中，每一个成员方法用Method对象来表示，通过Class类提供的方法可以获取类中的成员方法对象。如下下图所示</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Method[] getMethods()</code></td>
<td>获取类的全部成员方法（只能获取 public 修饰的）</td>
</tr>
<tr>
<td><code>Method[] getDeclaredMethods()</code></td>
<td>获取类的全部成员方法（只要存在就能拿到）</td>
</tr>
<tr>
<td><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取类的某个成员方法（只能获取 public 修饰的）</td>
</tr>
<tr>
<td><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取类的某个成员方法（只要存在就能拿到）</td>
</tr>
</tbody>
</table>
<p>接下来我们还是用代码演示一下：假设有一个Cat类，在Cat类中红有若干个成员方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空参数构造方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造方法执行了&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(&gt;^ω^&lt;)喵跑得贼快~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(&gt;^ω^&lt;)喵爱吃猫粮~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">eat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&gt;^ω^&lt;)喵爱吃:&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，通过反射获取Cat类中所有的成员方法，每一个成员方法都是一个Method对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3Method</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：先获取到Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类中的全部成员方法</span></span><br><span class="line">        Method[] methods = c.getDecalaredMethods();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、遍历这个数组中的每一个方法对象</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            System.out.println(method.getName()+<span class="string">&quot;--&gt;&quot;</span>+method.getParameterCount()+<span class="string">&quot;--&gt;&quot;</span>+method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，运行结果如下图所示：<strong>打印输出每一个成员方法的名称、参数格式、返回值类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getName--&gt;0--&gt;class java.lang.String</span><br><span class="line">run--&gt;0--&gt;void</span><br><span class="line">setName--&gt;1--&gt;void</span><br><span class="line">getAge--&gt;0--&gt;int</span><br><span class="line">eat--&gt;1--&gt;class java.lang.String</span><br><span class="line">eat--&gt;0--&gt;void</span><br><span class="line">setAge--&gt;1--&gt;void</span><br></pre></td></tr></table></figure>
<p>也能获取单个指定的成员方法，如下图所示</p>
<p><img src="1668581678388.png" alt="1668581678388" /></p>
<hr />
<p><strong>获取到成员方法之后，有什么作用呢？</strong></p>
<p>在Method类中提供了方法，可以将方法自己执行起来。</p>
<table>
<thead>
<tr>
<th>Method类中提供的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public Object invoke(Object obj, Object... args)</code></td>
<td>触发某个对象的特定方法执行,<code>obj</code>: 要调用该方法的对象  <code>args</code>: 该方法的输入参数</td>
</tr>
<tr>
<td><code>public void setAccessible(boolean flag)</code></td>
<td>设置访问权限（通过暴力反射取消访问控制），若设置为 <code>true</code>，则取消检查，允许使用暴力反射修改对象的私有属性或调用私有方法。</td>
</tr>
</tbody>
</table>
<p>把<code>run()</code>方法和<code>eat(String name)</code>方法执行起来。看分割线之下的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3Method</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：先获取到Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类中的全部成员方法</span></span><br><span class="line">        Method[] methods = c.getDecalaredMethods();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、遍历这个数组中的每一个方法对象</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            System.out.println(method.getName()+<span class="string">&quot;--&gt;&quot;</span>+method.getParameterCount()+<span class="string">&quot;--&gt;&quot;</span>+method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4、获取private修饰的run方法，得到Method对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDecalaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="comment">//执行run方法,在执行前需要取消权限检查</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        run.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rs1</span> <span class="operator">=</span> run.invoke(cat);</span><br><span class="line">        System.out.println(rs1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、获取private 修饰的eat(String name)方法，得到Method对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        eat.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rs2</span> <span class="operator">=</span> eat.invoke(cat,<span class="string">&quot;鱼儿&quot;</span>);</span><br><span class="line">        System.out.println(rs2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下图所示：run()方法执行后打印<code>猫跑得贼快~~</code>，返回<code>null</code>； eat()方法执行完，直接返回<code>猫最爱吃:鱼儿</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空参数构造方法执行了</span><br><span class="line">(&gt;^ω^&lt;)喵跑得贼快~~</span><br><span class="line">null</span><br><span class="line">(&gt;^ω^&lt;)喵爱吃:鱼儿</span><br></pre></td></tr></table></figure>
<h3 id="16-反射的应用"><a class="markdownIt-Anchor" href="#16-反射的应用"></a> 1.6 反射的应用</h3>
<p>反射的核心作用是用来获取类的各个组成部分并执行他们。一直说反射使用来写框架的，接下来，我们就写一个简易的框架。</p>
<p>需求是让我们写一个框架，能够将任意一个对象的属性名和属性值写到文件中去。不管这个对象有多少个属性，也不管这个对象的属性名是否相同。</p>
<p>分析一下该怎么做</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>先写好两个类，一个Student类和Teacher类</span><br><span class="line"><span class="number">2.</span>写一个ObjectFrame类代表框本架</span><br><span class="line">  在ObjectFrame类中定义一个saveObject(Object obj)方法，用于将任意对象存到文件中去</span><br><span class="line">  参数：Object obj: 就表示要存入文件中的对象</span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>编写方法内部的代码，往文件中存储对象的属性名和属性值</span><br><span class="line">  <span class="number">1</span>)参数obj对象中有哪些属性，属性名是什么实现值是什么，中有对象自己最清楚。</span><br><span class="line">  <span class="number">2</span>)接着就通过反射获取类的成员变量信息了（变量名、变量值）</span><br><span class="line">  <span class="number">3</span>)把变量名和变量值写到文件中去</span><br></pre></td></tr></table></figure>
<p>写一个ObjectFrame表示自己设计的框架，代码如下图所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectFrame</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\Users\\cmy\\Desktop\\data.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">//1)参数obj对象中有哪些属性，属性名是什么实现值是什么，中有对象自己最清楚。</span></span><br><span class="line">        <span class="comment">//2)接着就通过反射获取类的成员变量信息了（变量名、变量值）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> obj.getClass(); <span class="comment">//获取字节码</span></span><br><span class="line"></span><br><span class="line">        ps.println(<span class="string">&quot;---------&quot;</span>+c.getSimpleName()+<span class="string">&quot;---------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Field[] fields = c.getDeclaredFields(); <span class="comment">//获取所有成员变量</span></span><br><span class="line">        <span class="comment">//3)把变量名和变量值写到文件中去</span></span><br><span class="line">        <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>); <span class="comment">// 解除对私有成员的访问限制</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj);</span><br><span class="line">            ps.println(name + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用自己设计的框架，往文件中写入Student对象的信息和Teacher对象的信息。</p>
<p>先准备好Student类和Teacher类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> sex, <span class="type">double</span> height, String hobby)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个测试类，在测试中类创建一个Student对象，创建一个Teacher对象，用ObjectFrame的方法把这两个对象所有的属性名和属性值写到文件中去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5Frame</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;黑马吴彦祖&quot;</span>,<span class="number">45</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">185.3</span>, <span class="string">&quot;篮球，冰球，阅读&quot;</span>);</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;播妞&quot;</span>,<span class="number">999.9</span>);</span><br><span class="line">        </span><br><span class="line">        ObjectFrame.save(s1);</span><br><span class="line">        ObjectFrame.save(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开data.txt文件，内容如下图所示，就说明我们这个框架的功能已经实现了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------Student---------</span><br><span class="line">name=黑马吴彦祖</span><br><span class="line">age=45</span><br><span class="line">sex=男</span><br><span class="line">height=185.3</span><br><span class="line">hobby=篮球，冰球，阅读</span><br><span class="line">---------Teacher---------</span><br><span class="line">name=播妞</span><br><span class="line">salary=999.9</span><br></pre></td></tr></table></figure>
<h2 id="2-注解"><a class="markdownIt-Anchor" href="#2-注解"></a> 2. 注解</h2>
<h3 id="21-认识注解定义注解"><a class="markdownIt-Anchor" href="#21-认识注解定义注解"></a> 2.1 认识注解&amp;定义注解</h3>
<blockquote>
<p><strong>先来认识一下什么是注解？</strong></p>
</blockquote>
<p><strong>Java注解是代码中的特殊标记，比如@Override、@Test等，作用是让其他程序根据注解信息决定怎么执行该程序。</strong></p>
<p>比如：Junit框架的@Test注解可以用在方法上，用来标记这个方法是测试方法，被@Test标记的方法能够被Junit框架执行。</p>
<p>再比如：@Override注解可以用在方法上，用来标记这个方法是重写方法，被@Override注解标记的方法能够被IDEA识别进行语法检查。</p>
<ul>
<li><strong>注解不光可以用在方法上，还可以用在类上、变量上、构造器上等位置。</strong></li>
</ul>
<p>上面我们说的@Test注解、@Overide注解是别人定义好给我们用的，将来如果需要自己去开发框架，就需要我们自己定义注解。</p>
<blockquote>
<p><strong>接着我们学习自定义注解</strong></p>
</blockquote>
<p>自定义注解的格式如下图所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public @interface 注解名称 &#123;</span><br><span class="line">    public 树形类型 属性名() default 默认值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如：现在我们自定义一个MyTest注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">    String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>; <span class="comment">//default true 表示默认值为true,使用时可以不赋值。</span></span><br><span class="line">    String[] ccc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好MyTest注解之后，我们可以使用MyTest注解在类上、方法上等位置做标记。注意使用注解时需要加@符号，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyTest1(aaa=&quot;牛魔王&quot;,ccc=&#123;&quot;HTML&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest1</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest(aaa=&quot;铁扇公主&quot;,bbb=false, ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：当注解中只有一个属性且其名称为&quot;value&quot;时，可以省略&quot;value&quot;这个属性名，直接写属性值即可。比如现在重新定义一个MyTest2注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest2&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; <span class="comment">//特殊属性</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好MyTest2注解后，再将@MyTest2标记在类上，此时value属性名可以省略，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyTest2(&quot;孙悟空&quot;)</span> <span class="comment">//等价于 @MyTest2(value=&quot;孙悟空&quot;)</span></span><br><span class="line"><span class="meta">@MyTest1(aaa=&quot;牛魔王&quot;,ccc=&#123;&quot;HTML&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest1</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest(aaa=&quot;铁扇公主&quot;,bbb=false, ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里关于定义注解的格式、以及使用注解的格式就学习完了。</p>
<blockquote>
<p><strong>注解本质是什么呢？</strong></p>
</blockquote>
<p>想要搞清楚注解本质是什么东西，我们可以把注解的字节码进行反编译，使用XJad工具进行反编译。经过对MyTest1注解字节码反编译我们会发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>MyTest1注解本质上是接口，每一个注解接口都继承子Annotation接口</span><br><span class="line"><span class="number">2.</span>MyTest1注解中的属性本质上是抽象方法</span><br><span class="line"><span class="number">3.</span><span class="meta">@MyTest1</span>实际上是作为MyTest接口的实现类对象</span><br><span class="line"><span class="number">4.</span><span class="meta">@MyTest1(aaa=&quot;孙悟空&quot;,bbb=false,ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)</span>里面的属性值，可以通过调用aaa()、bbb()、ccc()方法获取到。 【别着急，继续往下看，再解析注解时会用到】</span><br></pre></td></tr></table></figure>
<h3 id="22-元注解"><a class="markdownIt-Anchor" href="#22-元注解"></a> 2.2 元注解</h3>
<blockquote>
<p><strong>什么是元注解？</strong></p>
</blockquote>
<p><strong>元注解是修饰注解的注解</strong>。这句话虽然有一点饶，但是非常准确。我们看一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME) //@Retention注解是修饰Test注解的注解</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;) //@Target注解是修饰Test注解的注解</span><br><span class="line"></span><br><span class="line">//这是自定义的Test注解</span><br><span class="line">public @interface Test &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来分别看一下@Target注解和@Retention注解有什么作用，如下图所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>是用来声明注解只能用在那些位置，比如：类上、方法上、成员变量上等</span><br><span class="line"><span class="meta">@Retetion</span>是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期</span><br></pre></td></tr></table></figure>
<p><mark>@Target</mark></p>
<blockquote>
<p>@Target 作用：声明被修饰的注解只能在哪些位置使用</p>
<p>@Target(ElementType.TYPE)</p>
<ol>
<li>TYPE：类，接口</li>
<li>FIELD：成员变量</li>
<li>METHOD：成员方法</li>
<li>PARAMETER：方法参数</li>
<li>CONSTRUCTOR：构造器</li>
<li>LOCAL_VARIABLE：局部变量</li>
</ol>
</blockquote>
<p><mark>@Retention</mark></p>
<blockquote>
<p>@Retention 作用：指定注解的保留策略周期。</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<ol>
<li>
<p>SOURCE（源码级别）<br />
仅在源码阶段有效，不会被保留到编译后的字节码文件中。</p>
</li>
<li>
<p>CLASS（默认值）<br />
在编译后的字节码文件中保留，但在运行阶段不起作用。</p>
</li>
<li>
<p>RUNTIME（开发常用）<br />
在运行阶段一直保留有效。这是开发中常用的保留策略。</p>
</li>
</ol>
</blockquote>
<ul>
<li>@Target元注解的使用：比如定义一个MyTest3注解，并添加@Target注解用来声明MyTest3的使用位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> <span class="comment">//声明@MyTest3注解只能用在类上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest3&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们定义MyTest3注解时，使用@Target注解属性值写成下面样子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明@MyTest3注解只能用在类上和方法上</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest3&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里@Target元注解的使用就演示完毕了。</p>
<ul>
<li>@Retetion元注解的使用：定义MyTest3注解时，给MyTest3注解添加@Retetion注解来声明MyTest3注解保留的时期</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retetion</span>是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期</span><br><span class="line">  <span class="meta">@Retetion(RetetionPloicy.SOURCE)</span>: 注解保留到源代码时期、字节码中就没有了</span><br><span class="line">  <span class="meta">@Retetion(RetetionPloicy.CLASS)</span>: 注解保留到字节码中、运行时注解就没有了</span><br><span class="line">  <span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span>：注解保留到运行时期</span><br><span class="line">  【自己写代码时，比较常用的是保留到运行时期】</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明@MyTest3注解只能用在类上和方法上</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span>  </span><br><span class="line"><span class="comment">//控制使用了@MyTest3注解的代码中，@MyTest3保留到运行时期</span></span><br><span class="line"><span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest3&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-解析注解"><a class="markdownIt-Anchor" href="#23-解析注解"></a> 2.3 解析注解</h3>
<p>可以通过反射技术把类上、方法上、变量上的注解对象获取出来，然后通过调用方法就可以获取注解上的属性值了。<strong>把获取类上、方法上、变量上等位置注解及注解属性值的过程称为解析注解。</strong></p>
<p>解析注解套路如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>如果注解在类上，先获取类的字节码对象，再获取类上的注解</span><br><span class="line"><span class="number">2.</span>如果注解在方法上，先获取方法对象，再获取方法上的注解</span><br><span class="line"><span class="number">3.</span>如果注解在成员变量上，先获取成员变量对象，再获取变量上的注解</span><br><span class="line">总之：注解在谁身上，就先获取谁，再用谁获取谁身上的注解</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Class、Method、Field,Constructor、都实现了AnnotatedElement接口，它们都拥有解析注解的能力。</p>
<table>
<thead>
<tr>
<th><strong>AnnotatedElement接口提供了解析注解的方法</strong></th>
<th>说明</th>
<th>参数含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public Annotation[] getDeclaredAnnotations()</code></td>
<td>获取当前对象上面的注解</td>
<td>无</td>
</tr>
<tr>
<td><code>public T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></td>
<td>获取指定的注解对象</td>
<td><code>annotationClass</code>：要获取的注解类型的Class</td>
</tr>
<tr>
<td><code>public boolean isAnnotationPresent(Class&lt;Annotation&gt; annotationClass)</code></td>
<td>判断当前对象上是否存在某个注解</td>
<td><code>annotationClass</code>：要判断的注解类型的Class</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>解析来看一个案例，来演示解析注解的代码编写</p>
<p>按照需求要求一步一步完成</p>
<p>① 先定义一个MyTest4注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明@MyTest4注解只能用在类上和方法上</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span>  </span><br><span class="line"><span class="comment">//控制使用了@MyTest4注解的代码中，@MyTest4保留到运行时期</span></span><br><span class="line"><span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest4&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">aaa</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">    String[] bbb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 定义有一个类Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyTest4(value=&quot;蜘蛛侠&quot;,aaa=99.9, bbb=&#123;&quot;至尊宝&quot;,&quot;黑马&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest4(value=&quot;孙悟空&quot;,aaa=199.9, bbb=&#123;&quot;紫霞&quot;,&quot;牛夫人&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③ 写一个测试类AnnotationTest3解析Demo类上的MyTest4注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest3</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.先获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Demo.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.解析Demo类上的注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(MyTest4.class))&#123;</span><br><span class="line">            <span class="comment">//获取类上的MyTest4注解</span></span><br><span class="line">            <span class="type">MyTest4</span> <span class="variable">myTest4</span> <span class="operator">=</span> (MyTest4)c.getDeclaredAnnotation(MyTest4.class);</span><br><span class="line">            <span class="comment">//获取MyTests4注解的属性值</span></span><br><span class="line">            System.out.println(myTest4.value());</span><br><span class="line">            System.out.println(myTest4.aaa());</span><br><span class="line">            System.out.println(myTest4.bbb());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.先获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Demo.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.解析Demo类中test1方法上的注解MyTest4注解</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(m.isAnnotationPresent(MyTest4.class))&#123;</span><br><span class="line">            <span class="comment">//获取方法上的MyTest4注解</span></span><br><span class="line">            <span class="type">MyTest4</span> <span class="variable">myTest4</span> <span class="operator">=</span> (MyTest4)m.getDeclaredAnnotation(MyTest4.class);</span><br><span class="line">            <span class="comment">//获取MyTests4注解的属性值</span></span><br><span class="line">            System.out.println(myTest4.value());</span><br><span class="line">            System.out.println(myTest4.aaa());</span><br><span class="line">            System.out.println(myTest4.bbb());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
